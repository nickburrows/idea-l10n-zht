assertequals.between.inconvertible.types.display.name='assertEquals()' 位于不可转换类型的对象之间
can.t.build.uast.tree.for.file=无法为文件构建 UAST 树
current.version=当前版本:
dialog.title.choose.annotation=选择 {0}
inspection.message.illegal.dependency.module.doesn.t.export=非法依赖: 模块 ''{0}'' 不导出软件包 ''{1}''
jvm.inspection.logging.condition.disagrees.with.log.statement.display.name=日志条件与日志记录调用不匹配
jvm.inspection.logging.condition.disagrees.with.log.statement.problem.descriptor=条件 ''{0}'' 的级别与日志记录调用 ''{1}'' 的级别不匹配
jvm.inspection.logging.placeholder.count.matches.argument.count.display.name=占位符数量与日志调用中的实参数量不匹配
jvm.inspection.logging.placeholder.count.matches.argument.count.fewer.problem.descriptor=提供的实形参量({0})少于指定的占位符数({1}) #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.fewer.problem.partial.descriptor=提供的实参量({0})少于指定的占位符数(至少 {1}) #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.incorrect.problem.descriptor=非法格式字符串指定符 #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.more.problem.descriptor=提供的实形参量({0})多于指定的占位符({1}) #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option=SLF4J 将 Log4j 2 用作实现
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.auto=自动检查
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.no=否
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.yes=是
jvm.inspection.logging.string.template.as.argument.all.levels.option=所有日志级别
jvm.inspection.logging.string.template.as.argument.debug.level.and.lower.option=调试级别和更低
jvm.inspection.logging.string.template.as.argument.display.name=字符串模板作为日志记录调用的实参
jvm.inspection.logging.string.template.as.argument.info.level.and.lower.option=信息级别和更低
jvm.inspection.logging.string.template.as.argument.problem.descriptor=作为 <code>#ref()</code> 日志记录调用实参的字符串模板 #loc
jvm.inspection.logging.string.template.as.argument.quickfix.name=替换为占位符
jvm.inspection.logging.string.template.as.argument.skip.on.primitives=仅包含具有基元类型的表达式、其包装器或字符串时不发出警告
jvm.inspection.logging.string.template.as.argument.trace.level.option=跟踪级别
jvm.inspection.logging.string.template.as.argument.warn.level.and.lower.option=警告级别和更低
jvm.inspection.logging.string.template.as.argument.warn.on.label=警告对象:
jvm.inspection.test.failed.line.display.name=测试中失败的行
jvm.inspections.1.5.problem.descriptor=使用记录为 @since {0}+ 的 API
jvm.inspections.1.7.problem.descriptor=使用自 1.6 以来通用的 API，这可能会导致 JDK {0} 出现编译问题。
jvm.inspections.1.8.problem.descriptor=默认{0, choice, 0#|1#方法|2#方法}不会被重写。它会导致 JDK {1} 出现编译问题
jvm.inspections.1.8.problem.single.descriptor=默认方法 ''{0}'' 不会被重写。它会导致 JDK {1} 出现编译问题
jvm.inspections.api.display.name=使用在配置的语言级别下不可用的 API
jvm.inspections.api.no.extension.class.description=不得扩展类 ''{0}''
jvm.inspections.api.no.extension.display.name=不应扩展类、接口或方法
jvm.inspections.api.no.extension.interface.extend.description=不得扩展接口 ''{0}''
jvm.inspections.api.no.extension.interface.implement.description=不得实现接口 ''{0}''
jvm.inspections.api.no.extension.method.overriding.description=不得重写方法 ''{0}''
jvm.inspections.api.override.only.description=方法 ''{0}'' 只能重写
jvm.inspections.api.override.only.display.name=方法只能重写
jvm.inspections.assertequals.between.inconvertible.types.problem.descriptor=<code>#ref()</code> 位于 ''{0}'' 和 ''{1}'' 不可转换类型的对象之间 #loc
jvm.inspections.assertnotequals.between.inconvertible.types.problem.descriptor=可能的冗余断言: 比较不兼容的类型 ''{0}'' 和 ''{1}''
jvm.inspections.assertnotsame.between.inconvertible.types.problem.descriptor=冗余断言: 比较不兼容的类型 ''{0}'' 和 ''{1}''
jvm.inspections.blocking.method.annotation.blocking=阻塞注解:
jvm.inspections.blocking.method.annotation.configure.add.blocking.title=添加阻塞注解
jvm.inspections.blocking.method.annotation.configure.add.non-blocking.title=添加非阻塞注解
jvm.inspections.blocking.method.annotation.non-blocking=非阻塞注解:
jvm.inspections.blocking.method.consider.suspend.context.non.blocking=Consider Kotlin suspend context non-blocking
jvm.inspections.blocking.method.consider.unknown.context.blocking=考虑未知上下文阻塞
jvm.inspections.blocking.method.consider.unknown.context.nonblocking=考虑未知上下文非阻塞
jvm.inspections.blocking.method.display.name=可能在非阻塞上下文中使用阻塞调用
jvm.inspections.blocking.method.in.implicit.ctr.problem.descriptor=在非阻塞上下文中使用来自隐式构造函数调用的阻塞调用可能会导致线程匮乏
jvm.inspections.blocking.method.in.implicit.ctr.problem.wildcard.descriptor=在{0}中使用来自隐式构造函数调用的阻塞调用可能会导致线程匮乏
jvm.inspections.blocking.method.intention.text=启用检查选项 ''{0}''。
jvm.inspections.blocking.method.problem.descriptor=在非阻塞上下文中使用阻塞调用可能会导致线程匮乏
jvm.inspections.blocking.method.problem.wildcard.descriptor=在{0}中使用阻塞调用可能会导致线程匮乏
jvm.inspections.collection.contains.url.problem.descriptor=''{0}'' 可能包含 URL 对象 #loc
jvm.inspections.dependency.display.name=非法的软件包依赖项
jvm.inspections.dependency.edit.rules.family=编辑依赖关系规则
jvm.inspections.dependency.edit.rules.text=编辑依赖关系规则“{0}”
jvm.inspections.dependency.intention.description=打开一个对话框以配置作用域之间的依赖关系规则。
jvm.inspections.dependency.on.internal.display.name=对内部软件包的非法依赖
jvm.inspections.dependency.violator.problem.descriptor=违反依赖关系规则 ''{0}.''
jvm.inspections.equals.hashcode.called.on.url.display.name=在 'URL' 对象上调用 'equals()' 或 'hashCode()'
jvm.inspections.equals.hashcode.called.on.url.problem.descriptor=在 URL 对象上调用 ''{0}''
jvm.inspections.group.name=JVM 语言
jvm.inspections.junit.assertequals.may.be.assertsame.display.name='assertEquals()' 可能是 'assertSame()'
jvm.inspections.junit.assertequals.may.be.assertsame.problem.descriptor=<code>#ref()</code> 可能是 'assertSame()' #loc
jvm.inspections.junit.assertequals.on.array.display.name=在数组上调用了 'assertEquals()'
jvm.inspections.junit.assertequals.on.array.problem.descriptor=在数组上调用了 <code>#ref()</code> #loc
jvm.inspections.junit.ignored.test.class.problem.descriptor=测试类 ''{0}'' 已被{1, choice, 1#|2#无理由}忽略/禁用 #loc
jvm.inspections.junit.ignored.test.display.name=使用 '@Ignore'/'@Disabled' 注解的 JUnit 测试
jvm.inspections.junit.ignored.test.ignore.reason.option=只报告没有原因的注解
jvm.inspections.junit.ignored.test.method.problem.descriptor=测试方法 ''{0}()'' 已被{1, choice, 1#|2#无理由}忽略/禁用 #loc
jvm.inspections.junit.malformed.annotated.double.descriptor=使用 ''@{1}'' 注解的{0, choice, 0#字段|1#方法} <code>#ref</code> 应为 {2} 和 {3}
jvm.inspections.junit.malformed.annotated.double.typed.descriptor=使用 ''@{1}'' 注解的{0, choice, 0#字段|1#方法} <code>#ref</code> 应为 {2}、{3} 且类型应为 ''{4}''
jvm.inspections.junit.malformed.annotated.method.double.param.double.descriptor=使用 ''@{0}'' 注解的方法 <code>#ref</code> 应为 {1}，{2}，且不应声明形参 ''{3}'' 和 ''{4}''
jvm.inspections.junit.malformed.annotated.method.double.param.single.descriptor=使用 ''@{0}'' 注解的方法 <code>#ref</code> 应为 {1}，{2}，且不应声明形参 ''{3}''
jvm.inspections.junit.malformed.annotated.method.double.typed.param.double.descriptor=使用 ''@{0}'' 注解的方法 <code>#ref</code> 应为 {1}，{2}，类型应为 ''{3}''，且不应声明形参 {4} 和 ''{5}''
jvm.inspections.junit.malformed.annotated.method.double.typed.param.single.descriptor=使用 ''@{0}'' 注解的方法 <code>#ref</code> 应为 {1}，{2}，类型应为 ''{3}''，且不应声明形参 ''{4}''
jvm.inspections.junit.malformed.annotated.method.param.double.descriptor=使用 ''@{0}'' 注解的方法 <code>#ref</code> 不应声明形参 {1} 和 ''{2}''
jvm.inspections.junit.malformed.annotated.method.param.single.descriptor=使用 ''@{0}'' 注解的方法 <code>#ref</code> 不应声明形参 ''{1}''
jvm.inspections.junit.malformed.annotated.method.single.param.double.descriptor=使用 ''@{0}'' 注解的方法 <code>#ref</code> 应为 {1} 且不应声明形参 ''{2}'' 和 ''{3}''
jvm.inspections.junit.malformed.annotated.method.single.param.single.descriptor=使用 ''@{0}'' 注解的方法 <code>#ref</code> 应为 {1} 且不应声明形参 ''{2}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.double.descriptor=使用 ''@{0}'' 注解的方法 <code>#ref</code> 应为 {1}，类型应为 ''{2}''，且不应声明形参 {3} 和 ''{4}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.single.descriptor=使用 ''@{0}'' 注解的方法 <code>#ref</code> 应为 {1}，类型应为 ''{2}''，且不应声明形参 ''{3}''
jvm.inspections.junit.malformed.annotated.method.typed.param.double.descriptor=使用 ''@{0}'' 注解的方法 <code>#ref</code> 的类型应为 ''{1}''，且不应声明形参 {2} 和 ''{3}''
jvm.inspections.junit.malformed.annotated.method.typed.param.single.descriptor=使用 ''@{0}'' 注解的方法 <code>#ref</code> 的类型应为 ''{1}'' 且不应声明形参 ''{2}''
jvm.inspections.junit.malformed.annotated.single.descriptor=使用 ''@{1}'' 注解的{0, choice, 0#字段|1#方法} <code>#ref</code> 应为 {2}
jvm.inspections.junit.malformed.annotated.single.typed.descriptor=使用 ''@{1}'' 注解的{0, choice, 0#字段|1#方法} <code>#ref</code> 应为 {2} 且类型应为 ''{3}''
jvm.inspections.junit.malformed.annotated.suspend.function.descriptor=使用 ''@{0}'' 注解的方法 <code>#ref</code> 不应为挂起函数
jvm.inspections.junit.malformed.annotated.typed.descriptor=使用 ''@{1}'' 注解的{0, choice, 0#字段|1#方法} <code>#ref</code> 类型应为 ''{2}''
jvm.inspections.junit.malformed.declaration.name=JUnit 格式错误的声明
jvm.inspections.junit.malformed.extension.class.level.descriptor=应在类级别注册{0}
jvm.inspections.junit.malformed.fix.class.signature=修正类签名
jvm.inspections.junit.malformed.fix.class.signature.descriptor=修正 ''{0}'' 类签名
jvm.inspections.junit.malformed.fix.class.signature.multi=修正类签名
jvm.inspections.junit.malformed.fix.field.signature=修正字段签名
jvm.inspections.junit.malformed.fix.field.signature.descriptor=修正 ''{0}'' 字段签名
jvm.inspections.junit.malformed.fix.method.signature=修复方法签名
jvm.inspections.junit.malformed.fix.method.signature.descriptor=修复 ''{0}'' 方法签名
jvm.inspections.junit.malformed.missing.nested.annotation.descriptor=不会执行嵌套类中的测试
jvm.inspections.junit.malformed.no.arg.descriptor=方法 <code>#ref</code> 应为 {0}、{1}{2, choice, 0#且无形参|1#，无形参，且类型为 void}
jvm.inspections.junit.malformed.option.ignore.test.parameter.if.annotated.by=由以下对象注解时忽略测试形参:
jvm.inspections.junit.malformed.param.duplicated.enum.descriptor=重复的 'enum' 常量名称
jvm.inspections.junit.malformed.param.empty.source.unsupported.descriptor=''@{0}'' 无法向方法提供实参，因为方法具有不受支持的 ''{1}'' 类型的形参
jvm.inspections.junit.malformed.param.exactly.one.type.of.input.must.be.provided.descriptor=必须恰好提供一种类型的输入
jvm.inspections.junit.malformed.param.file.source.descriptor=无法解析文件源: ''{0}''
jvm.inspections.junit.malformed.param.method.source.assignable.descriptor=未找到将 ''{0}'' 转换为 ''{1}'' 的隐式转换
jvm.inspections.junit.malformed.param.method.source.no.params.descriptor=方法源 ''{0}'' 不应有形参
jvm.inspections.junit.malformed.param.method.source.return.type.descriptor=方法源 ''{0}'' 必须具有以下其中一种返回值类型: ''Stream<?>''、''Iterator<?>''、''Iterable<?>'' 或 ''Object[]''
jvm.inspections.junit.malformed.param.method.source.static.descriptor=方法源 ''{0}'' 必须为 static
jvm.inspections.junit.malformed.param.method.source.unresolved.descriptor=无法解析目标方法源: ''{0}''
jvm.inspections.junit.malformed.param.multiple.parameters.descriptor=此源不支持多个形参
jvm.inspections.junit.malformed.param.no.sources.are.provided.descriptor=没有提供源，套件将为空
jvm.inspections.junit.malformed.param.no.value.source.is.defined.descriptor=未定义值源
jvm.inspections.junit.malformed.param.unresolved.enum.descriptor=无法解析 'enum' 常量引用。
jvm.inspections.junit.malformed.param.wrapped.in.arguments.descriptor=必须在 'Arguments' 中包装多个形参
jvm.inspections.junit.malformed.repetition.number.descriptor=重复次数必须大于零
jvm.inspections.junit.malformed.source.without.params.descriptor=''@{0}'' 无法向方法提供实参，因为方法没有形参
jvm.inspections.junit.malformed.suspend.function.descriptor=方法 <code>#ref</code> 不应为挂起函数
jvm.inspections.junit.malformed.test.combination.descriptor=可疑的 {0} 与 ''@{1}'' 组合
jvm.inspections.junit.mixed.annotations.junit.descriptor=扩展 JUnit {1} TestCase 的类内使用 ''@{0}'' 注解的方法 <code>#ref()</code> #loc
jvm.inspections.junit.mixed.annotations.name=在单个 TestCase 中使用多个版本的 JUnit API
jvm.inspections.junit3.super.teardown.display.name=未从 'finally' 块调用 JUnit 3 'super.tearDown()'
jvm.inspections.junit3.super.teardown.problem.descriptor=未从 'finally' 块调用 <code>#ref()</code> #loc
jvm.inspections.junit4.converter.display.name=JUnit 3 测试可以是 JUnit 4
jvm.inspections.junit4.converter.problem.descriptor=<code>#ref</code> 可以转换为 JUnit4 测试用例
jvm.inspections.junit4.converter.quickfix.conflict.call.compile=如果 {1} 被转换为 JUnit 4，方法调用 {0} 将不编译
jvm.inspections.junit4.converter.quickfix.conflict.name=方法 {0} 将与其 super 方法发生名称冲突
jvm.inspections.junit4.converter.quickfix.conflict.semantics=如果 {1} 被转换为 JUnit 4，方法调用 {0} 可能会更改语义
jvm.inspections.junit4.converter.quickfix.conflict.suite={0} 的 suite 方法的迁移有副作用，将被删除
jvm.inspections.junit4.converter.quickfix.name=转换为 JUnit 4 测试用例
jvm.inspections.junit5.converter.display.name=JUnit 4 测试可以为 JUnit 5
jvm.inspections.junit5.converter.problem.descriptor=#ref 可以为 JUnit 5 测试
jvm.inspections.junit5.converter.quickfix=迁移到 JUnit 5
jvm.inspections.junit5.converter.quickfix.conflict.inheritor=由于存在不兼容的继承者，类 {0} 无法转换为 JUnit 5: {1}
jvm.inspections.junit5.converter.quickfix.presentation.text=转换断言
jvm.inspections.logging.frameworks.group.name=日志记录
jvm.inspections.migrate.assert.to.matcher.description=断言表达式 <code>#ref</code> 可被替换为 ''{0}'' 调用 #loc
jvm.inspections.migrate.assert.to.matcher.option=静态导入匹配程序的方法
jvm.inspections.migrate.assertion.name=JUnit 断言可以是 'assertThat()' 调用
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.description=已计划移除的 API 也必须使用 '@Deprecated' 注解标记
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.display.name=已计划移除的 API 上缺少 '@Deprecated' 注解
jvm.inspections.must.already.be.removed.api.current.version.description=API 必须在当前版本 {0} 中移除
jvm.inspections.must.already.be.removed.api.display.name=API 必须已移除
jvm.inspections.must.already.be.removed.api.earlier.version.description=API 必须已在版本 {0} 中移除，但当前版本为 {1}
jvm.inspections.remove.annotation.quickfix.name=移除注解
jvm.inspections.remove.annotation.quickfix.text=移除 ''@{0}'' 注解
jvm.inspections.rename.quickfix.name=重命名元素
jvm.inspections.rename.quickfix.text=重命名为 ''{0}''
jvm.inspections.scheduled.for.removal.api.is.declared.in.marked.api=''{0}'' 在已计划从 {3} 中移除的{1} ''{2}'' 中声明
jvm.inspections.scheduled.for.removal.api.is.marked.itself=''{0}'' 已计划从 {1} 中移除
jvm.inspections.scheduled.for.removal.future.version=未来版本
jvm.inspections.scheduled.for.removal.method.overridden.declared.in.marked.api=重写方法 ''{0}'' 在已计划从 {3} 中移除的{1} ''{2}'' 中声明
jvm.inspections.scheduled.for.removal.method.overridden.marked.itself=重写方法 ''{0}'' 已计划从 {1} 中移除
jvm.inspections.scheduled.for.removal.predefined.version=版本 {0}
jvm.inspections.scheduled.for.removal.scheduled.for.removal.type.is.used.in.signature.of.referenced.api=''{0}'' 已计划移除，因为其签名引用了已计划从 {3} 中移除的{1} ''{2}''
jvm.inspections.serializable.class.without.serialversionuid.display.name=不带 'serialVersionUID' 的可序列化类
jvm.inspections.serializable.class.without.serialversionuid.problem.descriptor=<code>#ref</code> 未定义 'serialVersionUID' 字段 #loc
jvm.inspections.source.to.sink.flow.assigned.unknown=未知字符串分配给安全变量
jvm.inspections.source.to.sink.flow.assigned.unsafe=不安全的字符串分配给安全变量
jvm.inspections.source.to.sink.flow.common.unknown=未知字符串在安全上下文中使用
jvm.inspections.source.to.sink.flow.common.unsafe=不安全字符串在安全上下文中使用
jvm.inspections.source.to.sink.flow.display.name=不安全字符串被传递至安全方法
jvm.inspections.source.to.sink.flow.passed.unknown=未知字符串用作安全形参
jvm.inspections.source.to.sink.flow.passed.unsafe=不安全字符串用作安全形参
jvm.inspections.source.to.sink.flow.returned.unknown=未知字符串返回自安全方法
jvm.inspections.source.to.sink.flow.returned.unsafe=不安全字符串返回自安全方法
jvm.inspections.source.to.sink.flow.too.complex=Too complex to check that the string is safe in a safe context
jvm.inspections.source.unsafe.to.sink.flow.check.private.methods = 将 private 方法的形参视为安全
jvm.inspections.source.unsafe.to.sink.flow.check.private.methods.comment = If it is enabled, then parameters of private methods are considered as safe, otherwise they will be considered as unknown
jvm.inspections.source.unsafe.to.sink.flow.check.warn.if.complex = 报告情况是否太复杂而无法检查
jvm.inspections.source.unsafe.to.sink.flow.check.warn.if.complex.comment = Enable, if it is needed to report strings, which can not be checked because of the complexity
jvm.inspections.source.unsafe.to.sink.flow.config=Untainted 注解将被添加到元素 ''{0}'' 的检查设置中
jvm.inspections.source.unsafe.to.sink.flow.impossible=元素 ''{0}'' 不支持 Untainted 注解。该元素将被跳过
jvm.inspections.source.unsafe.to.sink.flow.index.parameter=形参索引
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.command.name=标记为需要验证
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.family=标记为需要验证
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.text=将元素标记为需要验证
jvm.inspections.source.unsafe.to.sink.flow.not.number=非数字
jvm.inspections.source.unsafe.to.sink.flow.preview=添加 '@Untainted' 注解
jvm.inspections.source.unsafe.to.sink.flow.preview.propagate=显示传播树
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.family=传播树
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.preview=打开工具窗口以检查安全注解的传播
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.text=从此处显示传播树
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.annotate=注解除排除外的所有对象
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.title=不安全的成员
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.unsafe.flow=不安全的流
jvm.inspections.source.unsafe.to.sink.flow.safe.class=安全类:
jvm.inspections.source.unsafe.to.sink.flow.safe.class.comment=These classes can't contain unsafe data
jvm.inspections.source.unsafe.to.sink.flow.tainted.annotations=Tainted 注解:
jvm.inspections.source.unsafe.to.sink.flow.tainted.annotations.comment=These annotations will be used as '@Tainted' annotations during the analysis
jvm.inspections.source.unsafe.to.sink.flow.tainted.methods=Tainted 方法:
jvm.inspections.source.unsafe.to.sink.flow.tainted.methods.comment=这些方法被视为只返回不安全的对象
jvm.inspections.source.unsafe.to.sink.flow.tainted.parameters=Tainted 形参:
jvm.inspections.source.unsafe.to.sink.flow.tainted.parameters.comment=这些形参被视为具有 '@Tainted' 注解
jvm.inspections.source.unsafe.to.sink.flow.untainted.annotations=Untainted 注解:
jvm.inspections.source.unsafe.to.sink.flow.untainted.annotations.comment=These annotations will be used as '@Untainted' annotations during the analysis. The first annotation from this list will be used for propagation if it exists in the classpath.
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields=Untainted 字段:
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields.comment=These fields are considered to contain only safe objects
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields.name=字段名称
jvm.inspections.source.unsafe.to.sink.flow.untainted.methods=Untainted 方法:
jvm.inspections.source.unsafe.to.sink.flow.untainted.methods.comment=These methods are considered to return only safe objects
jvm.inspections.source.unsafe.to.sink.flow.untainted.parameters=Untainted 形参:
jvm.inspections.source.unsafe.to.sink.flow.untainted.parameters.comment=这些形参被视为具有 '@Untainted' 注解
jvm.inspections.source.unsafe.to.sink.flow.untainted.process.as.qualifier.arguments=如果接收器和实参未被污染，则认为外部方法未被污染
jvm.inspections.source.unsafe.to.sink.flow.untainted.process.as.qualifier.arguments.comment=If it is enabled, then external methods outside the current class will be considered as safe if their receivers and arguments are safe. In some cases, it is not applicable, but it can be useful for stateless classes. Otherwise, all external methods will be considered as unsafe
jvm.inspections.string.touppercase.tolowercase.without.locale.description=在未使用国际化字符串指定区域设置的情况下调用 <code>String.{0}()</code> #loc
jvm.inspections.test.case.in.product.source.display.name=产品源中的测试
jvm.inspections.test.case.in.product.source.problem.descriptor=测试用例 <code>#ref</code> 可能应被放置在测试源树中 #loc
jvm.inspections.test.case.with.constructor.display.name=具有非普通构造函数的 TestCase
jvm.inspections.test.case.with.constructor.problem.descriptor=构造函数 <code>#ref()</code> 中的初始化逻辑，而不是 'setup()' 生命周期方法 #loc
jvm.inspections.test.case.with.constructor.problem.descriptor.initializer=初始值设定项中的初始化逻辑，而不是 'setup()' 生命周期方法
jvm.inspections.test.frameworks.group.name=测试框架
jvm.inspections.test.method.in.product.source.problem.descriptor=测试方法 <code>#ref()</code> 可能应被放置在测试源树中 #loc
jvm.inspections.test.method.without.assertion.display.name=不带断言的测试方法
jvm.inspections.test.method.without.assertion.problem.descriptor=测试方法 <code>#ref()</code> 不包含断言 #loc
jvm.inspections.testonly.class.reference=在生产代码中引用纯测试类
jvm.inspections.testonly.display.name=生产代码中的纯测试用法
jvm.inspections.testonly.field.reference=在生产代码中引用纯测试字段
jvm.inspections.testonly.method.call=在生产代码中调用纯测试方法
jvm.inspections.testonly.visiblefortesting=@VisibleForTesting 对 @TestOnly 代码意义不大
jvm.inspections.thread.run.display.name=调用 'Thread.run()'
jvm.inspections.unstable.api.usage.annotations.list=不稳定的 API 注解:
jvm.inspections.unstable.api.usage.api.is.declared.in.unstable.api=''{0}'' 在标记为 @{3} 的不稳定{1} ''{2}'' 中声明
jvm.inspections.unstable.api.usage.api.is.marked.unstable.itself=''{0}'' 使用 @{1} 标记为不稳定
jvm.inspections.unstable.api.usage.display.name=不稳定的 API 用法
jvm.inspections.unstable.api.usage.ignore.declared.inside.this.project=忽略此项目中声明的 API
jvm.inspections.unstable.api.usage.ignore.inside.imports=在导入内忽略
jvm.inspections.unstable.api.usage.overridden.method.is.declared.in.unstable.api=重写方法 ''{0}'' 在标记为 @{3} 的不稳定{1} ''{2}'' 中声明
jvm.inspections.unstable.api.usage.overridden.method.is.marked.unstable.itself=重写方法 ''{0}'' 使用 @{1} 标记为不稳定
jvm.inspections.unstable.api.usage.unstable.type.is.used.in.signature.of.referenced.api=''{0}'' 不稳定，因为其签名引用了标记为 @{3} 的不稳定{1} ''{2}''
jvm.inspections.unstable.type.used.in.class.signature.description=类必须使用 ''@{0}'' 注解标记，因为其声明引用了不稳定的类型 ''{1}''
jvm.inspections.unstable.type.used.in.field.signature.description=字段必须使用 ''@{0}'' 注解标记，因为其类型引用了不稳定的类型 ''{1}''
jvm.inspections.unstable.type.used.in.method.signature.description=方法必须使用 ''@{0}'' 注解标记，因为其签名引用了不稳定的类型 ''{1}''
jvm.inspections.unstable.type.used.in.signature.display.name=签名中使用了不稳定的类型
jvm.inspections.usages.of.obsolete.api.description=使用了过时的 API
jvm.inspections.usages.of.obsolete.api.display.name=ApiStatus.@Obsolete 的用法
propagated.from=传播原因:
propagated.to=要传播的目标:
title.uast=UAST