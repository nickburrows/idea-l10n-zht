go.advanced.module.description=需要对该语言有更深理解的功能
go.advanced.module.name=高级
go.apply.fix=选择 {0} 并按 {1}。
go.apply.fix.at.once=或者，如果快速修复工具提示可见，您可以按 {0} 立即应用建议的快速修复。
go.autocomplete.json.autocomplete=开始填写 JSON 标记时，在输入反引号 ({0}) 之后，<ide/> 将建议输入一个键。键入一个反引号 {0}，然后选择 {1}。
go.autocomplete.json.name=JSON 结构标记的自动补全
go.autocomplete.json.select.style=现在，选择要应用的样式。我们来选择 {0}! IDE 将保存您的选择，并为此结构的其他字段建议相同的样式。
go.basic.completion.invoke.completion=请注意，<ide/> 会自动插入一个新的导入。接下来，按 {0} 激活基本补全，选择 {1}，然后按 {2}。
go.basic.completion.lesson.name=基本补全
go.basic.completion.type.and.choose=默认情况下，<ide/> 会立即补全您的代码。在文本光标的位置开始键入 {0}，您将看到带有匹配建议的“查找”菜单。您可以按 {2} 从“查找”菜单选择 {1}。
go.basic.editing.module.description=可以帮助您编辑代码的操作
go.basic.editing.module.name=代码编辑
go.code.completion.for.benchmarks.bn.create.bench=要创建一个新的基准，请开始键入 {0}，然后从建议列表中选择 {0}。
go.code.completion.for.benchmarks.bn.for.loop=在基准中键入 {0} 时，<ide/> 建议在 {0} 循环的条件表达式中使用 {1}。\n\
例如，键入 {0}，然后从建议列表中选择 {2}。
go.code.completion.for.benchmarks.bn.name=基准和测试的代码补全
go.code.completion.for.time.package.hour=为小时执行同样的操作，从建议列表中选择 {0}。
go.code.completion.for.time.package.minute=为分钟选择 {0}，完成模板。
go.code.completion.for.time.package.month= 再次按 {0}，然后为月选择 {1}。
go.code.completion.for.time.package.name=基本补全: time 软件包
go.code.completion.for.time.package.year= 要设置日期和时间元素的格式，{0} 软件包使用以下预定义布局中的值: {1}。这意味着您可以使用引用时间元素作为占位符来定义格式。因此，在编码时间而不是 {4} 时，您应该编写 {5}。\n\
如果您忘记了预定义布局中的值，则可以使用代码补全作为提示。例如，按 {2} 并选择 {3} 可粘贴年份元素。
go.code.completion.module.description=上下文感知的代码补全可加快编码过程并减少拼写错误
go.code.completion.module.name=代码补全
go.code.style.module.description=在您的源代码中应用 Go 编码约定
go.code.style.module.name=代码样式
go.comments.comment.block=您可以注释掉代码块。例如，注释掉选定的块，然后按 {0}。
go.comments.comment.one.line=使用 {0} 注释掉任意一行。
go.comments.lesson.name=添加和移除注释
go.comments.uncomment.line=撤消对使用相同快捷键 {0} 注释过的行的注释。
go.completion.for.functions.choose.item=从列表选择 {0}，然后点击“{1}”。当您看到建议列表时，即可开始键入，减少结果数量。
go.completion.for.functions.lesson.name=基本补全: 适用于某个值的函数
go.completion.for.functions.press.twice=要查找接受元素作为第一个实参的所有函数，请按<strong>两次</strong> {0}。注意，点使其看起来像一个方法，而实际上并不是。
go.debug.function.calls.add.arguments.for.evaluation=在括号内，键入 {0}。该字段必须显示 {1}。
go.debug.function.calls.click.evaluate=点击“{0}”或按 {1}。随后您可以关闭对话框。
go.debug.function.calls.enter.expression.to.evaluate=在 {0} 字段中，开始键入 {1}，从建议列表中选择 {2}。
go.debug.function.calls.evaluate.expression=按 {1} 调用 {0} 操作。
go.debug.function.calls.lesson.name=调试函数调用
go.debug.function.calls.mac.note=请记住，您的操作系统可能会要求您输入密码以启动调试服务器。
go.debug.function.calls.run.to.cursor=现在，文本光标位于第 15 行的末尾。按 {0} 查看 {1} 操作的工作方式。
go.debug.function.calls.step.over=尝试使用 {1} 单步跳过 {0} 构造。
go.debug.function.calls.toggle.breakpoint=在调试模式下，您可以将不同的值传递至函数，并查看函数返回的内容。在<a href="{0}">文档</a>中了解有关“对表达式求值”功能的更多信息。\n\
{1}要开始调试，您需要创建一个断点。按 {2} 切换断点。
go.debug.function.calls.version.warning=<strong>注</strong>: 对于此功能，您需要安装 Go 1.11 或更高版本。
go.debug.function.context.menu=可以通过不同的方式调试代码。其中的一种方式是利用上下文菜单。\n\
尝试通过右键点击代码所在编辑器中的区域调用上下文菜单。
go.debug.nil.hide.types=如果对象类型占用大量空间，则可以在 {0} 工具窗口中隐藏该对象类型。\n\
试试看! 右击 {1} 窗格中的变量，然后在显示的列表中清除 {2} 选项。
go.debug.nil.hide.types.introduction=Go 中的接口有两个组件，类型和该类型的值。要使接口为 {0}，这两个组件都必须为 {0}。如果您的程序中有一个接口，其值包含 {0} 指针，则该接口将不等于 {0}，因为内部类型不是 {0}。在调试过程中，<ide/> 会检测这种情况，并以不同的方式显示它们。\n\
我们从创建断点开始调试。按 {1} 切换断点。{2}
go.debug.nil.hide.types.name=类型和 nil 接口的表示
go.debug.nil.hide.types.variables=在 {0} 窗格中，您可以看到 {1} 和 {2} 接口之间的差异。{1} 接口是 {3}，因为它的值和类型都未设置。与在接口值内部存储 {4} 类型的 {3} 指针的 {2} 接口不同。无论指针的值是什么，{2} 接口的内部类型都是 {3}。
go.debug.run.sample=选择 {0} 目录项或尝试 {1}。
go.debug.stop.debug=按 {0} 停止调试并完成单元。
go.debugging.module.description=调试可以帮助您发现并解决应用程序中的问题
go.debugging.module.name=调试
go.delete.conversion.intro=<strong>冗余类型转换</strong>检查会警告可以省略的冗余类型转换(例如，当您将字符串文字转换为字符串时)。在<a href="{0}">冗余类型转换</a>中可了解有关检查的更多信息。
go.delete.conversion.invoke.intentions=注意编辑器中的 {0} 函数。文本光标位于 {2} 的 {1} 类型转换上。按 {3} 调用意图操作。
go.delete.conversion.lesson.name=冗余类型转换
go.doc.click.back=要返回上一个屏幕，请点击“{0}”按钮。
go.doc.click.link=所有链接均可点击，并可将您转到软件包或函数的文档。例如，在“{1}”工具窗口中点击“{0}”。
go.doc.close.documentation.tool.window=我们关闭“{0}”工具窗口。要执行此操作，请点击“{0}”标签页。默认情况下，“{0}”标签页应位于 IDE 窗口的右下角。
go.doc.module=Go 文档注释
go.doc.show.documentation=Go 1.19 在文档注释中添加了对链接、列表和新标题的支持。<ide/> 支持这些新功能。您可以在弹出窗口或“{0}”工具窗口中预览注释。\n\
按 {1} 可在弹出窗口中查看有关 {2} 函数的文档。
go.doc.show.documentation.tool.window=再按一次 {0} 切换到“{1}”工具窗口。
go.dump.goroutines.click.button.DlvFilterGoroutinesAction=在打开的 {0} 标签页中，点击“{1}”按钮。
go.dump.goroutines.click.button.more=在 {0} 工具窗口中，点击“{1}”。
go.dump.goroutines.dump.tab={0} 标签页会显示应用程序的 Goroutine 列表。我们的应用程序有几个 goroutine。但您的实际应用程序可能不止这些。\n\
在 <ide/> 中，您可以应用筛选器来搜索特定的 goroutine，并研究筛选后的结果。
go.dump.goroutines.filter.goroutines=在 {0} 搜索字段中，键入 {1} 以筛选列表。此筛选器只保留名称中含有 {1} 的 goroutine 的执行堆栈。
go.dump.goroutines.name=转储 goroutine
go.dump.goroutines.toggle.breakpoint=在 Go 中，并发任务称为 goroutine。要创建 goroutine，可以在函数或方法调用之前使用 {0} 语句。\n\
您可以创建程序使用的所有 goroutine 的转储，应用搜索特定 goroutine 的筛选器，并研究筛选的结果。\n\
要转储 goroutine，需要启动调试。但首先要创建一个断点。按 {1} 可切换断点。{2}
go.error.handling.module.description=了解如何在 Go 中加快错误处理速度
go.error.handling.module.name=错误处理
go.error.string.formatting.goto=我们的程序中仍有一个弱警告。
go.error.string.formatting.introduction=根据<a href="{0}">Go 约定</a>，您不应将错误字符串大写。如果您不小心忘记了这个约定，<ide/> 会提醒您。\n\
要更正警告，请按 {1} 并选择 {2}。
go.error.string.formatting.name=后缀补全: 将字符串转换为数字
go.error.string.formatting.parsefloat=<ide/> 有特殊的后缀模板，可以帮助您将字符串转换为数字。通过输入点号 ({0}) 并从建议列表中选择 {1} 来尝试第一个选项。
go.error.string.formatting.parseint=我们将 {0} 后缀模板应用于 {1}。再次输入 {2}，选择 {0}，然后按 {3} 接受默认值。
go.export.types.name=导出类型
go.export.types.quickfix=如果您编写一个返回未导出类型的导出函数，<ide/> 将建议一个快速修复方法来导出该类型。按 {0} 并选择 {1}。
go.extract.inline.variables.extract.task=按 {0} 提取变量，选择一个字符串表达式，输入新名称，然后按 {1} 完成重构。
go.extract.inline.variables.inline.task=与 {0} 重构相反，{1} 有助于移除冗余变量。按 {2} 可将变量内联到其单个用法中。
go.extract.inline.variables.lesson.name=提取和内联变量
go.extract.methods.with.returns.complete.refactoring=键入 {0} 并按 {1}。
go.extract.methods.with.returns.intro=使用 {0} 重构，您可以获取代码段，将其移至单独的方法，并用对新方法的调用替换旧代码。如果代码在 return 语句中退出，则按原样提取。在<a href="{1}">提取函数和方法</a>一文中进一步了解 {0} 重构。
go.extract.methods.with.returns.invoke.refactoring=文本光标位于您可以提取的 {0} 子句之前。按 {1}。
go.extract.methods.with.returns.lesson.name=提取方法
go.feature.trainer.specify.sdk.to.continue.learning.title=指定 Go SDK 以继续学习
go.feature.trainer.too.old.go.sdk.notification.text=教程需要 Go SDK <b>{1}</b> 或更高版本才能对 Go 模块进行依赖项管理。您当前的 Go SDK 版本为 <b>{0}</b>。
go.feature.trainer.too.old.go.sdk.notification.title=将 Go SDK 更新到 <b>{0}</b> 或更高版本
go.fixing.test.close.problems=有一些问题需要我们注意。您可以直接在 {0} 工具窗口中解决部分问题。但是有些问题需要编辑器中的特定操作。我们将在编辑器中应用所有修复!\n\
再次按 {2} 关闭 {1} 工具窗口。
go.fixing.test.fix.camelcase={1} 软件包的 <a href="{0}">Go 文档</a>指出，函数名称必须以骆驼拼写法书写(如 {2})。我们的 {3} 函数不符合此约定。\n\
要修复函数名称，请按 {4}，然后选择 {5}。
go.fixing.test.fix.string.conversion=此 {0} 转换返回 Unicode 代码点的 UTF-8 表示，而不是我们期望的十进制字符串表示。\n\
要解决这个问题，请使用 {2} 软件包的 {1} 方法。按 {3}，然后选择 {4}。
go.fixing.test.lesson.name=修复测试文件
go.fixing.test.negate=最后一个并不是真正的错误，而是一些重构，能够简化我们的代码。注意 {0} 函数中的求反，让我们看看能做些什么。\n\
按 {1}，将选择移至 {2} 节点，然后按 {3} 预览我们将要执行的更改。\n\
看起来不错，按 {5} 应用 {4} 建议。
go.fixing.test.open.problems.toolwindow={0} 工具窗口显示当前文件中的警告和错误列表，并描述了这些问题。\n\
测试文件已损坏，来看看有什么问题。\n\
按 {1} 打开 {0} 工具窗口。
go.fixing.test.use.multicursors=下一个错误非常明显，我们在匿名 struct 中缺少右大括号和逗号。但是我们不想在每行中都重复键入。多光标可能会有所帮助。\n\
要触发多光标，选择区域并按 {0}。键入 {1} 补全该 struct。
go.fmt.lesson.name=运行 go fmt
go.fmt.task=如果您倾向于使用 {0} 格式化代码，可以按 {1} 运行。
go.formatting.clear.selection=要清理选区，按 {0}。
go.formatting.lesson.name=内置格式化程序
go.formatting.reformat.selection=<ide/> 可以帮助您进行代码格式化。点击 {0} 重新格式化所选代码块。
go.formatting.whole.file=要重新格式化整个源文件，请在未选择任何行的情况下使用 {0}。
go.general.templates.fori=我们从循环开始。输入{0} 并从建议列表中选择 {0}。在循环中设置以下条件: {1}。
go.general.templates.intro=实时模板可在代码中插入常见结构，如循环、条件、各种声明或打印语句。
go.general.templates.lesson.name=实时模板: fori 和 vars
go.general.templates.type.iteration=每次迭代，{0} 循环必须执行 {1}。
go.general.templates.vars=目前，程序会读取用户从键盘上输入的数字，并在 {0} 循环中使用。但是从 <ide/> 2020.1 起，您可以使用常量的 {1}、变量的 {2}、类型的 {3} 以及导入的 {4} 等模板，更快地编写结构组的代码。\n\
来用 {5} 和 {6} 变量的代码值替换用户输入吧。开始键入 {7}，然后从补全列表选择 {2} 实时模板。为 {5} 和 {6} 变量设置任意值。
go.generate.getters.and.setters.action=在需要为结构字段生成 getter 和 setter 的情况下，可以使用意图操作。\n\
按 {0} 并选择“{1}”。在“{2}”对话框中，按 {3} 并选择所有可用字段。点击“{4}”。
go.generate.getters.and.setters.name=生成 getter 和 setter
go.generate.missing.methods.lesson.name=生成缺少的方法
go.generate.missing.methods.task=使用 {0} 操作，即使接口定义中已省略，您仍可以生成缺失的方法并指定形参名称。\n\
按 {1}，选择 {2} 类型。在 {3} 窗口中，键入 {4}，然后按 {5}。
go.generate.missing.methods.todo=当您使用“{1}”操作时，{0} 注释会被自动添加到生成的模板中。这些特殊注释会在编辑器中高亮显示，编制索引并在“{2}”工具窗口中列出。它将提醒您注意未实现的方法。
go.generating.code.module.description=生成代码块的操作和模板
go.generating.code.module.name=正在生成代码
go.generics.change.casing=在生成测试文件之前，我们先修正一下代码样式。在官方 Go 文档中，类型形参的名称为大写，我们代码中的 {0} 形参为小写。\n\
要修正大小写，我们可以使用快速修复。要执行此操作，请按 {1}，然后选择“{2}”。
go.generics.click.function=点击“{0}”，然后在“{1}”弹出窗口中，选择“{2}”。
go.generics.fix.type=我们代码中的下一个问题是类型包含其本身，您将收到 {0} 错误。要避免此错误，应该包括指向类型的指针，而不是类型本身。IDE 有一个针对此情况的快速修复。\n\
按 {1}，然后选择“{2}”。
go.generics.inspections.change.interface.to.any=继续深入之前，我们再来重构一个东西。我们使用一个可被替换为 {0} 的空接口。\n\
按 {1}，然后选择“{2}”。
go.generics.inspections.delete.type.parameters={0} 函数使用中括号来使用类型形参，但在这些中括号中，我们看到了空的形参列表。要修正该错误，请按 {1}，然后选择“{2}”。
go.generics.inspections.title=类型形参的检查
go.generics.inspections.union.interfaces.with.methods=根据 <a href="{0}">Go 团队</a>，在联合中您不能将接口与方法一起使用。因此，不能将 {1} 用作联合元素中的术语。\n\
删除包括竖线及其之后空格的组({2})。
go.generics.inspections.unused.type.parameter=类型形参为灰显，因为我们在代码中的任何地方都不使用它们。我们来通过将形参部分中的 {0} 类型替换为 {1} 进行修正。
go.generics.right.click.function=我们已消除文件中的所有错误，可以尝试为 {0} 函数生成测试。\n\
右键点击 {0} 函数。
go.generics.running.code.click.link=现在，点击结果链接，在浏览器中打开您的代码。\n\
要使用类型形参运行代码，点击“{0}”按钮即可。
go.generics.running.code.set.118.in.go.mod=要尝试类型形参，您的{0}必须引用 {1} 或更高版本。您可以打开 {0} 并手动修正，或使用快速修复。\n\
按 {2}，然后选择“{3}”。
go.generics.test.generation.module=为类型形参生成测试
go.goto.next.error=要导航到文件中下一个高亮显示的错误，请按 {0}。
go.goto.next.warning=要导航到文件中下一个高亮显示的警告，请按 {0}。
go.handling.errors.with.templates.error.case=后缀代码补全可帮助您减少编写代码时的后向文本光标跳转。使用这些模板，可以将已经键入的表达式转换为另一种表达式。您可以在 {0} 部分中找到有关后缀补全的更多单元。\n\
扫描文件时，{1} 可能会遇到错误。如果发生错误，在扫描仪上调用 {2} 方法将返回该错误。\n\
要处理从 {2} 方法返回的可能错误，只需键入 {3} 并按 {4} 应用后缀模板。
go.handling.errors.with.templates.if.not.null=部分函数返回两个值。例如，{0} 返回指向 {1} 的指针和错误值。如果错误值为 {2}，则文件成功打开。如果错误不是 {3}，则说明发生了错误。在 <ide/> 中，实时和后缀模板可以帮助您更快速地编写错误值的处理进程。\n\
键入 {4}，然后从补全列表选择 {5} 实时模板。
go.handling.errors.with.templates.lesson.name=实时和后缀模板: if 和 rr
go.handling.errors.with.templates.return.nil.err=如果打开文件时出错，则需要返回一个切片和一个错误。我们可以返回 {0} 和 {1}。开始键入 {2}，选择 {3} 实时模板。
go.handling.unhandled.errors.handle.error={0} 代码检查会通知您返回错误值的函数或方法，但不会检查这些错误值。要进行处理，可以使用以下快速修复。\n\
第一个是 {1} 快速修复。它将调用结果分配给变量并生成 {2} 检查。\n\
我们将它应用到示例中! 按 {3} 并选择 {1}。
go.handling.unhandled.errors.handle.error.var.name=为变量名键入 {0}，然后按 {1}。
go.handling.unhandled.errors.name=处理未处理的错误
go.handling.unhandled.errors.wrap.in.closure=另一种快速修复适用于 {0} 和 {1} 语句。它的运作方式与 {2} 快速修复类似，但也会将代码包装在闭包中。\n\
按 {3} 并选择 {4}。
go.implement.missing.methods.lesson.name=实现缺少的方法
go.improve.names.apply.fix=在列表中选择整个调用，然后按 {0}。注意，<ide/> 为变量建议了 {1} 名称，因为它是错误的最常用名称。
go.improve.names.intro=<ide/> 为错误({0})和上下文({1})变量推荐最受欢迎的名称变体。
go.improve.names.introduce.variable=文本光标在 {0} 调用处。按 {1} 提取变量。
go.improve.names.lesson.name=错误变量的更好名称
go.inspection.unsafe.context.cancellation.add.defer={0} 代码检查会检查是否在所有执行路径上调用了 {2} 返回的 {1} 函数和类似函数。\n\
由于我们不在 {4} 执行路径上调用 {3}，因此您需要键入 {5} 来修复警告。
go.inspection.unsafe.context.cancellation.go.to.error=您可以在 <ide/> 于代码分析期间发现的问题之间导航。\n\
示例中包含一个问题。按 {0} 查看此问题。
go.inspection.unsafe.context.cancellation.name=不安全的上下文取消
go.intention.actions.module.description=意图操作可以为您提供代码的替代变体，甚至为检测到的问题提供解决方案
go.intention.actions.module.name=意图操作
go.introduce.function.final.propose=您现在可以根据需要调整形参。
go.introduce.function.intro=<ide/> 可以从调用创建函数和方法。现在，如果缺少函数或方法，还可以根据其类型进行创建。
go.introduce.function.invoke.intentions=注意文本光标位于 {0} 标识符下，该标识符用作函数引用。按 {1} 调用意图操作。
go.introduce.function.lesson.name=从函数类型创建函数
go.live.templates.with.types.add.method=将 {0} 添加为 {1} 接口的方法签名。
go.live.templates.with.types.add.second.return.value=目前，{0} 方法仅返回字符串形参。我们需要添加保留面积值的 {1} 返回值。<ide/> 自动在多个返回值类型周围添加括号。\n\
键入一个逗号({2})，按空格键，然后键入 {3}。
go.live.templates.with.types.complete.in.comment=注释解释了程序的工作方式及其意图。在注释中，可以使用代码补全来补全形参、函数和方法的名称。\n\
按 {0} 并选择 {1} 补全 {2} 函数之前的注释。
go.live.templates.with.types.fill.all.fields=最后，来创建一个矩形的新实例，并传递 {0} 和 {1} 的值。\n\
开始键入 {2}，然后从自动补全列表中选择此类型。接下来选择 {3} 操作。输入 {4} 和 {5} 的任意值。
go.live.templates.with.types.interface.template=在 Go 中，接口是一种自定义类型，您可以在其中指定一组方法签名。我们来添加一个!\n\
键入 {0}，然后选择 {1}。将接口命名为 {2}，然后按 {3}。
go.live.templates.with.types.lesson.name=实时模板: 创建类型和接口
go.live.templates.with.types.struct.template=struct 是一种包含命名字段的类型。struct 适用于将数据共同分组以形成记录。让我们为此代码创建。\n\
开始键入 {0}，然后选择 {1}。使用 {2} 作为 struct 名称。按 {3}。
go.live.templates.with.types.type.fields=将 {0} 添加为 {1} struct 的字段。
go.navigate.to.error=按 {0} 转到下一个错误。
go.navigation.module.description=在代码库中进行移动
go.navigation.module.name=导航
go.new.intentions.and.code.completion.actions.migrate.method.receiver.to.function.parameter=<ide/> 提供两种重构: {0} 和 {1}。例如，如果您有一个类型和该类型的方法，并且想要将此方法转换为单独的函数，只需按 {2} 并选择 {0}。
go.new.intentions.and.code.completion.actions.migrate.reverse=要将函数形参转换为方法接收器，请按 {0} 并选择 {1}。
go.new.intentions.and.code.completion.actions.name=快速修复和代码补全的增强
go.new.intentions.and.code.completion.actions.pass.arguments=通过输入 {1} 为 {0} 方法提供两个实参。
go.new.intentions.and.code.completion.actions.show.receiver=当直接在类型上调用方法(这称为方法表达式)时，应提供接收器类型作为第一个实参。<ide/> 会通过将接收者显示为补全建议中的第一个形参来帮助您。按 {0} 并选择 {1}。
go.onboarding.apply.action=选择“{0}”操作，然后按 {1}。
go.onboarding.apply.intention=选择 {0} 并按 {1}。
go.onboarding.balloon.about.debug.panel=“{0}”工具窗口为工具栏提供了各种调试操作。您可以稍后在“{1}”单元中进行尝试。
go.onboarding.balloon.click.here=点击此处设置断点
go.onboarding.balloon.open.file=双击以打开 {0}
go.onboarding.balloon.open.learn.toolbar=切换到“{0}”工具窗口继续学习本课
go.onboarding.balloon.project.directory=双击项目目录可以将其展开并查看项目文件
go.onboarding.balloon.project.view=点击以打开<strong>项目</strong>视图
go.onboarding.balloon.start.debugging=点击该图标以开始调试
go.onboarding.balloon.stop.debugging=点击该图标以停止调试
go.onboarding.case.changed=大小写已更改。
go.onboarding.change.ui.settings=在本课中，<ide/> 会将某些 UI 设置更改为默认状态。完成或退出课程后，将还原您的偏好设置。
go.onboarding.click.run.button=点击高亮显示的运行按钮“{0}”以显示运行选项。
go.onboarding.click.run.button.balloon=点击以显示运行选项
go.onboarding.close.debug.tool.window=要关闭{0}工具窗口，请按 {1}。
go.onboarding.context.menu=可以通过不同的方式运行代码。其中之一是借助 {1} 函数附近的运行按钮“{0}”。
go.onboarding.epilog=恭喜! 您已完成入门导览。此时，您可以:\n\
  - <callback id="{0}">关闭</callback>学习项目{1}\n\
  - <callback id="{2}">显示</callback>更多单元
go.onboarding.feedback.system.found.sdks=已找到 SDK:
go.onboarding.feedback.system.no.sdks=无
go.onboarding.feedback.system.used.sdk=已使用 SDK:
go.onboarding.finish.exit=关闭演示项目
go.onboarding.finish.modules=显示更多单元
go.onboarding.finish.text=您刚刚完成了 <ide/> 入门导览。\n\
现在可以关闭学习项目{0}。\n\
您也可以继续学习，尝试其他单元。
go.onboarding.finish.title=恭喜
go.onboarding.indexing.description=第一次打开项目时，<ide/> 会扫描 Go SDK 和项目本身，以收集编码辅助所需的详细信息。要继续，请等待索引完成。
go.onboarding.invoke.completion.tip=<strong>提示</strong>: 您可以按 {0} 在代码的任何位置显示补全条目。
go.onboarding.invoke.intention.for.code=意图还可以节省您的时间，让编码更轻松。我们使用意图将 {0} 函数快速转换为导出函数。按 {1}。
go.onboarding.invoke.intention.for.code.balloon=按 {0} 显示所有可用的意图
go.onboarding.invoke.intention.for.warning.1=您刚刚修正了一个错误，但还可以进一步改进这段代码。<ide/> 将高亮显示可以改进的代码行，并为这些行添加黄色灯泡。
go.onboarding.invoke.intention.for.warning.2=按 {0} 预览警告并应用快速修复。
go.onboarding.invoke.intention.for.warning.balloon=按 {0} 显示所有可用的快速修复
go.onboarding.invoke.search.everywhere.1=在 <ide/> 中进行处理时，您可能想要搜索项目中的文件、符号、类型，乃至 IDE 操作。在本课中，我们将搜索 {0} 操作，以将 {1} 字符串改为小写。
go.onboarding.invoke.search.everywhere.2=按两次 {0} 以打开“{1}”对话框。
go.onboarding.lesson.name=熟悉 {0}
go.onboarding.module.description={0} 中的主要功能概览
go.onboarding.module.name=入门导览
go.onboarding.project.view.description=<strong>项目</strong>视图是主要工具窗口之一。它包含项目目录、SDK 特定的软件包和临时文件。点击带条纹的按钮可以预览演示项目。您也可以按 {0} 打开。
go.onboarding.return.to.welcome=\ 并返回欢迎屏幕
go.onboarding.run.sample=选择“{0}”或尝试“{1}”。
go.onboarding.run.widget.balloon=使用此微件，您可以为所选配置执行常用的运行操作
go.onboarding.search.everywhere.description=可以看到，所选文本 {0} 已被自动复制到输入字符串中。我们不输入 {0}，而是输入 {1}。
go.onboarding.select.fix=应用第一个条目: {0}。通过该修正消除了不必要的圆括号。
go.onboarding.select.item=<ide/> 会在您输入时自动显示补全选项。使用键盘上的箭头选择“{0}”条目，然后按 {1}。
go.onboarding.start.debugging=点击“{0}”图标启动调试过程。
go.onboarding.start.typing=现在，开始输入 {0} 以显示补全选项。
go.onboarding.start.typing.balloon=开始输入 {0} 以显示补全选项
go.onboarding.stop.debugging=我们来停止调试。点击“{0}”图标。
go.onboarding.temporary.configuration.description=<ide/> 刚刚创建了一个临时运行配置。您可以在“{0}”中找到此配置。使用此微件，您可以为所选配置执行常用的运行操作，例如运行 {1}、调试 {2}。其他操作，如分析 {3} 以及使用覆盖率运行 {4} 可通过点击 {5} 显示。
go.onboarding.toggle.breakpoint.1=您可能会注意到 {1} 方法没有返回预期值 {0}，而是返回 {2}。我们来查看 return 语句，调试有问题的代码。
go.onboarding.toggle.breakpoint.2=点击高亮显示区域内的装订区域以设置断点。
go.onboarding.type.division=发现代码中的问题后，我们来修正。将得到的和除以值的长度。单元脚本已插入 {0}。
go.postfix.completion.better.variable.names.in.templates.description=<ide/> 可以帮助您对使用 {0} 和 {1} 后缀模板生成的变量进行命名。例如，在以下建议中，您可以会遇到: 用于索引的 {2} 或 {3}，或者用于 {5} 的 {4} 。
go.postfix.completion.better.variable.names.in.templates.use.forr=键入 {0}，然后从补全列表中选择 {1} 后缀模板。
go.postfix.completion.intro=使用后缀模板，您可以根据点号、表达式类型及其上下文后的后缀，将已经输入的表达式转换为其他表达式。您可以使用一组预定义的后缀补全模板或创建新模板。有关自定义后缀模板的更多信息，请参阅<a href = "{0}">此文档文章</a>。
go.postfix.completion.lesson.name=后缀补全
go.postfix.completion.task=我们的字母切片被打乱了。要对字符串切片正确排序，可以将 {1} 软件包中的 {0} 函数应用于切片。\n\
我们已经键入了保留切片的变量。接下来应用 {1} 后缀模板，无需反复操作。在 {3} 变量之后键入点({2})，查看后缀补全建议列表。从列表选择 {1}，或在编辑器中键入，然后按 {4} 补全语句。
go.postfix.templates.choose.item=输入 {0}，然后按 {1}。从建议列表中选择 {2}。
go.postfix.templates.lesson.name=后缀模板(nn、panic、rr 和 return)
go.postfix.templates.nn=键入 {0}，然后从补全列表中选择 {1} 后缀模板。
go.postfix.templates.return=键入 {0} 并应用 {1} 后缀模板。
go.postfix.templates.rr={0} 后缀补全模板生成一段代码，用于检查错误变量是否不为 {1}。您可以使用 {0} 后缀补全模板进行错误处理。\n\
现在键入 {2}，然后按 {3} 选择后缀模板。
go.press.and.apply.fix=按 {0} 并选择 {1}。
go.press.and.apply.fix.redundant.condition=IDE 会针对 {0} 循环中的冗余条件显示一条警告消息。要消除这种情况，请使用快速修复方法。\n\
按 {1} 并选择 {2}。
go.quick.documentation.convert.to.pointer.receiver=我们可以更新 {0} 方法以遵循约定。在 {2} 前键入 {1} 以将其从值接收器转换为指针接收器。
go.quick.documentation.iota=您可以直接从编辑器中获取任何符号的快速信息。例如，要查看{0}值，请调用“{1}”操作。\n\
按 {2} 可获取{3}常量的值。
go.quick.documentation.iota.methods.pointer.and.value.fix=<a href="{0}">Go 文档</a>建议给定类型上的所有方法都应具有值接收器或指针接收器。<ide/> 发现 {1} 结构在值接收器和指针接收器上都有方法。您可以重写或删除 {2} 方法。\n\
点击下面的链接继续下一步。
go.quick.documentation.title=使用快速文档
go.quick.fix.refactorings.change.to.formatting={0} 函数使用默认格式打印变量列表。同时，{1} 函数允许指定输出的格式。在示例中，我们将格式动词({2})用于浮点数。但是我们以 {0} 代替 {1}。\n\
来解决这个问题吧!按 {3}，然后选择 {4}。
go.quick.fix.refactorings.create.variable=有许多方法可以声明变量。声明变量后，即可使用等号({0})为其分配一个值。\n\
我们已经声明了 {1} 变量，但是尚未声明 {2} 变量。\n\
按 {3}，然后选择 {4}。现在该变量已声明但未初始化。让我们在其中存储一个零值!请从建议列表中选择 {5}。
go.quick.fix.refactorings.external.doc=外部文档会在 Web 浏览器中打开必要信息，以便您导航到相关符号，同时保留信息以备后续引用。\n\
现在，文本光标位于 {0} 函数上，按 {1}，打开 {2} 上有关 {0} 的文档。
go.quick.fix.refactorings.extract.method=使用 Extract Method 重构，您可以获取代码段，将其移至单独的函数，并用对该函数的调用替换旧代码。我们来将所有打印移至单独的函数。\n\
按 {0}。
go.quick.fix.refactorings.lesson.name=重命名、创建变量并将 Println 改为 Printf
go.quick.fix.refactorings.rename=在 <ide/> 中，您可以重命名元素，然后应用更改。<ide/> 重命名代码元素并相应地更新其用法。\n\
在 {1} 函数之前键入 {0} 将函数重命名为 {2}。按 {3}，然后选择 {4}。
go.refactorings.module.description=重构可使您的代码可靠、简洁并易于维护
go.refactorings.module.name=重构
go.rename.apply.intention=为此字段输入新名称。例如，键入 {0}，然后按 {1} 保存结果。
go.rename.invoke.intentions=您可以将文本光标放在符号上，并使用 {0} 重构来重命名任何内容。将文本光标放在代码任意位置的 {1} 字段上，然后按 {2}。
go.rename.lesson.name=重命名
go.running.code.context.menu=您可以通过不同的方式运行代码。其中一种方式是利用上下文菜单。\n\
尝试通过右键点击代码所在编辑器中的区域调用上下文菜单。
go.running.code.run.sample=点击“{0}”运行您的代码。应用程序的输出将显示在“{1}”工具窗口中。
go.running.module.description=在 IDE 中运行代码
go.running.module.name=正在运行
go.search.module.description=了解 IDE 的搜索功能
go.search.module.name=搜索
go.smart.type.completion.and.pointers.first.task=<ide/> 可以为您建议可能的指针和变量地址的列表。\n\
让我们从 {1} 函数返回 {0} 的地址。按 {2}，然后从补全列表中选择 {3}。
go.smart.type.completion.and.pointers.lesson.name=智能类型补全: 指针
go.smart.type.completion.and.pointers.second.task=SmartType 补全也可以与指针一起使用。按 {0} 返回指针，然后选择 {1}。
go.smart.type.completion.lesson.name=智能类型补全
go.smart.type.completion.special.cases.lesson.name=类型断言和 switch 结构
go.smart.type.completion.special.cases.line=如果您决定将字符串传递至 {0} 函数，会导致 {1} 错误。要检查任意值的类型，可以使用类型 switch 构造。按 {2}，然后选择 {3}。
go.smart.type.completion.special.cases.number=如果需要验证或检查变量的类型，可以使用类型断言或 switch 构造。<ide/> 将这些类型显示在建议列表的开头。要减少大量建议，可继续键入类型名称。\n\
让我们在 {0} 函数中补全验证。要完成操作，我们需要为 {2} 接口传递 {1} 类型。按 {3}，然后选择 {4} 类型。
go.smart.type.completion.task=智能类型补全可以筛选建议列表，使其仅包含当前上下文中适用的类型。按 {0} 以查看匹配建议的列表。按 {1} 选择第一个。
go.struct.fields.create.type=使用结构时，您可能希望先编写具有字段及其值的结构，然后在结构类型中定义所有内容。与示例一样，我们创建了一个新结构并为其字段定义了值。但我们仍然缺少结构定义。\n\
我们通过按 {0} 并选择 {1} {2} 快速修复来解决这个问题。
go.struct.fields.invoke.intentions=按 {0} 调用意图操作。
go.struct.fields.lesson.name=创建结构并填充结构字段
go.struct.fields.struct.no.fields=还有另一种情况，我们定义了所有内容，但需要为新结构填充字段名。我们可以手动重新输入，但 <ide/> 针对此过程有一个意图操作。
go.struct.fields.type.defined= 现在，已使用相应的字段对 {0} 结构进行了定义。
go.struct.inspections.delete.line=警告指出，我们尝试将两个 struct 字段({0} 和 {1})映射到相同的 JSON 字段名称，这并不好。遇到此错误，程序仍将运行，但是我们将在输出中错过一个键。\n\
要修正此问题，您可以重命名标记字符串中的值或删除整个字符串。我们简单点，按 {2} 删除整个字符串。
go.struct.inspections.jump.to.warning=Go 按约定会对 struct 标记编程。您可以阅读 <a href="{0}">pkg.go.dev 的文章</a>了解更多有关这些约定的信息。\n\
IDE 已经了解这些约定，并且将帮助您查找违反 Go 约定的不一致部分。找到的所有问题都会高亮显示。例如，{1} 字段周围的高亮显示。\n\
来导航到该错误，看看有什么问题吧。要跳转到警告，请按 {2}。
go.struct.inspections.lesson.name=struct 检查
go.support.for.table.tests.call.context.menu=在 <ide/> 中，您可以运行函数中的所有测试，或只运行部分测试。例如，点击 {0} 函数附近的装订区域中的运行图标，然后选择“{1}”。您将运行此函数中的所有测试。
go.support.for.table.tests.name=支持表测试
go.support.for.table.tests.run.subtest=您可以使用相同的方法运行单个子测试。点击 {0} 子测试附近的装订区域图标，然后选择“{1}”。\n\
这种方式当前存在多种限制，您可以在 <a href="{2}">GoLand 文档</a>中了解这些限制。
go.support.fuzz.testing.check.failing=糟糕，模糊测试失败了! 要找出原因，请在“{0}”工具窗口中向下滚动输出，然后点击指向 {1} 目录的链接。
go.support.fuzz.testing.run=模糊测试是一种通过不断提交各种输入来自动执行测试的方式。我们来运行模糊测试，根据各种生成的数据检查我们的函数。\n\
要运行模糊测试，请点击装订区域中的闪烁图标，然后选择“{0}”。
go.support.fuzz.testing.title=模糊测试
go.support.of.go.embed.fs=检查表明所指定的目录不存在。我们可以将它替换成现有目录。\n\
按 {0}，选择 {1}，键入 {2}，然后选择 {3}。
go.support.of.go.embed.name=基本补全: 使用 //go:embed
go.support.of.go.embed.navigate=我们的文件还有问题。按 {0} 导航到其他问题
go.support.of.go.embed.note={0}: 要使用 {1} 指令，请确保已安装 Go 1.16 或更高版本。有关 Go SDK 安装的详细信息，请参阅<a href="{2}">在文档中下载 Go SDK</a>。
go.support.of.go.embed.string=使用 {0} 指令，可以在构建期间将文件和目录嵌入到 Go 二进制文件中。\n\
我们来将 {1} 文件作为 {2} 类型嵌入。按 {3}，然后从建议列表中选择 {1}。
go.support.of.testify.framework.completion.and.subtests.assert=<strong>先决条件</strong>: 要完成本单元，<a href="{0}">请启用整个 GOPATH 的索引</a>并<a href="{1}">安装 {2} 包</a>。\n\
<strong>注意</strong>: 对整个 GOPATH 编制索引可能需要一些时间。编制索引速度取决于 GOPATH 下包的数量以及您的计算机性能。\n\
<ide/> 可以补全接受 {3} 作为第一个实参的函数或方法，IDE 会自动传递该实参。\n\
例如，将文本光标放在第 16 行 {6} 之后。在点后面键入 {4}，然后从补全列表中选择 {4}。键入 {5} (不要忘记逗号后面的空格)来完成实参列表。
go.support.of.testify.framework.completion.and.subtests.name=验证框架中的代码补全和子测试
go.support.of.testify.framework.completion.and.subtests.run.subtest=另外，只要子测试名称是字符串常量，就可以运行 {0} 和 {1} 子测试。\n\
例如，现在文本光标位于 {2}，您可以通过按 {3} 来运行它。
go.testing.module.description=测试可确保代码的行为正确无误且符合预期
go.testing.module.name=测试
go.to.internal.directory=从 {0} 2021.2 开始，您可以导航到 {1} 文件夹中存储的接口。\n\
按 {2} 转到 {3} 接口的实现。
go.to.internal.directory.build.constraints=根据 <a href="{0}">Bug-resistant build constraints 提案</a>，{1} 将被 {2} 替换。从 {1} 到 {2} 语法的过渡期将从 Go 1.16 持续到 1.18。在 Go 1.16 中，您可以使用旧语法或者同时使用两种语法。\n\
按 {3} 删除所选新语法声明。
go.to.internal.directory.hover.over.tab=顺便说一下，要查看文件位置，您可以将鼠标指标悬停在编辑器中的标签页上。例如，将指针悬停在“{0}”标签页上。
go.to.internal.directory.name=导航、构建约束和代码格式设置
go.to.internal.directory.reformat.gofmt.on.save= {0} 文件需要重新设置代码格式。按 {1} 重新设置文件格式。\n\
此外，默认情况下，<ide/> 将在内置的 <ide/> 格式化程序后运行{2}工具。此设置通过 {5} 中的“{4}”标签页上的“{3}”选项进行配置。
go.type.parameters.description=可能有助于您使用泛型的功能
go.type.parameters.module.name=泛型(类型形参)
go.var.check.error.postfix.template.anonymous.variable=键入 {0} 以使用空标识符，然后按 {1}。
go.var.check.error.postfix.template.call=来继续讨论错误处理。这次是讨论 {0} 后缀模板。如果是在返回错误的标识符之后键入它，<ide/> 会自动添加默认变量名，并且函数会返回错误。\n\
尝试在 {2} 函数后键入 {1}，然后从建议列表中选择 {0}。
go.var.check.error.postfix.template.name=varCheckError 后缀模板
go.var.check.error.postfix.template.quick.fix=Go 1.16 为 {0} 引入了新检查。它确保解封字节切片的值不是 {1}。<ide/> 会检测此类情况，并提供用于解决这些问题的快速修复。\n\
按 {2} 并选择 {3}。
go.variadic.functions.inline=您可以使用切片的可变实参替换切片。按 {0} 调用 {1} 重构。
go.variadic.functions.introduce.variable=要还原 {0} 重构，请使用 {1} 重构。按 {2}，然后从建议列表中选择 {3}。
go.variadic.functions.lesson.name=可变函数(快速修复和重构)
go.variadic.functions.unpack.slice=可变函数是可以使用不同数量的实参调用的函数，例如 {0}。\n\
可变函数将可变实参作为切片处理。\n\
在我们的示例中，该可变函数为 {1}。\n\
但是，我们无法按原样将 {2} 切片传递至可变函数 {3}。对于这种情况，Go 提供了特殊语法。就是切片之后的省略号({4})。\n\
要解决该错误，按 {5}，然后选择 {6}。
go.what.s.new.module.description=GoLand 2023.2 的新功能(2023 年 7 月)
go.what.s.new.module.name=GoLand 2023.2 最新变化
go.working.with.json.add.key.to.tags=要添加 XML 和 ASN1 标记，也可以使用意图操作。\n\
按 {0} 再次调用意图操作，然后选择 {1} 并键入 {2}。
go.working.with.json.change.style=您可以为标记中的字段名称应用不同的代码样式。例如，将其更改为骆驼拼写法。\n\
按 {0}，点击“{1}”，然后选择“{2}”。
go.working.with.json.copy=<ide/> 有几种工具可以帮助您更有效地处理 JSON 代码。\n\
按 {0} 复制所选的 JSON。
go.working.with.json.introduce.type=提取嵌入到 {1} 结构中的 {0} 结构。\n\
按 {2} 并选择 {3}。
go.working.with.json.name=使用 JSON
go.working.with.json.name.struct=更改结构名称，键入 {0}，然后按 {1} 完成编辑。IDE 将自动修复您的格式设置。
go.working.with.json.replace=按 {0} 替换注释部分。出现“{1}”对话框时，请点击<strong>是</strong>。\n\
<ide/> 自动将复制的 JSON 部分转换为结构类型。
go.working.with.json.update.value.in.tags=标记值的批处理更新也是如此。假设我们想将 {0} 添加到当前结构中的每个标记。\n\
按 {1}，选择 {2}，然后键入 {3}。\n\
您也可以从建议列表中选择 {0}。<ide/> 知道 JSON、XML 和 ASN1 标记的最常用值。
go.working.with.parameters.invoke.intentions.1=文本光标位于 {0} 方法的第一个形参处。按 {1} 调用意图操作。
go.working.with.parameters.invoke.intentions.2=查看编辑器中的 {0} 方法。文本光标位于第一个形参处。按 {1} 调用意图操作。
go.working.with.parameters.invoke.intentions.3=如果方法实现接口时需要形参，那么将其移除会不安全。按 {0} 查看可能选项的列表。
go.working.with.parameters.lesson.name=使用形参
go.working.with.parameters.press.action.again=现在，再按一下 {0}。
go.working.with.parameters.remove.parameters=<ide/> 仅高亮显示未使用形参的名称，前提是其类型用于实现方法规范。在这种情况下，您可以将此形参重命名为 {0} 或完全移除其名称。
go.working.with.parameters.signature.combined=注意签名类型的组合方式。
go.working.with.parameters.signature.expanded=要将签名恢复到初始状态，请选择 {0}。
go.working.with.parameters.single.type=如果函数或方法签名中具有单个类型的多个形参，则可以为这些形参使用简短的类型规范({0})，也可以为每个形参使用单独的类型规范({1})。
go.working.with.parameters.that.are.not.used=<ide/> 可以检测签名中未用于方法或函数体的形参。只要它们未被使用，就可以通过“{0}”快速修复将其删除。
go.wrapping.delete.line=警告指出，我们尝试将一个整数传递给格式设置函数。{0} 获取包含需要格式化的文本的模板字符串。我们可以使用格式动词或使用快速修复将整数转换为字符串。\n\
按 {1} 并选择 {2}。
go.wrapping.enable.soft.wrap=第一个实参仍在可见区域之外。可能需要为长行启用软换行。按 {0}，键入 {1}，然后切换 {2} 开关。随后您可以按 {3} 关闭搜索。
go.wrapping.lesson.name=换行并删除代码行
go.wrapping.put.arguments.on.separate.lines=我们将大量实参传递到 {0} 函数。问题在于第一个实参很长，无法看到它后面的内容。\n\
将文本光标放在左中括号之后，接着按 {1} 并选择 {2}，即可解决这个问题。
go.wrapping.put.parameters.on.same.lines=也许，{0} 函数中的实参都在一行中会看起来更好。要进行合并，应将文本光标放在左中括号之后，按 {1} 调用意图操作，然后选择 {2}。
toggle.case.part=大/小文字