GuiceClassAnnotator.popup.title=选择要导航到的表达式
GuiceClassAnnotator.popup.tooltip.text=导航到 Guice 绑定表达式
ImplicitSubclassInspection.display.forMethod.annotated=@Transactional 方法不得为 private
action.group.guice.description=Google Guice 组件
action.group.guice.title=Google Guice
binding.annotation.without.inject.display.name=没有 @Inject 的绑定注解
binding.annotation.without.inject.problem.descriptor=没有声明 @Inject 的绑定注解 #ref #loc
class.provided=提供的类:
conflicting.annotations.display.name=Guice 注解冲突
conflicting.annotations.problem.descriptor=注解 #ref 与声明的其他注解冲突 #loc
delete.binding=删除绑定
group.guice.inspections.name=Guice
guice.intentions=Guice
gutter.choose.injected.point=选择注入点
gutter.navigate.to.injection.point=导航到注入点
interception.annotation.without.runtime.retention.display.name=没有运行时保留的截取注解
interception.annotation.without.runtime.retention.problem.descriptor=注解 #ref 没有运行时保留 #loc
invalid.implemented.by.display.name=@ImplementedBy 注解无效
invalid.implemented.by.problem.descriptor=#ref 类未实现注解类 #loc
invalid.provided.by.display.name=@ProvidedBy 注解无效
invalid.provided.by.problem.descriptor=#ref 类未提供注解类 #loc
invalid.request.parameters.display.name=@RequestParameters 形参的类型不正确
invalid.request.parameters.problem.descriptor=标记为 #ref 的变量或形参的类型必须为 Map<String, String[]> #loc
make.injection.mandatory=将注解设为强制
make.injection.optional=将注解设为可选
move.binding.scope.to.class.family.name=将绑定作用域移至类
move.binding.scope.to.class.text=将绑定作用域移至类
move.binding.to.class.family.name=将绑定移至类
move.binding.to.class.text=将绑定类移至类
move.provider.binding.to.class.family.name=将提供程序绑定移至类
move.provider.binding.to.class.text=将提供程序绑定移至类
multiple.binding.annotations.display.name=变量有多个绑定注解
multiple.binding.annotations.problem.descriptor=变量 #ref 有多个绑定注解 #loc
multiple.injected.constructors.for.class.display.name=类有多个 @Inject 构造函数
multiple.injected.constructors.for.class.problem.descriptor=类 #ref 有多个 @Inject 构造函数 #loc
new.guice.binding.annotation.action.name=创建 Guice 绑定注解
new.guice.binding.annotation.error=无法创建 Guice 绑定注解
new.guice.binding.annotation.name=创建 Guice 绑定注解: {0}。{1}
new.guice.method.interceptor.action.name=创建 Guice 方法拦截器
new.guice.method.interceptor.error=无法创建 Guice 方法拦截器
new.guice.method.interceptor.name=创建 Guice 方法拦截器: {0}。{1}
new.guice.module.action.name=创建 Guice 模块
new.guice.module.error=无法创建 Guice 模块
new.guice.module.name=创建 Guice 模块: {0}。{1}
new.guice.provider=新建 Guice 提供程序
new.guice.provider.action.name=创建 Guice 提供程序
new.guice.provider.error=无法创建 Guice 提供程序
new.guice.provider.name=创建 Guice 提供程序: {0}。{1}
new.guice.scope.annotation.action.name=创建 Guice 作用域注解
new.guice.scope.annotation.error=无法创建 Guice 作用域注解
pointless.binding.display.name=无意义的绑定
pointless.binding.problem.descriptor=绑定非必要，可以移除 #loc
provider.class.name=提供程序类名:
redundant.scope.binding.display.name=冗余作用域绑定
redundant.scope.binding.problem.descriptor=与作用域 #ref 的绑定冗余 #loc
redundant.to.binding.display.name=冗余绑定
redundant.to.binding.problem.descriptor=与类 #ref 的绑定冗余 #loc
redundant.to.provider.binding.display.name=冗余提供程序绑定
redundant.to.provider.binding.problem.descriptor=与类 #ref 的绑定冗余 #loc
select.provided.class=选择要提供的类
session.scoped.injects.request.scoped.display.name=@SessionScoped 组件注入 @RequestScoped 组件
session.scoped.injects.request.scoped.problem.descriptor=@RequestScoped 类 #ref 的 @Inject 来自 @SessionScoped 类 #loc
singleton.injects.scoped.display.name=@Singleton 组件注入作用域组件
singleton.injects.scoped.problem.descriptor=作用域类 #ref 的 @Inject 来自 @Singleton 类 #loc
toggle.injection.required.family.name=切换注入
toggle.required=切换 'optional'
uninstantiable.binding.display.name=无法实例化的绑定
uninstantiable.binding.problem.descriptor=类 #ref 不可实例化，因此不可绑定 #loc
uninstantiable.implemented.by.class.display.name=无法实例化的 @ImplementedBy 类
uninstantiable.implemented.by.class.problem.descriptor=类 #ref 不可实例化，因此不能为 @ImplementedBy #loc
uninstantiable.provided.by.class.display.name=无法实例化的 @ProvidedBy 类
uninstantiable.provided.by.class.problem.descriptor=类 #ref 不可实例化，因此不能为 @ProvidedBy #loc
unnecessary.static.injection.display.name=不必要的 static 注入
unnecessary.static.injection.problem.descriptor=类 #ref 没有 static @Inject 成员 #loc