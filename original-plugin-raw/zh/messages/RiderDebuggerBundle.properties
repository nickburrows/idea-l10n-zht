AttachFromCommandLineInternalAction.dialog.field.label.pid=PID\:
AttachFromCommandLineInternalAction.dialog.message.invalid.pid=PID 无效
AttachFromCommandLineInternalAction.dialog.note.enter.pid=输入 PID\:
AttachFromCommandLineInternalAction.dialog.title.pid.selector=PID 选择器
# {0} is execution file name
AttachOpenSolutionStarter.notification.title.jit.debugger.run.config=JIT 调试器运行配置
# {0} is configuration name, {1} is execution file name.
AttachOpenSolutionStarter.notification.content.run.configuration.was.created=''{0}'' 运行配置已创建。现在，来自 ''{1}'' 的 Debugger.Launch 将自动附加到此解决方案。要取消此行为，请移除此运行配置。
DotNetDebugProcess.curr.state.message.target.ready=目标就绪
DotNetDebugProcess.curr.state.message.waiting.for.target=正在等待目标就绪
JITDebuggerNotifier.message=您可以将 Rider 设置为默认 JIT 调试器
# {0} is file path
DotNetDebugSourceHashChecker.notification.content.source.may.have.changed=自构建模块以来，源文件 {0} 可能已更改
DotNetDebugSourceHashChecker.notification.content.source.may.have.changed.hyperlink.message=不对当前调试会话显示
tab.display.name.parallel.stacks=并行堆栈
display.name.memory=内存
tab.display.name.debug.output=调试输出
tab.display.name.threads=线程
notification.content.exception.suspend=断点 ''{0}'' 异常 - {1, choice, 0\#已禁用|1\#已启用} ''Suspend'' 选项
# {0} is Type
notification.content.unable.to.modify.properties.exception=无法修改异常 ''{0}'' 的属性
DotNetExecutionStack.dialog.message.stack.not.valid=堆栈无效
DotNetExecutionStack.tooltip.drag.to.skip.code=拖动以跳过代码
DotNetInitializeDebuggerTask.progress.title.initializing.debugger=正在初始化调试器…
# {0} is namespace
# {1} is module name
DotNetValueModifier.dialog.message.operation.was.cancelled=操作已被取消
dialog.message.request.was.cancelled=请求已被取消
notification.content.can.t.get.type=无法获取类型
# {0} is type name
notification.content.can.t.navigate.to.type=无法导航到类型 {0}
HotReloadBuildToolWindowFactory.tab.title.hot.reload.build.results=热重载构建结果
HotReloadBuildToolWindowFactory.label.external.code=[外部代码\:
JITDebuggerUpdater.notification.title.should.be.updated=应更新 JIT 调试器
JITDebuggerUpdater.notification.content.new.version.available=存在新版本的 JIT 调试器。Debugger.Launch 现在可能无法运行。
JITDebuggerUpdater.notification.content.new.version.available.hyperlink=立即更新
JITDebuggerUpdater.notification.content.successfully.updated=JIT 调试器工具已成功更新
dialog.title.elevated.permissions.required=需要提升的权限
dialog.message.rider.has.to.be.restarted.elevation.for.debug=必须使用提升的权限重新启动 Rider 才能调试此应用程序。是否要重新启动 Rider?
dialog.message.rider.has.to.be.restarted.elevation.for.run=必须使用提升的权限重新启动 Rider 才能运行此应用程序。是否要重新启动 Rider?
RiderDebugRunner.dialog.message.worker.process.exited.unexpectedly=调试器工作进程已意外退出，退出代码为 {0}
RiderDebugRunner.dialog.message.worker.was.not.initialized.within.ms=调试器工作线程未在 {0} 毫秒内初始化
RiderDebugWritingAccessManager.dialog.title.write.access.is.denied=调试期间的写入权限被拒
RiderDebugWritingAccessManager.dialog.message.allow.typing=是否要在调试期间允许输入?
RiderDebugWritingAccessManager.notification.title.readonly.settings=只读模式设置
RiderDebugWritingAccessManager.notification.content.readonly.settings=您可以在调试期间在<a href\="settings">调试器设置</a>中更改只读模式设置
RiderDebugWritingAccessManager.dialog.title.hot.reload=热重载
# {0} is the message being asked about
RiderDebugWritingAccessManager.dialog.message.0.continue.editing={0}\n是否禁用热重载并继续编辑?
RiderDebugWritingAccessManager.checkbox.always.allow.editing.during.debug=为新会话禁用热重载(您可以稍后在设置中启用)
RiderDebugWritingAccessManager.dialog.message.changes.while.not.ready=热重载已启用，需要完成初始化才能允许在运行时进行编辑
popup.title.debugger=调试器
RiderAttachToRemoteProcessAction.group.name.remote.hosts=远程主机
RiderAttachToRemoteProcessAction.debugger.display.name.create.host=创建主机
# Used as action
RiderAttachToRemoteProcessAction.text.add.remote.host=添加远程主机…
ChooseCoreDumpConfiguration.popup.title.choose.core.dump=选择核心转储
RemoteDebugger.get.jetbrains.ssh.tool.link=获取 JetBrains 远程调试 SSH 工具
RiderDetachDebuggerAction.action.detach.text=分离
RiderDetachDebuggerAction.action.detach.description=分离
RiderDetachDebuggerAction.action.detach.0.text=分离 ''{0}''
# {0} is file path
RiderDebugDumpAction.notification.content.format.not.supported=不支持所选核心转储文件 ''{0}'' 的格式
RiderDebugDumpAction.popup.title.debug.core.dump.as=将核心转储调试为…
RiderMarkObjectHandler.tooltip.text.label.name.is.not.valid=标签名称无效\: {0, choice, 0\#名称必须符合变量限制|1\#已存在}
RiderNewSmartStepIntoHandler.popup.title.method.to.step.into=进入的方法
RiderSmartStepIntoVariant.description.execute.again=再次执行
RiderSmartStepIntoUtils.notification.content.unable.smart.step.into.list=无法获取智能步入列表
# {0} is reason message
RiderSmartStepIntoUtils.notification.content.unable.smart.step.into.list.reason=无法获取智能步入列表\: {0}
RiderSmartStepIntoUtils.choose.smart.step.into.target=选择智能步入目标
RiderSmartStepIntoUtils.execute.again=再次执行
MsClrAttachGroup.group.name.net.processes=.NET 进程
MsNetAttachProvider.display.name=.NET 调试器
MsNetAttachDebugger.display.name=.NET 调试器 [{0}]
MsNetCoreAttachDebugger.display.name=.NET Core 调试器
MsNetUwpAttachDebugger.display.name=UWP 调试器
MsNetAttachDebugger.display.short.name=.NET
DotNetCoreAttachGroup.group.name.net.core.processes=.NET Core 进程
ElevateActionDebugger.display.name=提升
ElevateActionDebugger.group.name.elevation.required=需要提升
RemoteDebuggerUtils.progress.text.compressing=正在压缩调试器工具 {0}/{1}…
RemoteDebuggerUtils.download.header=远程调试器工具
RemoteDebuggerUtils.progress.text.tools.uploading=正在上传远程调试器工具…
RemoteDebuggerUtils.progress.text.retrieve.tools=正在检索远程调试器工具信息，第 {0} 步，共 3 步…
RemoteDebuggerUtils.progress.text.upload.enumerator.and.debugger.workers=正在上传枚举器和调试器工作进程…
RemoteDebuggerUtils.progress.text.extracting=正在提取…
RemoteDebugTools.calculate.processes.error.message=无法列出进程。
RemoteDebugTools.calculate.processes.error.message.action=重试.
# {0}@{1}:{2} is username@host:port
RemoteDebuggerUtils.popup.title.attach.to.process.from=从 {0}@{1}\:{2} 附加到进程
# {0} is transferred
# {1} is total count
# {2} is seconds count
RemoteDebuggerUtils.progress.text.uploaded.remaining.time=已上传 {0} 个，共 {1} 个，剩余时间\: {2} 秒
RemoteDebugToolsNotLoadedProcessInfo.remote.debugger.tools.are.not.loaded=远程调试器工具未加载到远程主机。
RemoteDebugToolsNotLoadedProcessInfo.remote.debugger.tools.are.not.loaded.action=点击以加载。
rider.remote.debug.enumerator.exited.error.message=无法列出进程。进程枚举器意外退出.
# {0} is error message
UploadErrorProcessInfo.error.show.details=显示详细信息.
DotNetEvaluator.dialog.message.evaluation.request.was.cancelled=求值请求已被取消
RiderStopOnExceptionAction.notification.title.new.exception.rule=新异常规则
# {0} is exception type
RiderStopOnExceptionAction.notification.content.new.exception.rule=已创建类型 ''{0}'' 的异常规则
dialog.title.ssh.password.login=SSH 密码登录
dialog.title.ssh.key.passphrase=SSH 密钥密码短语
dialog.message.remote.debugging.uwp.not.supported=尚不支持 UWP 应用程序的远程调试
DotNetExceptionBreakpointType.tab.title.clr.exception.breakpoints=CLR 异常断点
DotNetNewExceptionBreakpointsDialog.dialog.title.add.clr.exception.breakpoints=添加 CLR 异常断点
RiderDataBreakpointPane.label.previous.value=上一个值\:
RiderDataBreakpointPane.label.new.value=新值\:
ImmediateWindow.placeholder.evaluation.with.breakpoints.available=在考虑断点的情况下对表达式求值
ImmediateWindow.not.supported.for.old.debugger.tab=要使用 Immediate 窗口，请启用新的调试器工具窗口并重新启动调试器会话
ImmediateWindowContentManager.enable.new.debugger.tab=启用
MemoryViewGetValuesTask.progress.title.getting.memory.snapshot=正在获取内存快照…
RiderClassesTable.column.name.size.bytes=大小(字节)
# {0} is number, {1} is total count
RiderInstancesView.label.shown.0.1=已显示\: {0} / {1}
RiderInstancesView.label.shown.more=显示更多
PinnedItemsNotificationManager.notification.content.pinned.items.are.in.favorites=固定条目列在 ''{0}'' 中
DotNetDebuggerAllLanguagesConfigurableUi.checkbox.show.prompt.to.allow.editing=显示提示以允许编辑
DotNetDebuggerSettings.checkbox.cluster.big.arrays=为大数组划分聚类
DotNetDebuggerSettings.checkbox.show.non.public.members.in.separate.group=在单独的组中显示非 public 成员
DotNetDebuggerSettings.checkbox.flatten.objects.hierarchy=平展对象层次结构
DotNetDebuggerSettings.checkbox.show.fully.qualified.type.names=显示完全限定类型名称
DotNetDebuggerSettings.checkbox.show.hex.value.for.integers=显示整数的十六进制值
DotNetDebuggerSettings.checkbox.add.raw.view.for.debugger.browsable.values=添加调试器可浏览值的原始视图
DotNetDebuggerSettings.checkbox.show.compiler.generated.members=显示编译器生成的成员
DotNetDebuggerSettings.checkbox.show.type.variables=显示类型变量
DotNetDebuggerSettings.checkbox.truncate.long.strings=截断长字符串的表示
DotNetDebuggerSettings.checkbox.truncate.long.strings.counter=阈值
DotNetDebuggerSettings.checkbox.allow.editing.in.the.debug.mode=允许在调试模式下编辑
DotNetDebuggerSettings.configurable.name.remote.debug=远程调试
DotNetDebuggerSettings.configurable.name.net.languages=.NET 语言
DotNetDebuggerSettings.configurable.name.all.languages=所有语言
DotNetDebuggerGeneralConfigurableUi.checkbox.allow.implicit.target.invoke=允许属性求值和其他隐式函数调用
DotNetDebuggerGeneralConfigurableUi.checkbox.automatically.refresh.watches=在调试器暂停时刷新监视值
DotNetDebuggerGeneralConfigurableUi.checkbox.process.exceptions.outside.of.my.code=我的代码以外的进程异常(不包括 Mono)
DotNetDebuggerGeneralConfigurableUi.checkbox.break.on.user.unhandled=在遇到用户未处理的异常时中断(不包括 Mono)
DotNetDebuggerGeneralConfigurableUi.checkbox.break.on.unhandled=在遇到未处理的异常时中断
DotNetDebuggerGeneralConfigurableUi.checkbox.disable.jit.optimization=在加载模块时禁用 JIT 优化
DotNetDebuggerGeneralConfigurableUi.checkbox.ignore.precompiled.assemblies=即使可以使用预编译的程序集，也使用 JIT
DotNetDebuggerGeneralConfigurableUi.checkbox.enable.external.source.debug=启用外部源调试
DotNetDebuggerGeneralConfigurableUi.checkbox.enable.breakpoint.suggestion=鼠标悬停时显示断点预览
DotNetDebuggerGeneralConfigurableUi.checkbox.set.rider.jit.debugger=将 Rider 设置为默认调试器
DotNetDebuggerGeneralConfigurableUi.checkbox.restore.previous.debugger=还原之前的默认调试器
DotNetDebuggerGeneralConfigurableUi.checkbox.show.return.values=显示返回值
DotNetDebuggerGeneralConfigurableUi.checkbox.save.all.files.on.debugger.launch=调试器启动时保存所有文件
DotNetDebuggerGeneralConfigurableUi.checkbox.pin.to.top.should.change.presentation=“置顶”应该会改变调试器对象的显示
DotNetDebuggerGeneralConfigurableUi.label.maximum.recursion.level=最大递归级别\:
# Part of sentence "Show floating debugger actions ({icon1} and {icon2}) in editor"
DotNetDebuggerGeneralConfigurableUi.checkbox.show.run.to.panel.1=在编辑器中显示浮动调试器操作(
# Part of sentence "Show floating debugger actions ({icon1} and {icon2}) in editor"
DotNetDebuggerGeneralConfigurableUi.checkbox.show.run.to.panel.2=和
# Part of sentence "Show floating debugger actions ({icon1} and {icon2}) in editor"
DotNetDebuggerGeneralConfigurableUi.checkbox.show.run.to.panel.3=)
DotNetDebuggerGeneralConfigurableUi.group.name.jit=JIT (不包括 Mono)
DotNetDebuggerGeneralConfigurableUi.help.label.disable.jit.optimizations=如果进程由调试器启动，此选项可以避免对在发布模式下编译的所有程序集(系统和二进制引用)进行优化。它会降低进程的运行速度，但可以让您检查这些程序集中经过优化的局部变量。
DotNetDebuggerGeneralConfigurableUi.help.label.use.jit.for.precompiled.assemblies=如果为程序集加载了预编译的映像(NGen、CrossGen 或任何 AOT)，则 JIT 将不运行，并且禁用 JIT 优化不起任何作用。此选项可以让调试器忽略预编译的映像并让 JIT 编译程序集。它会减慢进程启动速度，但可以让您检查程序集中经过优化的局部变量(如果禁用了 JIT 优化)。

# {0} is some text.
DotNetDebuggerGeneralConfigurableUi.0.net.core.only={0} (不包括 Mono)
DotNetDebuggerGeneralConfigurableUi.0.typing.is.not.allowed={0} (不允许输入)
DotNetDebuggerGeneralConfigurableUi.label.evaluation.timeout.ms=求值超时(ms)
DotNetDebuggerGeneralConfigurableUi.label.jit.debugger.cant.get.localappdata.folder.path=JIT 调试器设置\: 无法获取 LocalAppData 文件夹的路径
DotNetDebuggerGeneralConfigurableUi.dialog.message.timeout.should.be.non.negative=超时必须为非负值
debugger.action.link.force.refresh=Force Refresh
debugger.action.link.view=查看
debugger.action.link.create.breakpoint=配置
debugger.action.link.refresh=刷新
RiderDebugContextActionsHost.hint.text.updating.class.instances=正在更新类实例…
# {0} is class name
RiderDebugContextActionsHost.hint.text.instances.not.found=找不到类 ''{0}'' 的实例
RiderDebugContextActionsHost.hint.text.instances.are.not.available=无法获取类 ''{0}'' 的实例
RemoteDebuggerUtils.progress.title.checking.remote.debugger.tools=正在检查远程调试器工具
RemoteDebuggerUtils.progress.title.uploading.remote.debugger.tools=正在上传远程调试器工具
RiderRunToPopupManager.tooltip.run.to.here=运行到此处
RiderRunToPopupManager.tooltip.skip.to.here=跳到此处

exception.filters.update.message=正在查找有效的 .NET 堆栈跟踪…
highlight.call.stacks.in.output.message=在“调试输出”窗口中高亮显示调用堆栈

RiderDebuggerDisableMethodToInvokeAction.enable=启用对所选条目的求值
RiderDebuggerDisableMethodToInvokeAction.enable.multi=启用对所选条目的求值
RiderDebuggerDisableMethodToInvokeAction.disable=禁用对所选条目的求值
RiderDebuggerDisableMethodToInvokeAction.disable.multi=禁用对所选条目的求值
MonoAttachDebugger.display.name.mono.debugger=Mono 调试器
MonoAttachDebugger.display.short.name.mono.debugger=Mono
MonoAttachGroup.group.name.mono.processes=Mono 进程
DotNetLineBreakpointType.net.line.breakpoints=.NET 行断点
DotNetLineBreakpointType.line.in.function={1}中的行 {0}
DotNetLineBreakpointType.all.breakpoints.message=全部
DotNetMethodBreakpointType.title.method.breakpoints=方法断点
DotNetMethodBreakpointType.label.type.name=类型名称\:
DotNetMethodBreakpointType.label.method.name=方法名称\:
DotNetMethodBreakpointType.dialog.title.add.method.breakpoint=添加方法断点
DotNetMethodBreakpointType.dialog.message.type.name.not.set=未设置类型名称
DotNetMethodBreakpointType.dialog.message.method.name.not.set=未设置方法名称
DotNetSteppingConfigurableUi.checkbox.always.do.smart.step.into=始终进行智能单步执行
DotNetSteppingConfigurableUi.checkbox.show.executed.calls.in.smart.step.into=在“智能步入”中显示已执行的调用
DotNetThreadSpecificBreakpointsPanel.checkbox.suspend.only.on.specific.thread=仅在特定线程上挂起\:
DotNetUserUnhandledIgnoreList.dialog.title.add.exceptions.to.ignore=添加要忽略的异常
DotNetUserUnhandledIgnoreList.label.except=排除\:

rider.debug.restart.with.elevated.privileges.action.text=使用提升的权限重新启动 Rider

RemoteDebugConfigurableUi.upload.debug.symbols.for.remote.debugger=上传远程调试器的调试符号
RemoteDebugConfigurableUi.label.os=OS\:
RemoteDebugConfigurableUi.label.passphrase=密码短语\:
RemoteDebugConfigurableUi.label.confirm.passphrase=确认密码短语\:
RemoteDebugConfigurableUi.checkbox.use.passphrase=使用密码短语
RemoteDebugConfigurableUi.public.key.comment=公钥注释\:
RemoteDebugConfigurableUi.button.generate=生成
RemoteDebugConfigurableUi.label.public.key.file=公钥文件\:
RemoteDebugConfigurableUi.dialog.title.select.public.key=选择公钥
RemoteDebugConfigurableUi.label.select.public.key=选择公钥以生成用于配置 SSH 服务器的脚本
RemoteDebugConfigurableUi.label.output.folder=输出文件夹\:
RemoteDebugConfigurableUi.dialog.title.select.output.folder=选择输出文件夹
RemoteDebugConfigurableUi.label.select.folder.to.write.generated.keys.scripts=选择用于编写生成的密钥和脚本的文件夹
RemoteDebugConfigurableUi.checkbox.use.existing.key=使用现有密钥
RemoteDebugConfigurableUi.message.given.passphrases.do.not.match=给定密码短语不匹配
RemoteDebugConfigurableUi.dialog.title.cant.generate.key.pair=无法生成密钥对
RemoteDebugConfigurableUi.dialog.message.passphrase.is.empty=密码短语为空
RemoteDebugConfigurableUi.dialog.message.generation.completed.successfully=生成成功完成
RemoteDebugConfigurableUi.dialog.title.remote.tools.generator=远程工具生成器
RemoteDebugConfigurableUi.dialog.message.exception.occurred.0=发生异常\: {0}
RemoteDebugConfigurableUi.dialog.title.generation.error=生成错误
RemoteDebugConfigurableUi.border.title.generate.ssh.tools=生成 SSH 工具
RemoteDebugConfigurableUi.ubuntu=Ubuntu
RemoteDebugConfigurableUi.border.title.ssh.credentials.for.remote.debugging=远程调试的 SSH 凭据
notification.title.failed.to.resolve.host=无法解析主机
notification.title.failed.to.connect=无法连接
notification.title.no.password.provided=未提供密码
notification.title.no.passphrase.provided=未提供密码短语
notification.title.authentication.failed=身份验证失败
notification.title.failed.to.open.sftp.connection=无法打开 SFTP 连接
notification.title.failed.to.list.processes=无法列出进程
RiderSshRemoteGroup.group.name.remote.hosts=远程主机
SymbolServerConfigurable.configurable.name.external.symbols=外部符号
SymbolServerConfigurable.checkbox.use.sources.from.symbol.files.when.available=尽可能使用符号文件中的源代码
SymbolServerConfigurable.tooltip.text.use.symbol.files.to.get.compiled.code.source=使用符号文件获取编译的代码源
SymbolServerConfigurable.checkbox.allow.downloading.symbols.from.remote.locations=允许从远程位置下载符号
SymbolServerConfigurable.tooltip.text.download.symbol.files.from.symbol.server.s=从符号服务器下载符号文件
SymbolServerConfigurable.checkbox.enable.private.source.link.support=启用不公开源链接支持
SymbolServerConfigurable.checkbox.decompile.methods=反编译方法
SymbolServerConfigurable.tooltip.text.decompile.method.bodies=反编译方法体
SymbolServerConfigurable.checkbox.show.non.public.compiled.items=在“转到…”结果中显示非 public 编译条目
SymbolServerConfigurable.tooltip.text.show.non.public.compiled.items.in.go.to=在“转到…”结果中显示非 public 编译条目
SymbolServerConfigurable.separator.symbol.servers=符号服务器
# Used as empty text
SymbolServerConfigurable.empty.text.no.symbol.servers.configured=未配置符号服务器
SymbolServerConfigurable.dialog.message.enter.symbol.server.url=输入符号服务器 URL
SymbolServerConfigurable.dialog.title.symbol.server=符号服务器
SymbolServerConfigurable.error.text.uri.scheme.not.specified=未指定 URI 方案。支持的 URI 方案\: file、http、https。
SymbolServerConfigurable.error.text.unsupported.uri.scheme=不受支持的 URI 方案\: {0}
SymbolServerConfigurable.error.text.malformed.uri=URI 格式不正确
UWPAppAttachGroup.group.name.uwp.processes=UWP 进程
dialog.message.this.run.profile.not.supported=不支持此运行配置文件\: {0}
dialog.message.failed.to.launch.application.file.doesn.t.exist=无法启动应用程序\: 文件 ''{0}'' 不存在
RemoteDebugConfigurableUi.label.user.name=用户名
RemoteDebugConfigurableUi.label.host=主机
RemoteDebugConfigurableUi.label.authentication=身份验证

RiderExternalSourceDebugNotifier.notification.message.debugging.external.code=正在调试外部代码，实时反编译
RiderExternalSourceDebugNotifier.notification.message.debugging.external.code.suggest.jit.configuring=正在调试外部代码，实时反编译。要检查优化后的局部变量，请配置 JIT 行为
RiderExternalSourceDebugNotifier.notification.action.configure.jit=配置 JIT 行为
RiderExternalSourceDebugNotifier.notification.action.configure.external.source.debug=配置外部源调试
RiderHotReloadNotifier.sources.are.modified=源代码已修改。
RiderHotReloadNotifier.changes.will.be.applied=更改将在下一步或恢复时应用。
RiderHotReloadNotifier.continue.without.changes=继续且无任何更改
RiderHotReloadNotifier.apply.changes=应用更改
DotNetDebuggerGeneralConfigurableUi.label.editing.during.debug=调试期间编辑\:
DotNetDebuggerGeneralConfigurableUi.label.value.inspections=值检查\:
DotNetDebuggerGeneralConfigurableUi.label.exceptions=异常\:
DotNetDebuggerGeneralConfigurableUi.label.pin.to.top=固定至顶部\:
DotNetDebuggerGeneralConfigurableUi.label.just.in.time.debugger=即时调试器\:
RiderExceptionGroupByNamespaceRule.rule.name.group.by.namespace=按命名空间分组
RiderExceptionGroupBySourceRule.group.name.group.by.exception.source=按异常源分组

DotNetStackFrame.presentation.suffix.message=(在 {0}, {1} 中)
DotNetStackFrame.location.presentation.suffix.message=在 {0}
DotNetStackFrame.location.line.presentation.suffix.message=\:行 {0}

ExternalCodeMetaFrame.frame.text=框架

RemoteDebugger.host.resolve.error.message.first=未知主机\: ''{0}''。
RemoteDebugger.host.resolve.error.message.second=请检查主机名是否正确，并确认网络没有问题。
RemoteDebugger.establish.connection.error.message.first=无法与 {0} 建立连接。
RemoteDebugger.establish.connection.error.message.second=请检查主机名({0})和端口({1})是否正确，以及 SSH 服务器是否正在远程主机上运行。
RemoteDebugger.authentication.failed.error.message=使用{1}方法对 {0} 进行身份验证的尝试失败.
RemoteDebugger.authentication.password.error.message=正在尝试使用密码进行身份验证，但未提供密码。
RemoteDebugger.authentication.passphrase.error.message=正在尝试使用密钥对进行身份验证，但未提供密码短语。
RemoteDebugger.authentication.other.error.message=请检查用户名和身份验证方法是否正确。
RemoteDebugger.sftp.error.message.first=SSH 连接成功，但 SFTP 连接失败。
RemoteDebugger.sftp.error.message.second=请检查 SSH 服务器的设置中是否启用了 SFTP。
RemoteDebugger.unknown.error.message.first=未知错误\: {0}.
RemoteDebugger.unknown.error.message.second=请联系支持团队以获取更多信息。
RemoteDebugger.enter.passphrase.message=输入密码短语…
RemoteDebugger.enter.passphrase.description.message=SSH 密钥 {0} 的密码短语\:
RemoteDebugger.enter.password.message=输入密码…
RemoteDebugger.enter.password.description.message=用户 {0} 的密码\:
RemoteDebugger.enter.edit.credentials.action.message=编辑凭据…

RiderDataBreakpoint.popup.title.message=数据断点命中
RiderDataBreakpoint.popup.description.message={1} ({2})上的{0}在会话 ''{3}'' 中发生更改。

RiderMarkObjectHandler.failed.to.mark.message=无法标记对象\: {0}

blazor.wasm.debugging=Blazor WASM 调试\:
enable.browser.logs=启用浏览器日志
browser.cli.options=启动浏览器时使用默认命令行实参
# {0} is the localized name of the 'Web Browsers and Preview' settings page
browser.cli.options.help=将默认命令行实参传递给浏览器，忽略 ''{0}'' 设置页面上的选项，为每个新浏览器会话创建唯一的用户数据目录。
enable.browser.logs.help=日志可能会影响浏览器性能，生成额外的窗口并导致各种浏览器特定效果。将 '--enable-logging --v\=1' 开关添加到基于 Chromium 的浏览器。
enable.blazor.wasm.debugging=启用 Blazor WASM 调试
enable.debugging.blazor.wasm.backend=允许调试 Blazor WASM 后端
enable.debugging.every.browser.page=启用调试每个浏览器页面
enable.debugging.every.browser.page.help=在新页面或已打开的页面上自动生成新的调试进程

debugger.exception.breakpoint.default.display.name.message=任何异常
debugger.new.exception.breakpoint.entry.message=添加断点

debugger.pinned.item.favourites.list.name=已在调试器中固定


rider.debug.external.sources.action.name=调试外部源
rider.break.on.user.unhandled.exceptions.action.name=在遇到用户未处理的异常时中断

rider.hide.threads.action.name=隐藏线程
rider.show.threads.action.name=显示线程

rider.core.dump.action.name=调试核心转储…
rider.copy.all.stacks.action.name=复制所有堆栈
rider.copy.all.stacks.progress.message=正在复制堆栈帧…
rider.refresh.stack.frame.action.name=刷新堆栈帧
rider.show.integers.in.hex.action.name=以十六进制显示整数
rider.set.data.breakpoint.action.name=设置数据断点
rider.remove.all.line.breakpoints.action.name=移除所有行断点
rider.stop.on.exception.action.name=出现异常时停止…

rider.external.console.kind.message=选择 ''{0}'' 时，控制台输出不可用
rider.attach.console.kind.message=当调试器附加到正在运行的进程时，控制台输出不可用

rider.more.debugger.settings.message=更多调试器设置…

rider.debug.ImmediateWindowConsoleImpl.add.watch.action.text=添加监视
rider.debug.ImmediateWindowConsoleImpl.add.watch.action.description=在当前表达式上设置监视，如果输入为空，则在最后求值的表达式上设置监视
rider.debug.ImmediateWindowConsoleImpl.stop.on.break.events.text=在断点和异常处停止
rider.debug.ImmediateWindowCollapseExpandAction.collapse.text=收起
rider.debug.ImmediateWindowCollapseExpandAction.expand.text=展开
rider.debug.ImmediateWindowConsoleImpl.file.name=Immediate 窗口

rider.debug.navigate.to.underlying.delegate.fail.notification.text=无法导航到委托方法
rider.debug.navigate.to.link.text=导航

immediate.window.action.evaluate.in.dialog.window.text=在对话框中求值
immediate.window.toolbar.got.it.action.link.text=明白了
# {0} is shortcut
immediate.window.toolbar.got.it.description.message={0} 以在最后一个表达式上设置监视
welcometab.attach=附加到进程

rider.debug.exception.popup.mute.and.resume.message=静默和还原
rider.debug.exception.popup.stop.debugging.message=停止

rider.debug.memory.fetching.is.not.supported.message=不支持内存提取

rider.evaluation.failed.message=无法计算{0}的对象属性
rider.children.evaluation.failed.message=无法计算子节点

rider.debug.critical.error.message=发生严重错误。{0}

rider.debug.failed.conditional.breakpoint.title.text=断点条件错误
# {0} is a technical description of what went wrong
rider.debug.failed.conditional.breakpoint.description.text=无法对条件断点表达式求值。\n错误\: {0}。\n是否要在断点处停止?

rider.remote.debug.unknown.os.and.cpu.message=目标操作系统和 CPU 架构({0})组合不受支持
rider.debug.downloading.debugger.tools.message=正在下载调试器工具…

rider.debug.unsupported.architecture.message=调试尚不支持进程架构 {0}

rider.debug.attach.generated.solution.name=处理 ''{0}''
rider.debug.attach.unknown.runtime.message=未知类型的目标进程运行时\: {0}
notification.group.can't.navigate.to.delegate.method=无法导航到委托方法
notification.group.rider.debug.dump.action=Rider 调试转储操作
notification.group.immediate.window.is.not.supported.for.the.old.debugger.tool.window=旧的调试器工具窗口不支持 Immediate 窗口
notification.group.jit.debugger.updater.host=JIT 调试器更新程序主机
notification.group.jit.debugger.run.configuration=JIT 调试器运行配置
notification.group.rider.remote.debugger.upload.error.upload.error=Rider 远程调试器\: 上传错误
notification.group.debugger.event.log.messages=调试器事件日志消息
notification.group.rider.remote.debugger=Rider 远程调试器

rider.debug.apply.changes.message=应用更改
rider.debug.add.exceptions.message=添加异常

rider.remote.debug.unarchiver.is.missing.message=缺失 {0} 的解档程序

rider.debugger.view.visualizers.formatted=已格式化
rider.debugger.view.visualizers.raw=原始

rider.exception.popup.unhandled.exception.message=未处理的异常
rider.exception.popup.user.unhandled.exception.message=用户未处理的异常
rider.exception.popup.handled.exception.message=已处理的异常
rider.exception.popup.unknown.exception.message=异常

rider.exception.only.break.in.my.code.message=仅在用户代码抛出异常时中断
rider.breakpoint.hit.count.message=命中数\:

rider.breakpoint.less.than.hit.count.mode.message=小于
rider.breakpoint.less.than.or.equal.to.hit.count.mode.message=小于或等于
rider.breakpoint.equal.to.hit.count.mode.message=等于
rider.breakpoint.greater.than.hit.count.mode.message=大于
rider.breakpoint.greater.than.or.equal.to.hit.count.mode.message=大于或等于
rider.breakpoint.multiple.of.hit.count.mode.message=多倍

rider.reattach.looking.for.process.message=正在检测要附加到的进程…

rider.debugger.DFA.title=调试器数据流分析
rider.debugger.DFA.enable.title=启用调试器数据流分析
rider.debugger.DFA.timeout=调试器数据流分析超时

rider.debugger.process.does.not.exist.message=无法附加到 ''{0}'' 进程。确保此进程存在。

rider.debugger.worker.connector.session=内部会话
rider.debugger.worker.connector.dialog.title=连接到调试器工作进程
rider.debugger.worker.connector.dialog.button=连接
# Don't localize
rider.debugger.worker.connector.dialog.frontend.port.row=调试器工作进程端口的前端
# Don't localize
rider.debugger.worker.connector.dialog.backend.port.row=调试器工作进程端口的后端
rider.debugger.worker.connector.dialog.process.id.row=进程 ID
rider.debugger.attach.to.rider.spawned.processes=显示 Rider 生成的进程
RemoteDebugger.progress.text.adding.execution.permissions=添加执行权限