### org/jetbrains/plugins/scala/debugger/ScalaFrameExtraVariablesProvider.scala
debug.process.is.detached=调试进程已分离。

### org/jetbrains/plugins/scala/debugger/breakpoints/ScalaLineBreakpointType.scala
line.breakpoints.tab.title=Scala 行断点
breakpoint.location.constructor.of={0} 的构造函数
breakpoint.location.early.definitions.of={0} 的早期定义
breakpoint.location.line.in.containing.block=包含块中的行
breakpoint.location.line.in.function=函数 {0} 中的行
breakpoint.location.line.in.containing.file=包含文件中的行

### org/jetbrains/plugins/scala/debugger/evaluation/ScalaEvaluatorBuilder.scala
evaluation.of.object.needs.compilation=对象求值需要编译
evaluation.of.class.needs.compilation=类求值需要编译
evaluation.of.trait.needs.compilation=特征求值需要编译
evaluation.of.anonymous.class.needs.compilation=匿名类求值需要编译
evaluation.of.type.alias.needs.compilation=类型别名求值需要编译
evaluation.of.function.definition.needs.compilation=函数定义求值需要编译
evaluation.of.variable.declaration.needs.compilation=变量声明求值需要编译
evaluation.of.lazy.val.definition.needs.compilation=lazy val 定义求值需要编译
evaluation.of.anonymous.function.needs.compilation=匿名函数求值需要编译
evaluation.of.for.expression.needs.compilation=for 表达式求值需要编译
evaluation.of.try.statement.needs.compilation=try 语句求值需要编译
evaluation.of.return.statement.needs.compilation=return 语句求值需要编译
evaluation.of.match.statement.needs.compilation=match 语句求值需要编译
evaluation.of.throw.statement.needs.compilation=throw 语句求值需要编译
evaluation.of.xml.expression.needs.compilation=xml 表达式求值需要编译
evaluation.of.interpolated.string.needs.compilation=插值字符串求值需要编译
cannot.find.by.name.parameter.with.such.name=找不到具有此名称的传名形参\: {0}
evaluation.of.expression.is.not.supported=不支持表达式求值\: {0}
evaluation.of.element.is.not.supported=不支持元素求值\: {0}

### org/jetbrains/plugins/scala/debugger/evaluation/ScalaEvaluatorBuilderUtil.scala
cannot.evaluate.imported.reference=无法对导入的引用求值
cannot.evaluate.local.method=无法对局部方法求值
cannot.evaluate.parameter=无法对形参 {0} 求值
cannot.evaluate.method=无法对方法 {0} 求值
cannot.evaluate.local.object=无法对局部对象 {0} 求值
cannot.evaluate.local.variable=无法对局部变量 {0} 求值
wrong.number.of.arguments=方法 {0} 的实参数量错误
array.instance.is.not.found=无法对方法 {0} 求值\: 找不到数组实例
array.method.not.supported=不支持数组方法
cannot.find.implicit.parameters=找不到要传递的隐式形参
implicit.parameters.from.dependent.objects=依赖对象中的隐式形参不受支持
implicit.conversions.from.dependent.objects=依赖对象中的隐式转换不受支持
method.with.by-name.parameters=无法对包含传名形参的方法求值
wrong.number.of.expressions=无法对实参求值\: 匹配的表达式的数量错误
tupling.not.supported=不支持元组化。请使用元组表达式。
not.used.from.for.statement=无法对 for 语句中的变量 {0} 求值，因为它没有在主体中使用
cannot.find.pattern=找不到 case 子句的模式
cannot.find.expression.of.match=找不到 match 语句的表达式
invalid.case.clause=无效的 case 子句
assignent.without.expression=无法对没有表达式的赋值语句求值
unapply.without.arguments=无法从没有实参的 unapply 提取值
pattern.doesnot.resolves.to.unapply=模式引用 {0} 不会解析为 unapply 或 unapplySeq
pattern.alternatives.cannot.bind.vars=模式替代项不能绑定变量
xml.patterns.not.supported=不支持 xml 模式
kind.of.pattern.not.supported=不支持此类模式\: {0}
anon.classes.not.supported=不支持匿名类
new.expression.without.class.reference=无法对没有类引用的新表达式求值
new.expression.without.constructor.call=无法对没有构造函数调用的表达式求值
new.expression.without.template.parents=无法对没有模板父项的表达式求值
could.not.resolve.constructor=无法解析构造函数
if.statement.without.condition=无法对没有条件的 if 语句求值
if.statement.without.if.branch=无法对没有 if 分支的 if 语句求值
while.statement.without.condition=无法对没有条件的 while 语句求值
while.statement.without.body=无法对没有主体的 while 语句求值
do.statement.without.condition=无法对没有条件的 do 语句求值
do.statement.without.body=无法对没有主体的 do 语句求值
method.call.implicitly.converted.qualifier=无法对包含隐式转换限定符的方法调用求值\: {0}
synchronized.statement.is.not.supported=不支持同步语句
cannot.evaluate.synthetic.method=无法对合成方法求值\: {0}
by.name.parameter.expected=应为传名形参
update.method.is.not.supported=不支持更新方法
variable.definition.needs.right.hand.side=变量定义需要在右侧\: {0}
value.definition.needs.right.hand.side=值定义需要在右侧\: {0}
new.synthetic.instantiation={0} ''{1}'' 为 abstract；无法实例化
missing.type.argument.synthetic.method=在没有显式类型实参的情况下调用了{0}
constructor.param.inaccessible.outside.of.constructor=构造函数形参 ''{0}'' 在类构造函数外部无法访问
array.constructor.unspecified.parameters=未指定的值形参\: _length\: Int
array.constructor.too.many.arguments=构造函数 Array(Int)的实参过多

### org/jetbrains/plugins/scala/debugger/evaluation/ScalaEvaluatorCompileHelper.scala
could.not.compile=无法编译\:\n{0}
compilation.failed=编译失败

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/AsInstanceOfEvaluator.scala
error.cannot.cast.value.to.type=无法将类型 ''{0}'' 的值转换为类型 ''{1}''

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ClassOfEvaluator.scala
error.literal.type.is.not.class.type=文字类型({0}\: {1})不是类类型

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/IsInstanceOfEvaluator.scala
error.type.cannot.be.used.in.isinstanceof={0} {1} 不能在运行时类型测试中使用
error.value.isinstanceof.reference=无法测试类型 {0} 的值是否为类型 {1} 的引用
error.isinstanceof.structural.type=未选中结构类型的运行时类型测试

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/NewValueClassInstanceEvaluator.scala
error.cannot.resolve.value.class.primary.constructor=无法解析值类{0}的主构造函数

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaBoxingEvaluator.scala
cannot.perform.boxing.conversion.for.result=无法为 {0} 执行装箱转换

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaCompilingEvaluator.scala
could.not.compile.generated.class=无法编译生成的类
error.during.generated.code.invocation=生成代码调用时出错\:\n {0}
error.creating.evaluation.class.loader=创建求值类加载器时出错\:\n {0}
error.during.classes.definition=类定义时出错\:\n {0}

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaLiteralEvaluator.scala
unknown.type.of.literal=未知的文字类型
literal.has.null.value=文字 {0} 有 null 值

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaMethodEvaluator.scala
could.not.find.appropriate.constructor.for.name=找不到 {0} 的适用构造函数
cannot.invoke.abstract.interface.method.name=无法调用抽象接口方法 {0}
method.methodname.cannot.be.invoked.on.array=无法在数组上调用方法 {0}

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaThisEvaluator.scala
outer.this.not.available=外部 `this` 不可用

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/compiling/GeneratedClass.scala
module.for.compilation.is.not.found=找不到编译模块
could.not.evaluate.due.to.a.change.in.a.source.file=由于源文件中的更改而无法求值
could.not.compile.local.class.in.this.context=无法在此上下文中编译本地类

### org/jetbrains/plugins/scala/debugger/filters/ScalaDebuggerSettingsConfigurable.form
friendly.collection.display.enabled=在调试器中友好地显示 Scala 集合
dont.show.runtime.refs=不在调试器中显示运行时引用
show.variables.from.outer.scopes.in.variables.view=在变量视图中显示外部作用域中的变量

### org/jetbrains/plugins/scala/debugger/filters/ScalaDebuggerSettingsConfigurable.java
scala.debug.caption=Scala

### org/jetbrains/plugins/scala/debugger/filters/ScalaSteppingConfigurable.form
scala.debug.disable.specific.methods=不单步执行具体的 Scala 类(&I)

### org/jetbrains/plugins/scala/debugger/ui/ScalaClassRenderer.scala
scala.class.renderer=Scala 对象

### org/jetbrains/plugins/scala/debugger/ui/ScalaCollectionRenderer.scala
scala.collection.renderer=Scala 集合

### org/jetbrains/plugins/scala/debugger/ui/ScalaRuntimeRefRenderer.scala
scala.runtime.ref.renderer=Scala 运行时引用

### org/jetbrains/plugins/scala/debugger/ui/descriptors.scala
could.not.find.bitmap.field=找不到位图字段{0}
could.not.find.accessor.method=找不到字段{0}的访问器方法
initialize.lazy.val=初始化
lazy.val.not.initialized=<未初始化>
collection.element.descriptors.evaluation.not.supported="不支持集合元素描述符求值"
