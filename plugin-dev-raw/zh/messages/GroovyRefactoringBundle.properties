Field.cannot.be.final.because.replaced.variable.has.lhs.usages=所選變數用於寫入
access.to.created.field.0.will.be.overridden.by.method.1=對欄位 {0} 的存取將被 {1} 覆寫
all.invocations.and.remove.the.method=內聯所有呼叫並移除方法(&A)
all.invocations.in.project=內聯專案中的所有呼叫(&A)
cannot.find.a.single.definition.to.inline.field=欄位沒有初始設定式
cannot.find.a.single.definition.to.inline.local.var=找不到內聯區域變數的單一定義
cannot.inline.0.=無法內聯{0}
cannot.inline.reference.0=無法內聯參照 ''{0}''
cannot.introduce.field.in.interface=無法在接口中引入欄位
cannot.introduce.field.in.script=作用域內沒有類別
cannot.process.usage.in.language.{0}=無法處理 {0} 中的用法
cannot.rename.property.0=無法重新命名覆寫方法 <bold>''{1}''</bold> 的屬性 <bold>''{0}''</bold>
cannot.rename.script.class.to.0=無法將腳本類別 ''{0}'' 重命名為 ''{1}''
changeSignature.no.type.for.exception=指定異常的類型
changeSignature.not.throwable.type=類型錯誤: 異常的 ''{0}''，應擴展 java.lang.Throwable
changeSignature.wrong.type.for.exception=類型錯誤: 異常的 ''{0}''
class.does.not.exist.in.the.module=模組中不存在類別。是否要建立?
class.language.is.not.groovy=目標類別的語言不是 Groovy
closure.uses.external.variables=閉包使用外部非常數變數
convert.to.java.can.work.only.with.groovy=轉換為 Java 重構僅適用於 Groovy 檔案
convert.to.java.refactoring.name=轉換為 Java
converting.files.to.java=正在將檔案轉換為 Java
converting.files.to.static=正在將檔案轉換為 @CompileStatic
declare.final.checkbox=宣告 final(&F)
error.wrong.caret.position.method.name=文字游標應置於要重構的方法的名稱處。
expression.contains.errors=表達式包含錯誤
extract.method.dialog.explicit.return.checkbox=使用顯式 return 語句(&X)
extract.method.title=提取方法
field.0.is.already.defined=欄位 {0} 已定義
field.cannot.be.initialized.in.constructor(s)=無法在建構函式中初始化欄位
field.cannot.be.initialized.in.field.declaration=無法在宣告中初始化欄位
field.is.not.accessible.form.context.0=不能從呼叫站點存取內聯方法中使用的欄位 {0}
files.to.be.converted=要轉換的檔案
final.field.cant.be.initialized.in.cur.method=無法在當前方法中初始化最終欄位
implicit.getter.will.by.overridden.by.method=屬性 {0} 的隱式 getter 將被方法 {1} 覆寫
implicit.setter.will.by.overridden.by.method=屬性 {0} 的隱式 setter 將被方法 {1} 覆寫
initialize.in.border.title=初始化位置
initialize.in.class.constructor.choice=類別建構函式(&C)
initialize.in.current.method.choice=當前方法(&M)
initialize.in.field.declaration.choice=欄位宣告(&D)
initialize.in.label=初始化位置(&I):
initialize.in.setup.method.choice=setUp 方法
inline.local.variable.prompt.0.1=內聯區域變數 ''{0}''?
inline.method.border.title=內聯
inline.method.label=方法 {0}
inline.method.title=內聯方法
inplace.introduce.constant.move.checkbox=移至另一個類別(&M)
intention.converting.to.static=將轉換應用於 @CompileStatic
intention.converting.to.static.family=轉換為 @CompileStatic
introduce.closure.parameter.elements.header=正在將參數新增到閉包
introduce.constant.class.label=對類別引入(完全限定名稱)(&C):
introduce.variable.title=引入變數
introduced.variable.conflicts.with.parameter.0=引入的變數與參數 {0} 衝突
introduced.variable.conflicts.with.variable.0=引入的變數與區域變數 {0} 衝突
local.variable.is.lvalue=要內聯的變數在賦值中以左值形式出現
method.duplicate=具有簽名 {0} 的方法已在 {1} 中定義
method.is.already.defined.in.class=方法 {0} 已在類別 {1} 中定義。
method.is.already.defined.in.script=方法 {0} 已在腳本 {1} 中定義。
method.is.not.accessible.form.context.0=不能從呼叫站點存取內聯方法中使用的方法 {0}
multiple.output.values=所選程式碼段有多個輸出值
name.is.wrong=名稱 ''{0}'' 不正確
name.label=名稱(&N):
no.occurrences.found=未找到符合項
only.in.groovy.files=此重構僅在 Groovy 檔案中可用
press.escape.to.remove.the.highlighting=按 Esc 移除醒目提示
ref.0.will.not.be.resolved.outside.of.current.context=不會在當前上下文範圍外解析參照 ''{0}''
refactored.method.will.cover.closure.property=重構的方法將覆寫 {1} 中的閉包屬性 ''{0}''
refactoring.cannot.be.applied.no.sources.attached=無法套用重構: 未附加任何源
refactoring.cannot.be.applied.to.abstract.methods=重構不能應用於 abstract 方法
refactoring.cannot.be.applied.to.constructors=重構不能應用於建構函式
refactoring.is.available.only.for.method.calls=重構僅適用於方法呼叫
refactoring.is.not.supported.in.method.parameters=閉包或方法參數中不支持重構
refactoring.is.not.supported.in.parameter.initializers=參數初始設定式中不支持重構
refactoring.is.not.supported.in.the.current.context=當前上下文中不支持重構
refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow=當 return 語句中斷執行流時，不支持重構
reference.to.accessor.0.is.used=無法內聯對存取器 <bold>{0}<bold> 的參照。
remove.parameter.0.no.longer.used=移除不再使用的參數 ''{0}''
rename.groovy.property=重新命名 Groovy 屬性(&G)
rename.is.not.applicable.to.implicit.elements=無法重新命名隱式元素
rename.member=重新命名 {0}
rename.property=重新命名屬性 ''{0}''
replace.all.occurrences.checkbox=取代所有符合項(&A)
replace.getter.for.property=屬性 ''{0}'' 的預設 getter 將被覆蓋
replace.setter.for.property=屬性 ''{0}'' 的預設 setter 將被覆蓋
return.type.is.wrong=返回值類型錯誤
selected.block.contains.invocation.of.another.class.constructor=所選塊包含呼叫另一個類別建構函式
selected.block.should.represent.a.statement.set=所選塊應代表一組語句或表達式
selected.block.should.represent.an.expression=所選塊應該代表一個表達式
selected.expression.has.void.type=所選表達式具有 void 類型
selected.expression.should.not.be.lvalue=所選表達式不應位於賦值的左側
selected.variable.is.used.for.write=所選變數用於寫入
signature.preview.border.title=簽名預覽
specify.default.value=為參數 ''{0}'' 指定預設值或初始設定式
specify.type.label=顯式指定返回值類型(&T)
super.reference.is.used=內聯方法中使用的 super 呼叫在內聯後將無效。
target.class.must.not.be.script=目標類別不得為腳本
there.is.no.method.or.closure=沒有包含方法或閉包
this.invocation.only.and.keep.the.method=僅內聯此呼叫並保留方法(&T)
type.for.parameter.is.incorrect=參數 ''{0}'' 的類型不正確
type.label=類型(&T):
usage.will.be.overridden.by.method=用法 {0} 將被方法 {1} 覆寫
variable.conflicts.with.field.0=所選名稱與欄位 {0} 衝突
variable.conflicts.with.parameter.0=所選名稱與參數 {0} 衝突
variable.conflicts.with.variable.0=所選名稱與區域變數 {0} 衝突
variable.is.accessed.for.writing=變數 ''{0}'' 被存取以進行寫入
visibility.border.title=可見性
visibility.private.choice=私有(&V)
visibility.property.choice=屬性(&R)
visibility.protected.choice=Protected(&O)
visibility.public.choice=public(&B)
you.cannot.pass.as.parameter.0.because.you.remove.1.from.base.method=您無法將 ''{0}'' 作為參數傳遞，因為您從方法中移除了與其關聯的參數 ''{1}''。您應當在參數表中取消選擇“移除不再使用的參數 ''{0}''”或取消選擇參數 ''{1}''。