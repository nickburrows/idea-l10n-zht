abstract.cannot.be.instantiated=''{0}'' 為 abstract；無法實例化
abstract.method.0.cannot.be.accessed.directly.method.reference.context=無法直接存取 abstract 方法 ''{0}''
abstract.method.in.non.abstract.class=非抽象類別中存在 abstract 方法
abstract.methods.cannot.have.a.body=abstract 方法不能有主體
actual.type.argument.contradict.inferred.type=實際類型實參與推斷的類型相矛盾
ambiguous.method.call=方法呼叫不明確: ''{0}'' 和 ''{1}'' 均符合
ambiguous.method.call.no.match=無法解析 ''{1}'' 中的方法 ''{0}''
ambiguous.method.html.tooltip=<html><body><table border=0><tr><td colspan={0}>方法呼叫不明確。<b>{2}</b> 中的 </td></tr><tr>{1}<td>\\&nbsp;和 <b>{4}</b> 中的 </td></tr><tr>{3}<td>\\&nbsp;均符合</td></tr></table></body></html>
ambiguous.reference=對 ''{0}'' 的參照不明確，''{1}'' 和 ''{2}'' 均符合
an.enclosing.instance.of.type.not.in.scope.method.reference.context=作用域中沒有類型 {0} 的封閉實例
annotation.annotation.type.expected=應為註解類型
annotation.cannot.be.local=不允許區域註解
annotation.container.abstract=容器註解 ''{0}'' 沒有包含 ''{1}'' 的預設值
annotation.container.bad.type=無效的容器註解 ''{0}'': ''value'' 方法的類型應為 ''{1}''
annotation.container.low.retention=容器註解 ''{0}'' 的保留長度(''{1}'')比包含的註解短
annotation.container.missed.annotation=容器註解 ''{0}'' 沒有必需的 @{1} 註解
annotation.container.no.value=無效的容器註解 ''{0}'': 未宣告 ''value'' 方法
annotation.container.not.applicable=容器註解 ''@{0}'' 不適用於 {1}
annotation.container.wide.target=容器註解 ''{0}'' 的目標不是此註解目標的子集
annotation.container.wrong.place=容器註解 ''{0}'' 不得與它所包含的元素同時存在
annotation.cyclic.element.type=迴圈註解元素類型
annotation.duplicate.annotation=註解重複
annotation.duplicate.attribute=特性 ''{0}'' 重複
annotation.duplicate.explained=註解重複。{0}
annotation.illegal.array.initializer=''{0}'' 的初始設定式非法
annotation.interface.members.may.not.have.parameters=@interface 成員可能沒有參數
annotation.invalid.annotation.member.type=註解成員的類型 ''{0}'' 無效
annotation.may.not.have.extends.list=@interface 可能沒有 extends 列表
annotation.may.not.have.type.parameters=@interface 可能沒有類型參數
annotation.members.may.not.have.throws.list=@interface 成員可能沒有 throws 列表
annotation.missing.attribute={0} 必要，但缺少
annotation.missing.method=找不到方法 ''{0}''
annotation.non.class.literal.attribute.value=特性值必須為類別文字
annotation.non.constant.attribute.value=特性值必須為常數
annotation.non.enum.constant.attribute.value=特性值必須為枚舉常數
annotation.non.repeatable=''{0}'' 的宣告沒有有效的 java.lang.annotation.Repeatable 註解
annotation.not.allowed.class=類別文字類型可能未進行註解
annotation.not.allowed.here=此處不允許註解
annotation.not.allowed.ref=註解不適用於此類別參照
annotation.not.allowed.static=限定類型的 static 成員可能未註解
annotation.not.allowed.var='var' 類型可能未註解
annotation.not.allowed.void='void' 類型可能未進行註解
annotation.not.applicable=''@{0}'' 不適用於{1}
annotation.on.static.member.qualifying.type.family.name=移動類型註解
annotation.type.permits=不允許為註解類型使用 permits 子句
annotation.unknown.method=無法解析方法 ''{0}''
anonymous.class.implements.interface.cannot.have.qualifier=匿名類別實作接口；new 不能有限定符
anonymous.class.implements.interface.cannot.have.type.arguments=匿名類別實作接口；不能具有類型實參
anonymous.classes.must.not.extend.sealed.classes=匿名類別不得擴展密封類別
array.creation.with.type.arguments=無法建立具有類型實參的陣列
array.initializer.not.allowed=此處不允許陣列初始設定式
array.type.expected=應為陣列類型；實際為 ''{0}''
assert.identifier.warn=自 Java 1.4 起，不支持使用 'assert' 作為關鍵字
assignment.to.final.variable=無法將值賦給 final 變數 ''{0}''
auto.closeable.resource=可自動關閉資源
bad.qualifier.in.super.method.reference.extended=預設 super 呼叫中的類型限定符錯誤: 冗餘接口 {0} 由 {1} 擴展
bad.qualifier.in.super.method.reference.overridden=預設 super 呼叫中的類型限定符錯誤: 方法 {0} 在 {1} 中被覆寫
bad.type.in.switch.expression=switch 表達式中存在錯誤類型: {0} 無法轉換為 {1}
binary.numbers.must.contain.at.least.one.hexadecimal.digit=二進制數值必須至少包含一個二進制數字
binary.operator.not.applicable=運算符 ''{0}'' 不能應用於 ''{1}''、''{2}''
break.outside.switch.expr=不允許 switch 表達式外的 break
break.outside.switch.or.loop=break 位於 switch 或迴圈外部
call.to.super.is.not.allowed.in.enum.constructor=枚舉建構函式中不允許呼叫 super
cannot.access.member.on.type=無法存取成員，因為 ''{0}'' 具有基元類型 {1}
cannot.be.referenced.from.static.context=無法從 static 上下文參照 ''{0}'' 
cannot.call.method.on.type=無法呼叫方法，因為 ''{0}'' 具有基元類型 {1}
cannot.create.array.with.empty.diamond=無法使用 '<>' 建立陣列
cannot.find.class=找不到類別 {0}
cannot.infer.functional.interface.type=無法推斷函式接口類型
cannot.resolve.constructor=無法解析建構函式 ''{0}''
cannot.resolve.method=無法解析方法 ''{0}''
cannot.resolve.package=無法解析軟體套件 {0}
cannot.resolve.symbol=無法解析符號 ''{0}''
cannot.select.dot.class.from.type.variable=無法存取類型參數的類別物件
cannot.select.from.a.type.parameter=無法從類型參數中選擇
cannot.select.from.parameterized.type=無法存取參數化類型的類別物件
case.statement.outside.switch=case 語句位於 switch 外部
catch.without.try='catch' 沒有 'try'
clash.methods.message=''{0}'' 與 ''{1}'' 衝突
clash.methods.message.show.classes=''{2}'' 中的 ''{0}'' 與 ''{3}'' 中的 ''{1}'' 衝突
class.already.imported=已在此編譯單元中定義 ''{0}''
class.cannot.be.inherited.with.different.arguments={0} 不能用不同的實參繼承: {1}
class.cannot.extend.multiple.classes=類別不能擴展多個類別
class.cannot.inherit.from.its.type.parameter=類別無法從其類型參數繼承
class.clashes.with.package=類別 ''{0}'' 與同名的軟體套件衝突
class.expected=此處應為類別名
class.in.default.package=類別 ''{0}'' 位於預設軟體套件中
class.is.already.defined.in.single.static.import=已在單一靜態匯入中定義類別 ''{0}''
class.is.ambiguous.in.single.static.import=類別 ''{0}'' 在單一靜態匯入中不明確
class.is.not.used=類別 ''{0}'' 從未使用
class.member.declared.outside=在類別外部宣告的類別成員
class.must.be.abstract=類別“{0}”必須宣告為抽象，或為實作“{2}”中的抽象方法“{1}”
class.must.implement.method=類別 ''{0}'' 必須在 ''{2}'' 中實作 abstract 方法 ''{1}''
class.name.expected=應為類別名
class.not.allowed.to.extend.sealed.class.from.another.module=不允許類別擴展另一個模組中的密封類別
class.not.allowed.to.extend.sealed.class.from.another.package=不允許類別擴展另一個軟體套件中的密封類別
classes.extends.prohibited.super=類別無法直接擴展 ''{0}''
compact.constructor.in.regular.class=應為參數列表
constant.expression.required=需要常數表達式
constructor.call.must.be.first.statement=''{0}'' 呼叫必須是建構函式主體中的第一條語句
constructor.is.not.used=建構函式 ''{0}'' 從未使用
continue.outside.loop=continue 位於迴圈外部
continue.outside.switch.expr=continue 位於封閉 switch 表達式外部
create.class.action.this.not.valid.java.qualified.name=這不是有效的 Java 限定名稱
cyclic.inheritance=涉及 ''{0}'' 的迴圈繼承
declaration.not.allowed=此處不允許宣告
declaration.or.variable.expected=應為宣告、final 或 effectively final 變數
deconstruction.pattern.requires.record=解構模式只能應用於記錄，''{0}'' 不是記錄
default.label.must.not.contains.case.keyword=預設 case 的標籤只能使用 'default' 關鍵字，不能使用 'case'
default.label.not.allowed.here=此處不允許使用預設標籤: 'default' 只能用作單個 case 標籤或僅與 'null' 配對
default.method.overrides.object.member=預設方法 ''{0}'' 覆寫 ''java.lang.Object'' 的成員
deprecated.default.constructor=''{0}'' 中的預設建構函式已棄用
deprecated.symbol=''{0}'' 已棄用
different.case.kinds.in.switch=switch 中使用了不同的 case 種類
direct.abstract.method.access=無法直接存取 abstract 方法 ''{0}''
dot.expected.after.super.or.this=應為 '.'
duplicate.class=重複的類別: ''{0}''
duplicate.class.in.other.file=在檔案 ''{0}'' 中找到重複類別
duplicate.default.switch.label=預設標籤重複
duplicate.label=標籤 ''{0}'' 已在使用中
duplicate.method=已在 ''{1}'' 中定義 ''{0}''
duplicate.switch.label=標籤 ''{0}'' 重複
duplicate.unconditional.pattern.label=重複的無條件模式
else.without.if='else' 沒有 'if'
empty.character.literal=空字元文字
enum.constant.must.implement.method=枚舉常數 ''{0}'' 必須在 ''{2}'' 中實作 abstract 方法 ''{1}''
enum.identifier.warn=自 Java 1.5 起，不支持使用 'enum' 作為關鍵字
enum.is.not.used=枚舉 ''{0}'' 從未使用
enum.types.cannot.be.instantiated=無法實例化枚舉類型
error.cannot.infer.pattern.type=無法推斷模式類型: {0}
error.cannot.resolve.class=無法解析類別 ''{0}''
error.cannot.resolve.class.or.package=無法解析類別或軟體套件 ''{0}''
error.interface.member.clashes=@interface 成員與 {1} 中的 ''{0}'' 衝突
error.raw.deconstruction=不允許使用原始解構模式
exception.already.caught=已捕捉到異常 ''{0}''
exception.already.caught.warn=無法存取的部分: {1, choice, 0#異常|2#異常} ''{0}'' {1, choice, 0已被#|2#已被}捕獲 
exception.is.never.thrown=此方法中從未拋出異常 ''{0}''
exception.must.be.disjoint=多 catch 中的類型必須不相交: ''{0}'' 是 ''{1}'' 的子類別
exception.never.thrown.try=相應的 try 塊中從未拋出異常 ''{0}''
expected.boolean.expression=應為布爾表達式
expected.catch.or.finally=應為 'catch' 或 'finally'
expected.class.or.package=應為類別或軟體套件
expected.comma=應為 ','
expected.expression=應為表達式
expected.identifier=應為關鍵字
expected.identifier.or.type=應為關鍵字或類型
expected.lbrace=應為 '{'
expected.lparen=應為 '('
expected.lparen.or.lbracket=應為 '(' 或 '['
expected.parameter=應為參數
expected.rbrace=應為 '}'
expected.rbracket=應為 ']'
expected.rparen=應為 ')'
expected.semicolon=應為 ';'
expected.statement=應為語句
expected.switch.label=應為 'case'、'default' 或 '}'
expected.switch.rule=應為表達式、塊或 throw 語句
expected.while=應為 'while'
expression.expected=應為表達式
extends.after.enum=不允許對枚舉使用 extends 子句
extension.method.in.class=擴展方法只能在接口中使用
extension.method.should.have.a.body=擴展方法應有主體
field.is.already.defined.in.single.static.import=已在單一靜態匯入中定義欄位 ''{0}''
field.is.ambiguous.in.single.static.import=欄位 ''{0}'' 在單一靜態匯入中不明確
field.is.not.used=欄位 ''{0}'' 從未使用
field.is.not.used.for.reading={0} 欄位 ''{1}'' 已被分配，從未被存取
final.method.override=''{0}'' 無法覆寫 ''{2}'' 中的 ''{1}''；覆寫的方法為 final
finally.without.try='finally' 沒有 'try'
floating.point.number.too.large=浮點數過大
floating.point.number.too.small=浮點數過小
foreach.not.applicable=Foreach 不適用於類型 ''{0}''
formal.varargs.element.type.inaccessible.here=無法在此處存取正式的 vararg 元素類型 {0}
functional.interface.must.not.be.sealed.error.description=函式接口不能宣告為 ''{0}''
generic.array.creation=建立泛型陣列
generic.extend.exception=泛型類別不能擴展 'java.lang.Throwable'
generics.annotation.members.may.not.have.type.parameters=@interface 成員可能沒有類型參數
generics.cannot.be.inherited.as.raw.and.generic=''{0}'' 不能作為原始類型和包含泛型類型實參 ''{1}'' 來繼承
generics.cannot.be.inherited.with.different.type.arguments=''{0}'' 不能使用不同的類型實參繼承: ''{1}'' 和 ''{2}''
generics.cannot.catch.type.parameters=無法捕獲類型參數
generics.cannot.instanceof.type.parameters=應為類別或陣列
generics.diamond.not.applicable=菱形運算符不適用於非參數化類型
generics.duplicate.type.parameter=重複的類型參數: ''{0}''
generics.enum.may.not.have.type.parameters=枚舉可能沒有類型參數
generics.holder.method=方法
generics.holder.type=類型
generics.inferred.type.for.type.parameter.is.not.within.its.bound.extend=類型參數 ''{0}'' 的推斷類型 ''{2}'' 不在其界限內；應擴展 ''{1}''
generics.inferred.type.for.type.parameter.is.not.within.its.bound.implement=類型參數 ''{0}'' 的推斷類型 ''{2}'' 不在其界限內；應實作 ''{1}''
generics.methods.have.same.erasure={0}；兩個方法具有相同的擦除
generics.methods.have.same.erasure.hide={0}；兩個方法具有相同的擦除，但都沒有隱藏另一個
generics.methods.have.same.erasure.override={0}；兩個方法具有相同的擦除，但都沒有覆寫另一個
generics.reference.parameters.not.allowed=此處不允許參照參數
generics.select.static.class.from.parameterized.type=此處不允許類型實參，因為類別 ''{0}'' 為 static
generics.type.argument.cannot.be.of.primitive.type=類型實參不能為基元類型
generics.type.arguments.on.raw.method=在原始方法上提供類型實參
generics.type.arguments.on.raw.type=在原始類型上提供類型實參
generics.type.or.method.does.not.have.type.parameters={0} ''{1}'' 沒有類型參數
generics.type.parameter.cannot.be.instantiated=類型參數 ''{0}'' 不能直接實例化
generics.type.parameter.is.not.within.its.bound.extend=類型參數 ''{0}'' 不在其界限內；應擴展 ''{1}''
generics.type.parameter.is.not.within.its.bound.implement=類型參數 ''{0}'' 不在其界限內；應實作 ''{1}''
generics.unchecked.assignment=未檢查的賦值: ''{0}'' 賦值給 ''{1}''
generics.unchecked.call=未檢查的方法 ''{0}'' 呼叫
generics.unchecked.call.to.member.of.raw.type=作為原始類型 ''{1}'' 的成員對 ''{0}'' 的未檢查的呼叫
generics.unchecked.cast=未檢查的轉換: ''{0}'' 轉換為 ''{1}''
generics.wildcard.not.expected=應為非萬用字元
generics.wildcards.may.be.used.only.as.reference.parameters=萬用字元只能用作參照參數
generics.wrong.number.of.type.arguments=類型實參的數量錯誤: {0}；要求 {1} 個
guarded.pattern.variable.must.be.final=受保護模式中使用的變數應當為 final 或有效 final
guarded.patterns.unavailable=JEP 406 中的受保護模式自 Java 19 預覽版開始不可用
hexadecimal.numbers.must.contain.at.least.one.hexadecimal.digit=十六進制數值必須至少包含一個十六進制數字
identifier.is.not.allowed.here=此處不允許使用關鍵字
illegal.escape.character.in.character.literal=字串文字中有非法轉義字元
illegal.escape.character.in.string.literal=字串文字中的非法轉義字元
illegal.forward.reference=非法前向參照
illegal.generic.type.for.instanceof=instanceof 的泛型類型非法
illegal.initializer=''{0}'' 的初始設定式非法
illegal.line.end.in.string.literal=字元文字中的行尾非法
illegal.self.reference=非法自參照
illegal.to.access.static.member.from.enum.constructor.or.instance.initializer=從枚舉建構函式或實例初始設定式存取 static 成員 ''{0}'' 是非法的
illegal.type.void=非法類型: 'void'
illegal.underscore=下劃線非法
illegal.unicode.escape=非法 Unicode 轉義序列
implements.after.interface=不允許對接口使用 implements 子句
inaccessible.type=類別 ''{0}'' 在此處無法存取
incompatible.modifiers=非法的修飾符組合: ''{0}'' 和''{1}''
incompatible.parameter.types.in.lambda=lambda 表達式中的參數類型不相容: 應為 {0}，但找到的是 {1}
incompatible.parameter.types.in.lambda.wrong.number.of.parameters=lambda 表達式中的參數類型不相容: 參數的數量錯誤: 應為 {0} 個，但發現了 {1} 個
incompatible.return.type=嘗試使用不相容的返回值類型
incompatible.switch.null.type=''{0}'' 無法轉換為 ''{1}''
incompatible.types=不相容的類型。實際為 {1}''，需要 ''{0}''
incompatible.types.html.tooltip=<html><body><table><tr><td style=''padding: 0px 16px 8px 4px;color: {5}''>需要的類型: </td><td style=''padding: 0px 4px 8px 0px;''>{0}</td>{1}</tr><tr><td style=''padding: 0px 16px 0px 4px;color: {5}''>提供的類型: </td><td style=''padding: 0px 4px 0px 0px;''>{2}</td>{3}</tr></table>{4}</body></html>
incompatible.types.reason.ambiguous.method.reference=<br/>原因: 方法參照不明確: ''{0}'' 和 ''{1}'' 均符合
inconvertible.type.cast=不可轉換的類型；無法將 ''{0}'' 轉換為 ''{1}''
incorrect.number.of.nested.patterns=嵌套模式的數量不正確: 應為 {0}，但實際為 {1}
inheritance.from.final.class=無法從{1} ''{0}'' 繼承
initializer.must.be.able.to.complete.normally=初始設定式必須能夠正常完成
instance.method.cannot.override.static.method=''{1}'' 中的實例方法 ''{0}'' 無法覆寫 ''{3}'' 中的 static 方法 ''{2}''
instanceof.pattern.equals=模式類型 ''{0}'' 與表達式類型相同
instanceof.pattern.supertype=模式類型 ''{0}'' 是表達式類型 ''{1}'' 的父類型
insufficient.language.level=語言級別 ''{1}'' 不支持 {0}
integer.number.too.large=整數過大
interface.expected=此處應為接口
interface.is.not.used=接口 ''{0}'' 從未使用
interface.methods.cannot.have.body=接口 abstract 方法不能有主體
invalid.case.label.combination.constants.and.patterns=無效的 case 標籤組合: 一個 case 標籤必須包含 case 常數列表或單個 case 模式
invalid.case.label.combination.several.patterns=無效的 case 標籤組合: 一個 case 標籤不得包含一個以上的 case 模式
invalid.default.and.null.order=無效的 case 標籤順序: 'null' 必須是第一個，'default' 必須是第二個
invalid.package.annotation.containing.file=軟體套件註解應位於檔案 package-info.java 中
invalid.permits.clause=無效的 permits 子句: 必須密封 ''{0}''
invalid.permits.clause.direct.implementation=無效的許可條款: ''{0}'' 必須直接{1, choice, 1#擴展|2#實作} ''{2}''
invalid.qualified.new=限定 new 無效
invalid.statement=語句無效
is.not.an.enclosing.class=''{0}'' 不是封閉類別
label.without.statement=無語句的標籤
lambda.expression.not.expected=不應在此處使用 lambda 表達式
lambda.parameters.consistency.message=不能在 lambda 表達式中將 'var' 和顯式類型參數混合
lambda.variable.must.be.final=lambda 表達式中使用的變數應為 final 或有效 final
local.class.is.not.used=本地類別 ''{0}'' 從未使用
local.classes.must.not.extend.sealed.classes=區域類別不得擴展密封類別
local.variable.is.never.used=''{0}'' 從未使用變數
local.variable.is.not.assigned=變數 ''{0}'' 從未被賦值
local.variable.is.not.used.for.reading=''{0}'' 已被賦值，從未被存取
long.number.too.large=長整數過大
lvti.array=不允許將 'var' 作為陣列的元素類型
lvti.compound=複合宣告中不允許 'var'
lvti.lambda=無法推斷類型: lambda 表達式需要顯式目標類型
lvti.method.ref=無法推斷類型: 方法參照需要顯式目標類型
lvti.no.initializer=無法推斷類型: 'var' 位於沒有初始設定式的變數上
lvti.null=無法推斷類型: 變數初始設定式為 'null'
lvti.selfReferenced=無法推斷 ''{0}'' 的類型，它用於其自己的變數初始設定式中
lvti.void=無法推斷類型: 變數初始設定式為 'void'
malformed.floating.point.literal=浮點文字格式不正確
marked.for.removal.default.constructor=''{0}'' 中的預設建構函式已棄用並被標記為移除
marked.for.removal.symbol=''{0}'' 已棄用並被標記為移除
member.referenced.before.constructor.called=在呼叫父類型建構函式之前無法參照 ''{0}''
method.call.expected=應為方法呼叫
method.does.not.override.super=方法未從其超類別覆寫方法
method.is.not.used=方法 ''{0}'' 從未使用
method.reference.expression.is.not.expected=不應在此處使用方法參照表達式
missing.method.body=缺少方法體，或宣告為 abstract
missing.package.statement=缺少 package 語句: ''{0}''
missing.package.statement.package.name.invalid=缺少軟體套件語句，但與檔案路徑相對應的軟體套件名稱 ''{0}'' 無效
missing.return.statement=缺少 return 語句
missing.return.type=方法宣告無效；需要返回值類型
missing.return.value=缺少返回值
modifier.not.allowed=此處不允許使用修飾符 ''{0}''
modifiers.for.enum.constants=不允許對枚舉常數使用修飾符
module.access.bad.name=軟體套件 ''{0}'' 在具有無效名稱(''{1}'')的模組中宣告
module.access.does.not.read=軟體套件 ''{0}'' 在模組 ''{1}'' 中宣告，但模組 ''{2}'' 沒有讀取它
module.access.from.named=軟體套件 ''{0}'' 在模組 ''{1}'' 中宣告，但後者沒有將它匯出到模組 ''{2}''
module.access.from.unnamed=軟體套件 ''{0}'' 在模組 ''{1}'' 中宣告，但後者沒有將它匯出到未命名模組
module.access.not.in.graph=軟體套件 ''{0}'' 在模組 ''{1}'' 中宣告，但後者不在模組圖中
module.access.to.unnamed=軟體套件 ''{0}'' 在未命名的模組中宣告，但模組 ''{1}'' 沒有讀取它
module.ambiguous=不明確的模組參照: {0}
module.conflicting.packages=軟體套件 ''{0}'' 存在於另一個模組中: {1}
module.conflicting.reads=模組 ''{0}'' 同時從 ''{2}'' 和 ''{3}'' 讀取軟體套件 ''{1}''
module.cyclic.dependence=迴圈相依關係: {0}
module.duplicate.exports=重複的 ''exports'': {0}
module.duplicate.exports.target=重複的 ''exports'' 目標: {0}
module.duplicate.impl=重複的實作: {0}
module.duplicate.opens=重複的 ''opens'': {0}
module.duplicate.opens.target=重複的 ''opens'' 目標: {0}
module.duplicate.provides=重複的 ''provides'': {0}
module.duplicate.requires=重複的 ''requires'': {0}
module.duplicate.uses=重複的 ''uses'': {0}
module.file.duplicate=模組中已存在 'module-info.java'
module.file.wrong.location=模組宣告應位於模組的來源根中
module.file.wrong.name=模組宣告應位於名為 'module-info.java' 的檔案中
module.no.package=模組檔案不應具有 'package' 語句
module.not.found=找不到模組: {0}
module.not.on.path=模組不在相依項中: {0}
module.open.duplicate.text=轉到重複項
module.opens.in.weak.module=開啟的模組中不允許 'opens'
module.service.abstract=該服務實作是抽象類別: {0}
module.service.alien=服務實現必須在 provides 指令所在的同一模組中定義
module.service.enum=服務定義為枚舉: {0}
module.service.impl=服務實作類型必須為服務接口類型的子類型，或者具有 public static 無實參 'provider' 方法
module.service.inner=服務實現為內部類別: {0}
module.service.no.ctor=服務實作沒有 public 預設建構函式: {0}
module.service.provider.type=''provider'' 方法返回值類型必須是服務接口類型的子類型: {0}
module.service.unused=提供了服務接口，但未匯出或使用
module.unwanted.modifier.warn=自 Java 10 起，禁止對 'requires java.base' 使用修飾符
multiple.non.overriding.abstract.methods.found.in.0=在 {0} 中找到多個非覆寫 abstract 方法
multiple.non.overriding.abstract.methods.found.in.interface.0=在接口 {0} 中找到多個非覆寫 abstract 方法
multiple.switch.labels=在標記為 switch 的語句組中，只有在沒有宣告任何模式變數的情況下，才允許為該語句組指定多個 switch 標籤
native.methods.cannot.have.a.body=原生方法不能有主體
no.default.constructor.available=''{0}'' 中沒有可用的預設建構函式。
no.enclosing.instance.in.scope=作用域中沒有類型 ''{0}'' 的封閉實例
no.interface.expected=此處不應為接口
no.target.method.found=未找到目標方法
non.static.method.cannot.be.referenced.from.a.static.context.method.reference.context=無法從 static 上下文參照非 static 方法
non.static.symbol.referenced.from.static.context=無法從 static 上下文參照非 static {0} ''{1}'' 
not.a.functional.interface={0} 不是函式接口
not.a.statement=不是語句
not.allowed.in.interface=在接口中不允許
not.allowed.in.sealed.hierarchy=sealed 層次結構中不允許使用 ''{0}''
not.inner.class=''{0}'' 不是內部類別
not.loop.label=不是迴圈標籤: ''{0}''
null.label.not.allowed.here=無效的 case 標籤組合: 'null' 只能用作單個 case 標籤或僅與 'default' 配對
numeric.overflow.in.expression=表達式中出現數值溢出
overridden.method.does.not.throw={0}；覆寫的方法未拋出 ''{1}''
override.not.allowed.in.interfaces=實作接口方法時不允許 @Override
overrides.deprecated.method=覆寫 ''{0}'' 中棄用的方法
overrides.marked.for.removal.method=覆寫 ''{0}'' 中棄用並標記為移除的方法
package.clashes.with.class=軟體套件 ''{0}'' 與同名的類別衝突
package.is.empty=軟體套件為空: {0}
package.local.symbol=''{0}'' 在 ''{1}'' 中不為 public。無法從外部軟體套件存取
package.name.file.path.mismatch=軟體套件名稱 ''{0}'' 與檔案路徑 ''{1}'' 不對應
package.not.found=找不到軟體套件: {0}
parameter.excluding.hierarchy.disable.text=不醒目提示繼承方法的參數
parameter.is.not.used=參數 ''{0}'' 從未使用
parameterized.qualifier.on.static.method.reference.context=static 方法參照上的參數化限定符
pattern.is.not.exhaustive=模式 ''{0}'' 在 ''{1}'' 上不詳盡
pattern.variable.is.not.used=模式變數 ''{0}'' 從未使用
permit.list.must.contain.outside.inheritors=密封類別 permit 子句必須包含所有子類別
permits.after.enum=枚舉不允許 permits 子句
permits.list.generics.are.not.allowed=允許列表中不支持泛型
permitted.subclass.must.have.modifier=所有 sealed 類別的子類別必須為 fianl、sealed 或 non-sealed 類型
private.constructor.is.not.used=private 建構函式 ''{0}'' 從未使用
private.field.is.not.assigned=private 欄位 ''{0}'' 從未分配
private.field.is.not.used=private 欄位 ''{0}'' 從未使用
private.inner.class.is.not.used=private 內部類別 ''{0}'' 從未使用
private.inner.interface.is.not.used=private 內部接口 ''{0}'' 從未使用
private.method.is.not.used=private 方法 ''{0}'' 從未使用
private.methods.in.interfaces.should.have.body=接口中的 private 方法應具有主體
private.symbol=''{0}'' 在 ''{1}'' 中具有 private 存取權限
protected.symbol=''{0}'' 在 ''{1}'' 中具有 protected 存取權限
public.class.should.be.named.after.file=類別 ''{0}'' 為 public，應在檔案 ''{0}.java'' 中宣告
qualified.class.reference.not.allowed.in.qualified.new=限定 new 中不允許使用限定類別參照
qualified.enum.constant.in.switch=枚舉 switch case 標籤必須是枚舉常數的非限定名稱
qualified.enum.constant.in.switch.remove.fix=移除限定符
qualified.new.of.static.class=限定新增 static 類別
qualifier.must.be.expression=限定符必須是表達式
receiver.name.mismatch=接收器名稱不符合封閉類別類型
receiver.static.context=接收器不能在 static 上下文中使用
receiver.type.mismatch=接收器類型不符合封閉類別類型
receiver.wrong.context=不允許接收器超出方法參數列表
receiver.wrong.position=接收器應為第一個參數
record.accessor=記錄組件存取器
record.accessor.wrong.return.type=組件存取器返回值類型不正確。應為 ''{0}''，實際為 ''{1}''
record.canonical.constructor=規範建構函式
record.canonical.constructor.wrong.parameter.name=規範建構函式參數名稱必須符合記錄組件名稱。應為 ''{0}''，實際為 ''{1}''
record.canonical.constructor.wrong.parameter.type=記錄組件 ''{0}'' 的參數類型不正確。應為 ''{1}''，實際為 ''{2}''
record.compact.constructor=緊湊建構函式
record.compact.constructor.return=緊湊建構函式中不允許 'return' 語句
record.component.cstyle.declaration=記錄組件中不允許 C 樣式的陣列宣告
record.component.not.initialized=記錄組件 ''{0}'' 可能無法在規範建構函式中初始化
record.component.restricted.name=記錄組件名稱 ''{0}'' 非法
record.component.vararg.not.last=Vararg 記錄組件必須為列表中的最後一項
record.constructor.call.in.canonical=規範建構函式不能委託給其他建構函式
record.extends=不允許對記錄使用 extends 子句
record.header.regular.class=為非記錄宣告了記錄標頭
record.instance.field=記錄中不允許實例欄位
record.instance.initializer=記錄中不允許實例初始設定式
record.no.constructor.call.in.non.canonical=非規範記錄建構函式必須委託給其他建構函式
record.no.header=記錄沒有宣告標頭
record.permits=記錄不允許 permits 子句
record.special.method.non.public={0} 必須為 ''public''
record.special.method.stronger.access={0} 存取級別的限制不能超過記錄存取級別(''{1}'')
record.special.method.throws={0} 無法宣告拋出的異常
record.special.method.type.parameters={0} 不能有類型參數
recursive.constructor.invocation=遞迴建構函式呼叫
repeated.annotation.target=重複的註解目標
repeated.interface=重複的接口
resource.variable.must.be.final=用作 try-with-resources 資源的變數應為 final 或有效 final
restricted.identifier=''{0}'' 是受限關鍵字，不能用於類型宣告
restricted.identifier.reference=非法參照受限類型 ''{0}''
restricted.identifier.warn=自 Java {1} 起的版本中不支持使用 ''{0}'' 作為類別名
return.from.void.method=無法從結果類型為 void 的方法返回值
return.outside.method=return 位於方法外部
return.outside.switch.expr=return 位於封閉 switch 表達式外部
safevararg.annotation.cannot.be.applied.for.record.component=記錄組件上不允許 @SafeVarargs
safevarargs.not.allowed.non.final.instance.methods=非 final 實例方法中不允許 @SafeVarargs
safevarargs.not.allowed.on.methods.with.fixed.arity=具有固定元數的方法不允許使用 @SafeVarargs
safevarargs.not.applicable.for.reifiable.types=@SafeVarargs 不適用於可具體化的類型
safevarargs.not.suppress.potentially.unsafe.operations=@SafeVarargs 不禁止潛在的不安全動作
sealed.cannot.be.functional.interface=密封類別不能用作函式接口
sealed.must.have.inheritors=密封類別必須有子類別
sealed.type.inheritor.expected.modifiers=應為 {0}、{1} 或 {2} 修飾符
single.import.class.conflict=已在單類型匯入中定義 ''{0}''
statement.must.be.prepended.with.case.label=必須在語句前面預置 case 標籤
static.interface.method.call.qualifier=只能在包含接口類別時呼叫 static 方法
static.member.accessed.via.instance.reference=通過實例參照存取 static 成員 ''{0}.{1}''
static.method.cannot.be.annotated.with.override=Static 方法不能用 @Override 註解
static.method.cannot.override.instance.method=''{1}'' 中的 static 方法 ''{0}'' 無法覆寫 ''{3}'' 中的實例方法 ''{2}''
static.method.referenced.through.non.static.qualifier.method.reference.context=通過非 static 限定符參照 static 方法
static.method.referenced.through.receiver.method.reference.context=通過接收器參照 static 方法
static.methods.in.interfaces.should.have.body=接口中的 static 方法應具有主體
suspicious.name.assignment=''{0}'' 可能不應分配給 ''{1}''
suspicious.name.parameter=''{0}'' 可能不應作為參數 ''{1}'' 傳遞
suspicious.name.return=''{0}'' 可能不應從方法 ''{1}'' 返回
switch.class.or.array.type.expected=類別或陣列
switch.constant.expression.required=常數表達式、模式或 null 為必需項
switch.dominance.of.preceding.label=標籤由先前的 case 標籤 ''{0}'' 支配
switch.expr.empty='switch' 表達式沒有任何 case 子句
switch.expr.incomplete='switch' 表達式未涵蓋所有可能的輸入值
switch.expr.no.result=Switch 表達式沒有任何結果表達式
switch.expr.rule.should.produce.result=switch 表達式規則應在所有執行路徑中產生結果
switch.expr.should.produce.result=switch 表達式應在所有執行路徑中產生結果
switch.expression.cannot.be.void=switch 表達式的目標類型不能為 void
switch.illegal.fall.through.from=從模式的非法直落
switch.illegal.fall.through.to=到模式的非法直落
switch.invalid.selector.types=不支持 ''{0}'' 的選擇器類型
switch.statement.empty='switch' 語句沒有任何 case 子句
switch.statement.incomplete='switch' 語句未涵蓋所有可能的輸入值
switch.unconditional.pattern.and.default.exist='switch' 同時具有無條件模式和預設標籤
target.method.is.generic=目標方法為泛型
target.type.of.a.lambda.conversion.must.be.an.interface=lambda 轉換的目標類型必須是接口
text.block.new.line=非法的文本塊起始: 左引號後缺少新行
text.block.unclosed=文本塊未閉合
text.class.cannot.access=無法存取 {0}
text.class.inherits.abstract.and.default={0} 從類型 {2} 和 {3} 繼承 {1} 的抽象和預設值
text.class.inherits.unrelated.defaults={0} 從類型 {2} 繼承 {1} 的不相關預設值
text.class.is.not.accessible={0} 在當前上下文中不可存取
text.improper.formed.type=成型類型不正確；部分類型參數丟失
too.many.array.dimensions=陣列維度過多
too.many.characters.in.character.literal=字元文字中的字元數過多
two.methods.are.inherited.with.same.signature={1} 中的方法 {0} 和 {3} 中的方法 {2} 使用相同的簽名繼承
type.parameter.cannot.be.followed.by.other.bounds=類型參數後面不能跟隨其他邊界
type.parameter.has.incompatible.upper.bounds=類型參數 {0} 的上限不相容: {1}
type.parameter.is.not.used=類型參數 ''{0}'' 從未使用
type.pattern.expected=應為類型模式
unary.operator.not.applicable=運算符 ''{0}'' 不能應用於 ''{1}''
unchecked.overriding.incompatible.return.type=未檢查的覆寫: 返回值類型需要未經檢查的轉換。實際為 ''{0}''，需要 ''{1}''
unclosed.char.literal=字元文字未閉合
unclosed.comment=未閉合註釋
underscore.identifier.error=從 Java 9 起，'_' 是關鍵字，不能用作關鍵字
underscore.identifier.warn=自 Java 9 起，不支持使用 '_' 作為關鍵字
underscore.lambda.identifier=不允許使用 '_' 作為 lambda 參數名稱
unexpected.token=意外的標記
unexpected.type=意外類型。實際為 ''{1}'' ，需要 ''{0}''
unexpected.type.class.expected=意外的類型: 應為類別
unhandled.close.exceptions={2} 中有未處理的{1, choice, 0#異常|2#異常}: {0}
unhandled.exceptions=未處理 {1, choice, 0#異常|2#異常}: {0}
unknown.class=未知類別: ''{0}''
unqualified.super.disallowed=擴展方法中不允許非限定 super 參照
unreachable.statement=不可到達的語句
unreachable.statement.false.condition=迴圈條件始終為 false，使循環體不可到達
unrelated.overriding.methods.return.types=方法有不相關的返回值類型
unresolved.label=未定義的標籤: ''{0}''
unsafe.cast.in.instanceof=''{0}'' 無法安全轉換為 ''{1}''
valid.switch.17.selector.types=char、byte、short、int、Character、Byte、Short、Integer、String 或枚舉
valid.switch.selector.types=byte、char、short 或 int
vararg.cstyle.array.declaration=vararg 參數中不允許 C 樣式的陣列宣告
vararg.not.last.parameter=Vararg 參數必須為列表中的最後一個參數
variable.already.assigned=變數 ''{0}'' 可能尚未被賦值
variable.already.defined=作用域中已定義變數 ''{0}''
variable.assigned.in.loop=變數 ''{0}'' 可能在迴圈中賦值
variable.expected=應為變數
variable.must.be.final=變數 ''{0}'' 從內部類別中存取，需要宣告為 final
variable.must.be.final.or.effectively.final=變數 ''{0}'' 從內部類別中存取，需要為 final 或有效 final
variable.not.initialized=變數 ''{0}'' 可能尚未初始化
visibility.access.problem=無法存取 ''{1}'' 中的 ''{0}''
visibility.module.access.problem=對 ''{1}'' 中 ''{0}'' 的存取被 {2} 阻止
void.type.is.not.allowed=此處不允許 'void' 類型
weaker.privileges={0}；嘗試分配較弱的存取權限(''{1}'')；曾為 ''{2}''
when.expression.is.false=此 case 標籤有一個 guard，它是一個值為 'false' 的常數表達式
wildcard.type.cannot.be.instantiated=萬用字元類型 ''{0}'' 不能直接實例化
wrong.constructor.arguments=''{0}'' 無法應用於 ''{1}''
wrong.method.arguments=''{1}'' 中的 ''{0}'' 無法應用於 ''{2}''
yield.unexpected=yield 位於 switch 表達式外部
yield.unqualified.method.warn=自 Java 14 起的版本中不支持對 'yield' 方法進行非限定呼叫
yield.void=表達式類型不應為 'void'