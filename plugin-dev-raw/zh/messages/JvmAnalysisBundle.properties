assertequals.between.inconvertible.types.display.name='assertEquals()' 位於不可轉換類型的物件之間
can.t.build.uast.tree.for.file=無法為檔案建置 UAST 樹
current.version=當前版本:
dialog.title.choose.annotation=選擇 {0}
inspection.message.illegal.dependency.module.doesn.t.export=非法相依: 模組 ''{0}'' 不匯出軟體套件 ''{1}''
jvm.inspection.logging.condition.disagrees.with.log.statement.display.name=日誌條件與日誌記錄呼叫不符合
jvm.inspection.logging.condition.disagrees.with.log.statement.problem.descriptor=條件 ''{0}'' 的級別與日誌記錄呼叫 ''{1}'' 的級別不符合
jvm.inspection.logging.placeholder.count.matches.argument.count.display.name=佔位符數量與日誌呼叫中的實參數量不符合
jvm.inspection.logging.placeholder.count.matches.argument.count.fewer.problem.descriptor=提供的實參數量({0})少於指定的佔位符數({1}) #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.fewer.problem.partial.descriptor=提供的實參量({0})少於指定的佔位符數(至少 {1}) #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.incorrect.problem.descriptor=非法格式字串指定符 #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.more.problem.descriptor=提供的實參數量({0})多於指定的佔位符({1}) #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option=SLF4J 將 Log4j 2 用作實作
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.auto=自動檢查
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.no=否
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.yes=是
jvm.inspection.logging.string.template.as.argument.all.levels.option=所有日誌級別
jvm.inspection.logging.string.template.as.argument.debug.level.and.lower.option=偵錯級別和更低
jvm.inspection.logging.string.template.as.argument.display.name=字串模板作為日誌記錄呼叫的實參
jvm.inspection.logging.string.template.as.argument.info.level.and.lower.option=資訊級別和更低
jvm.inspection.logging.string.template.as.argument.problem.descriptor=作為 <code>#ref()</code> 日誌記錄呼叫實參的字串模板 #loc
jvm.inspection.logging.string.template.as.argument.quickfix.name=取代為佔位符
jvm.inspection.logging.string.template.as.argument.skip.on.primitives=僅包含具有基元類型的表達式、其包裝器或字串時不發出警告
jvm.inspection.logging.string.template.as.argument.trace.level.option=追蹤級別
jvm.inspection.logging.string.template.as.argument.warn.level.and.lower.option=警告級別和更低
jvm.inspection.logging.string.template.as.argument.warn.on.label=警告物件:
jvm.inspection.test.failed.line.display.name=測試中失敗的行
jvm.inspections.1.5.problem.descriptor=使用記錄為 @since {0}+ 的 API
jvm.inspections.1.7.problem.descriptor=使用自 1.6 以來通用的 API，這可能會導致 JDK {0} 出現編譯問題。
jvm.inspections.1.8.problem.descriptor=預設{0, choice, 0#|1#方法|2#方法}不會被覆寫。它會導致 JDK {1} 出現編譯問題
jvm.inspections.1.8.problem.single.descriptor=預設方法 ''{0}'' 不會被覆寫。它會導致 JDK {1} 出現編譯問題
jvm.inspections.api.display.name=使用在組態的語言級別下不可用的 API
jvm.inspections.api.no.extension.class.description=不得擴展類別 ''{0}''
jvm.inspections.api.no.extension.display.name=不應擴展類別、接口或方法
jvm.inspections.api.no.extension.interface.extend.description=不得擴展接口 ''{0}''
jvm.inspections.api.no.extension.interface.implement.description=不得實作接口 ''{0}''
jvm.inspections.api.no.extension.method.overriding.description=不得覆寫方法 ''{0}''
jvm.inspections.api.override.only.description=方法 ''{0}'' 只能覆寫
jvm.inspections.api.override.only.display.name=方法只能覆寫
jvm.inspections.assertequals.between.inconvertible.types.problem.descriptor=<code>#ref()</code> 位於 ''{0}'' 和 ''{1}'' 不可轉換類型的物件之間 #loc
jvm.inspections.assertnotequals.between.inconvertible.types.problem.descriptor=可能的冗餘斷言: 比較不相容的類型 ''{0}'' 和 ''{1}''
jvm.inspections.assertnotsame.between.inconvertible.types.problem.descriptor=冗餘斷言: 比較不相容的類型 ''{0}'' 和 ''{1}''
jvm.inspections.blocking.method.annotation.blocking=阻塞註解:
jvm.inspections.blocking.method.annotation.configure.add.blocking.title=新增阻塞註解
jvm.inspections.blocking.method.annotation.configure.add.non-blocking.title=新增非阻塞註解
jvm.inspections.blocking.method.annotation.non-blocking=非阻塞註解:
jvm.inspections.blocking.method.consider.suspend.context.non.blocking=Consider Kotlin suspend context non-blocking
jvm.inspections.blocking.method.consider.unknown.context.blocking=考慮未知上下文阻塞
jvm.inspections.blocking.method.consider.unknown.context.nonblocking=考慮未知上下文非阻塞
jvm.inspections.blocking.method.display.name=可能在非阻塞上下文中使用阻塞呼叫
jvm.inspections.blocking.method.in.implicit.ctr.problem.descriptor=在非阻塞上下文中使用來自隱式建構函式呼叫的阻塞呼叫可能會導致執行緒匱乏
jvm.inspections.blocking.method.in.implicit.ctr.problem.wildcard.descriptor=在{0}中使用來自隱式建構函式呼叫的阻塞呼叫可能會導致執行緒匱乏
jvm.inspections.blocking.method.intention.text=啟用檢查選項 ''{0}''。
jvm.inspections.blocking.method.problem.descriptor=在非阻塞上下文中使用阻塞呼叫可能會導致執行緒匱乏
jvm.inspections.blocking.method.problem.wildcard.descriptor=在{0}中使用阻塞呼叫可能會導致執行緒匱乏
jvm.inspections.collection.contains.url.problem.descriptor=''{0}'' 可能包含 URL 物件 #loc
jvm.inspections.dependency.display.name=非法的軟體套件相依項
jvm.inspections.dependency.edit.rules.family=編輯相依關係規則
jvm.inspections.dependency.edit.rules.text=編輯相依關係規則“{0}”
jvm.inspections.dependency.intention.description=開啟一個對話框以組態作用域之間的相依關係規則。
jvm.inspections.dependency.on.internal.display.name=對內部軟體套件的非法相依
jvm.inspections.dependency.violator.problem.descriptor=違反相依關係規則 ''{0}.''
jvm.inspections.equals.hashcode.called.on.url.display.name=在 'URL' 物件上呼叫 'equals()' 或 'hashCode()'
jvm.inspections.equals.hashcode.called.on.url.problem.descriptor=在 URL 物件上呼叫 ''{0}''
jvm.inspections.group.name=JVM 語言
jvm.inspections.junit.assertequals.may.be.assertsame.display.name='assertEquals()' 可能是 'assertSame()'
jvm.inspections.junit.assertequals.may.be.assertsame.problem.descriptor=<code>#ref()</code> 可能是 'assertSame()' #loc
jvm.inspections.junit.assertequals.on.array.display.name=在陣列上呼叫了 'assertEquals()'
jvm.inspections.junit.assertequals.on.array.problem.descriptor=在陣列上呼叫了 <code>#ref()</code> #loc
jvm.inspections.junit.ignored.test.class.problem.descriptor=測試類別 ''{0}'' 已被{1, choice, 1#|2#無理由}忽略/停用 #loc
jvm.inspections.junit.ignored.test.display.name=使用 '@Ignore'/'@Disabled' 註解的 JUnit 測試
jvm.inspections.junit.ignored.test.ignore.reason.option=只報告沒有原因的註解
jvm.inspections.junit.ignored.test.method.problem.descriptor=測試方法 ''{0}()'' 已被{1, choice, 1#|2#無理由}忽略/停用 #loc
jvm.inspections.junit.malformed.annotated.double.descriptor=使用 ''@{1}'' 註解的{0, choice, 0#欄位|1#方法} <code>#ref</code> 應為 {2} 和 {3}
jvm.inspections.junit.malformed.annotated.double.typed.descriptor=使用 ''@{1}'' 註解的{0, choice, 0#欄位|1#方法} <code>#ref</code> 應為 {2}、{3} 且類型應為 ''{4}''
jvm.inspections.junit.malformed.annotated.method.double.param.double.descriptor=使用 ''@{0}'' 註解的方法 <code>#ref</code> 應為 {1}，{2}，且不應宣告參數 ''{3}'' 和 ''{4}''
jvm.inspections.junit.malformed.annotated.method.double.param.single.descriptor=使用 ''@{0}'' 註解的方法 <code>#ref</code> 應為 {1}，{2}，且不應宣告參數 ''{3}''
jvm.inspections.junit.malformed.annotated.method.double.typed.param.double.descriptor=使用 ''@{0}'' 註解的方法 <code>#ref</code> 應為 {1}，{2}，類型應為 ''{3}''，且不應宣告參數 {4} 和 ''{5}''
jvm.inspections.junit.malformed.annotated.method.double.typed.param.single.descriptor=使用 ''@{0}'' 註解的方法 <code>#ref</code> 應為 {1}，{2}，類型應為 ''{3}''，且不應宣告參數 ''{4}''
jvm.inspections.junit.malformed.annotated.method.param.double.descriptor=使用 ''@{0}'' 註解的方法 <code>#ref</code> 不應宣告參數 {1} 和 ''{2}''
jvm.inspections.junit.malformed.annotated.method.param.single.descriptor=使用 ''@{0}'' 註解的方法 <code>#ref</code> 不應宣告參數 ''{1}''
jvm.inspections.junit.malformed.annotated.method.single.param.double.descriptor=使用 ''@{0}'' 註解的方法 <code>#ref</code> 應為 {1} 且不應宣告參數 ''{2}'' 和 ''{3}''
jvm.inspections.junit.malformed.annotated.method.single.param.single.descriptor=使用 ''@{0}'' 註解的方法 <code>#ref</code> 應為 {1} 且不應宣告參數 ''{2}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.double.descriptor=使用 ''@{0}'' 註解的方法 <code>#ref</code> 應為 {1}，類型應為 ''{2}''，且不應宣告參數 {3} 和 ''{4}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.single.descriptor=使用 ''@{0}'' 註解的方法 <code>#ref</code> 應為 {1}，類型應為 ''{2}''，且不應宣告參數 ''{3}''
jvm.inspections.junit.malformed.annotated.method.typed.param.double.descriptor=使用 ''@{0}'' 註解的方法 <code>#ref</code> 的類型應為 ''{1}''，且不應宣告參數 {2} 和 ''{3}''
jvm.inspections.junit.malformed.annotated.method.typed.param.single.descriptor=使用 ''@{0}'' 註解的方法 <code>#ref</code> 的類型應為 ''{1}'' 且不應宣告參數 ''{2}''
jvm.inspections.junit.malformed.annotated.single.descriptor=使用 ''@{1}'' 註解的{0, choice, 0#欄位|1#方法} <code>#ref</code> 應為 {2}
jvm.inspections.junit.malformed.annotated.single.typed.descriptor=使用 ''@{1}'' 註解的{0, choice, 0#欄位|1#方法} <code>#ref</code> 應為 {2} 且類型應為 ''{3}''
jvm.inspections.junit.malformed.annotated.suspend.function.descriptor=使用 ''@{0}'' 註解的方法 <code>#ref</code> 不應為掛起函式
jvm.inspections.junit.malformed.annotated.typed.descriptor=使用 ''@{1}'' 註解的{0, choice, 0#欄位|1#方法} <code>#ref</code> 類型應為 ''{2}''
jvm.inspections.junit.malformed.declaration.name=JUnit 格式錯誤的宣告
jvm.inspections.junit.malformed.extension.class.level.descriptor=應在類別級別註冊{0}
jvm.inspections.junit.malformed.fix.class.signature=修正類別簽名
jvm.inspections.junit.malformed.fix.class.signature.descriptor=修正 ''{0}'' 類別簽名
jvm.inspections.junit.malformed.fix.class.signature.multi=修正類別簽名
jvm.inspections.junit.malformed.fix.field.signature=修正欄位簽名
jvm.inspections.junit.malformed.fix.field.signature.descriptor=修正 ''{0}'' 欄位簽名
jvm.inspections.junit.malformed.fix.method.signature=修復方法簽名
jvm.inspections.junit.malformed.fix.method.signature.descriptor=修復 ''{0}'' 方法簽名
jvm.inspections.junit.malformed.missing.nested.annotation.descriptor=不會執行嵌套類別中的測試
jvm.inspections.junit.malformed.no.arg.descriptor=方法 <code>#ref</code> 應為 {0}、{1}{2, choice, 0#且無形參|1#，無形參，且類型為 void}
jvm.inspections.junit.malformed.option.ignore.test.parameter.if.annotated.by=由以下物件註解時忽略測試參數:
jvm.inspections.junit.malformed.param.duplicated.enum.descriptor=重複的 'enum' 常數名稱
jvm.inspections.junit.malformed.param.empty.source.unsupported.descriptor=''@{0}'' 無法向方法提供實參，因為方法具有不受支援的 ''{1}'' 類型的參數
jvm.inspections.junit.malformed.param.exactly.one.type.of.input.must.be.provided.descriptor=必須恰好提供一種類型的輸入
jvm.inspections.junit.malformed.param.file.source.descriptor=無法解析檔案源: ''{0}''
jvm.inspections.junit.malformed.param.method.source.assignable.descriptor=未找到將 ''{0}'' 轉換為 ''{1}'' 的隱式轉換
jvm.inspections.junit.malformed.param.method.source.no.params.descriptor=方法源 ''{0}'' 不應有參數
jvm.inspections.junit.malformed.param.method.source.return.type.descriptor=方法源 ''{0}'' 必須具有以下其中一種返回值類型: ''Stream<?>''、''Iterator<?>''、''Iterable<?>'' 或 ''Object[]''
jvm.inspections.junit.malformed.param.method.source.static.descriptor=方法源 ''{0}'' 必須為 static
jvm.inspections.junit.malformed.param.method.source.unresolved.descriptor=無法解析目標方法源: ''{0}''
jvm.inspections.junit.malformed.param.multiple.parameters.descriptor=此源不支持多個參數
jvm.inspections.junit.malformed.param.no.sources.are.provided.descriptor=沒有提供源，套件將為空
jvm.inspections.junit.malformed.param.no.value.source.is.defined.descriptor=未定義值源
jvm.inspections.junit.malformed.param.unresolved.enum.descriptor=無法解析 'enum' 常數參照。
jvm.inspections.junit.malformed.param.wrapped.in.arguments.descriptor=必須在 'Arguments' 中包裝多個參數
jvm.inspections.junit.malformed.repetition.number.descriptor=重複次數必須大於零
jvm.inspections.junit.malformed.source.without.params.descriptor=''@{0}'' 無法向方法提供實參，因為方法沒有參數
jvm.inspections.junit.malformed.suspend.function.descriptor=方法 <code>#ref</code> 不應為掛起函式
jvm.inspections.junit.malformed.test.combination.descriptor=可疑的 {0} 與 ''@{1}'' 組合
jvm.inspections.junit.mixed.annotations.junit.descriptor=擴展 JUnit {1} TestCase 的類別內使用 ''@{0}'' 註解的方法 <code>#ref()</code> #loc
jvm.inspections.junit.mixed.annotations.name=在單個 TestCase 中使用多個版本的 JUnit API
jvm.inspections.junit3.super.teardown.display.name=未從 'finally' 塊呼叫 JUnit 3 'super.tearDown()'
jvm.inspections.junit3.super.teardown.problem.descriptor=未從 'finally' 塊呼叫 <code>#ref()</code> #loc
jvm.inspections.junit4.converter.display.name=JUnit 3 測試可以是 JUnit 4
jvm.inspections.junit4.converter.problem.descriptor=<code>#ref</code> 可以轉換為 JUnit4 測試用例
jvm.inspections.junit4.converter.quickfix.conflict.call.compile=如果 {1} 被轉換為 JUnit 4，方法呼叫 {0} 將不編譯
jvm.inspections.junit4.converter.quickfix.conflict.name=方法 {0} 將與其 super 方法發生名稱衝突
jvm.inspections.junit4.converter.quickfix.conflict.semantics=如果 {1} 被轉換為 JUnit 4，方法呼叫 {0} 可能會更改語意
jvm.inspections.junit4.converter.quickfix.conflict.suite={0} 的 suite 方法的遷移有副作用，將被刪除
jvm.inspections.junit4.converter.quickfix.name=轉換為 JUnit 4 測試用例
jvm.inspections.junit5.converter.display.name=JUnit 4 測試可以為 JUnit 5
jvm.inspections.junit5.converter.problem.descriptor=#ref 可以為 JUnit 5 測試
jvm.inspections.junit5.converter.quickfix=遷移到 JUnit 5
jvm.inspections.junit5.converter.quickfix.conflict.inheritor=由於存在不相容的繼承者，類別 {0} 無法轉換為 JUnit 5: {1}
jvm.inspections.junit5.converter.quickfix.presentation.text=轉換斷言
jvm.inspections.logging.frameworks.group.name=日誌記錄
jvm.inspections.migrate.assert.to.matcher.description=斷言表達式 <code>#ref</code> 可被取代為 ''{0}'' 呼叫 #loc
jvm.inspections.migrate.assert.to.matcher.option=靜態匯入符合程序的方法
jvm.inspections.migrate.assertion.name=JUnit 斷言可以是 'assertThat()' 呼叫
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.description=已計劃移除的 API 也必須使用 '@Deprecated' 註解標記
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.display.name=已計劃移除的 API 上缺少 '@Deprecated' 註解
jvm.inspections.must.already.be.removed.api.current.version.description=API 必須在當前版本 {0} 中移除
jvm.inspections.must.already.be.removed.api.display.name=API 必須已移除
jvm.inspections.must.already.be.removed.api.earlier.version.description=API 必須已在版本 {0} 中移除，但當前版本為 {1}
jvm.inspections.remove.annotation.quickfix.name=移除註解
jvm.inspections.remove.annotation.quickfix.text=移除 ''@{0}'' 註解
jvm.inspections.rename.quickfix.name=重新命名元素
jvm.inspections.rename.quickfix.text=重命名為 ''{0}''
jvm.inspections.scheduled.for.removal.api.is.declared.in.marked.api=''{0}'' 在已計劃從 {3} 中移除的{1} ''{2}'' 中宣告
jvm.inspections.scheduled.for.removal.api.is.marked.itself=''{0}'' 已計劃從 {1} 中移除
jvm.inspections.scheduled.for.removal.future.version=未來版本
jvm.inspections.scheduled.for.removal.method.overridden.declared.in.marked.api=覆寫方法 ''{0}'' 在已計劃從 {3} 中移除的{1} ''{2}'' 中宣告
jvm.inspections.scheduled.for.removal.method.overridden.marked.itself=覆寫方法 ''{0}'' 已計劃從 {1} 中移除
jvm.inspections.scheduled.for.removal.predefined.version=版本 {0}
jvm.inspections.scheduled.for.removal.scheduled.for.removal.type.is.used.in.signature.of.referenced.api=''{0}'' 已計劃移除，因為其簽名參照了已計劃從 {3} 中移除的{1} ''{2}''
jvm.inspections.serializable.class.without.serialversionuid.display.name=不帶 'serialVersionUID' 的可序列化類別
jvm.inspections.serializable.class.without.serialversionuid.problem.descriptor=<code>#ref</code> 未定義 'serialVersionUID' 欄位 #loc
jvm.inspections.source.to.sink.flow.assigned.unknown=未知字串分配給安全變數
jvm.inspections.source.to.sink.flow.assigned.unsafe=不安全的字串分配給安全變數
jvm.inspections.source.to.sink.flow.common.unknown=未知字串在安全上下文中使用
jvm.inspections.source.to.sink.flow.common.unsafe=不安全字串在安全上下文中使用
jvm.inspections.source.to.sink.flow.display.name=不安全字串被傳遞至安全方法
jvm.inspections.source.to.sink.flow.passed.unknown=未知字串用作安全參數
jvm.inspections.source.to.sink.flow.passed.unsafe=不安全字串用作安全參數
jvm.inspections.source.to.sink.flow.returned.unknown=未知字串返回自安全方法
jvm.inspections.source.to.sink.flow.returned.unsafe=不安全字串返回自安全方法
jvm.inspections.source.to.sink.flow.too.complex=Too complex to check that the string is safe in a safe context
jvm.inspections.source.unsafe.to.sink.flow.check.private.methods = 將 private 方法的參數視為安全
jvm.inspections.source.unsafe.to.sink.flow.check.private.methods.comment = If it is enabled, then parameters of private methods are considered as safe, otherwise they will be considered as unknown
jvm.inspections.source.unsafe.to.sink.flow.check.warn.if.complex = 報告情況是否太複雜而無法檢查
jvm.inspections.source.unsafe.to.sink.flow.check.warn.if.complex.comment = Enable, if it is needed to report strings, which can not be checked because of the complexity
jvm.inspections.source.unsafe.to.sink.flow.config=Untainted 註解將被新增到元素 ''{0}'' 的檢查設定中
jvm.inspections.source.unsafe.to.sink.flow.impossible=元素 ''{0}'' 不支持 Untainted 註解。該元素將被跳過
jvm.inspections.source.unsafe.to.sink.flow.index.parameter=參數索引
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.command.name=標記為需要驗證
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.family=標記為需要驗證
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.text=將元素標記為需要驗證
jvm.inspections.source.unsafe.to.sink.flow.not.number=非數字
jvm.inspections.source.unsafe.to.sink.flow.preview=新增 '@Untainted' 註解
jvm.inspections.source.unsafe.to.sink.flow.preview.propagate=顯示傳播樹
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.family=傳播樹
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.preview=開啟工具視窗以檢查安全註解的傳播
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.text=從此處顯示傳播樹
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.annotate=註解除排除外的所有物件
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.title=不安全的成員
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.unsafe.flow=不安全的流
jvm.inspections.source.unsafe.to.sink.flow.safe.class=安全類別:
jvm.inspections.source.unsafe.to.sink.flow.safe.class.comment=These classes can't contain unsafe data
jvm.inspections.source.unsafe.to.sink.flow.tainted.annotations=Tainted 註解:
jvm.inspections.source.unsafe.to.sink.flow.tainted.annotations.comment=These annotations will be used as '@Tainted' annotations during the analysis
jvm.inspections.source.unsafe.to.sink.flow.tainted.methods=Tainted 方法:
jvm.inspections.source.unsafe.to.sink.flow.tainted.methods.comment=這些方法被視為只返回不安全的物件
jvm.inspections.source.unsafe.to.sink.flow.tainted.parameters=Tainted 參數:
jvm.inspections.source.unsafe.to.sink.flow.tainted.parameters.comment=這些參數被視為具有 '@Tainted' 註解
jvm.inspections.source.unsafe.to.sink.flow.untainted.annotations=Untainted 註解:
jvm.inspections.source.unsafe.to.sink.flow.untainted.annotations.comment=These annotations will be used as '@Untainted' annotations during the analysis. The first annotation from this list will be used for propagation if it exists in the classpath.
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields=Untainted 欄位:
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields.comment=These fields are considered to contain only safe objects
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields.name=欄位名稱
jvm.inspections.source.unsafe.to.sink.flow.untainted.methods=Untainted 方法:
jvm.inspections.source.unsafe.to.sink.flow.untainted.methods.comment=These methods are considered to return only safe objects
jvm.inspections.source.unsafe.to.sink.flow.untainted.parameters=Untainted 參數:
jvm.inspections.source.unsafe.to.sink.flow.untainted.parameters.comment=這些參數被視為具有 '@Untainted' 註解
jvm.inspections.source.unsafe.to.sink.flow.untainted.process.as.qualifier.arguments=如果接收器和實參未被污染，則認為外部方法未被污染
jvm.inspections.source.unsafe.to.sink.flow.untainted.process.as.qualifier.arguments.comment=If it is enabled, then external methods outside the current class will be considered as safe if their receivers and arguments are safe. In some cases, it is not applicable, but it can be useful for stateless classes. Otherwise, all external methods will be considered as unsafe
jvm.inspections.string.touppercase.tolowercase.without.locale.description=在未使用國際化字串指定區域設定的情況下呼叫 <code>String.{0}()</code> #loc
jvm.inspections.test.case.in.product.source.display.name=產品源中的測試
jvm.inspections.test.case.in.product.source.problem.descriptor=測試用例 <code>#ref</code> 可能應被放置在測試源樹中 #loc
jvm.inspections.test.case.with.constructor.display.name=具有非普通建構函式的 TestCase
jvm.inspections.test.case.with.constructor.problem.descriptor=建構函式 <code>#ref()</code> 中的初始化邏輯，而不是 'setup()' 生命周期方法 #loc
jvm.inspections.test.case.with.constructor.problem.descriptor.initializer=初始設定式中的初始化邏輯，而不是 'setup()' 生命周期方法
jvm.inspections.test.frameworks.group.name=測試框架
jvm.inspections.test.method.in.product.source.problem.descriptor=測試方法 <code>#ref()</code> 可能應被放置在測試源樹中 #loc
jvm.inspections.test.method.without.assertion.display.name=不帶斷言的測試方法
jvm.inspections.test.method.without.assertion.problem.descriptor=測試方法 <code>#ref()</code> 不包含斷言 #loc
jvm.inspections.testonly.class.reference=在生產程式碼中參照純測試類別
jvm.inspections.testonly.display.name=生產程式碼中的純測試用法
jvm.inspections.testonly.field.reference=在生產程式碼中參照純測試欄位
jvm.inspections.testonly.method.call=在生產程式碼中呼叫純測試方法
jvm.inspections.testonly.visiblefortesting=@VisibleForTesting 對 @TestOnly 程式碼意義不大
jvm.inspections.thread.run.display.name=呼叫 'Thread.run()'
jvm.inspections.unstable.api.usage.annotations.list=不穩定的 API 註解:
jvm.inspections.unstable.api.usage.api.is.declared.in.unstable.api=''{0}'' 在標記為 @{3} 的不穩定{1} ''{2}'' 中宣告
jvm.inspections.unstable.api.usage.api.is.marked.unstable.itself=''{0}'' 使用 @{1} 標記為不穩定
jvm.inspections.unstable.api.usage.display.name=不穩定的 API 用法
jvm.inspections.unstable.api.usage.ignore.declared.inside.this.project=忽略此專案中宣告的 API
jvm.inspections.unstable.api.usage.ignore.inside.imports=在匯入內忽略
jvm.inspections.unstable.api.usage.overridden.method.is.declared.in.unstable.api=覆寫方法 ''{0}'' 在標記為 @{3} 的不穩定{1} ''{2}'' 中宣告
jvm.inspections.unstable.api.usage.overridden.method.is.marked.unstable.itself=覆寫方法 ''{0}'' 使用 @{1} 標記為不穩定
jvm.inspections.unstable.api.usage.unstable.type.is.used.in.signature.of.referenced.api=''{0}'' 不穩定，因為其簽名參照了標記為 @{3} 的不穩定{1} ''{2}''
jvm.inspections.unstable.type.used.in.class.signature.description=類別必須使用 ''@{0}'' 註解標記，因為其宣告參照了不穩定的類型 ''{1}''
jvm.inspections.unstable.type.used.in.field.signature.description=欄位必須使用 ''@{0}'' 註解標記，因為其類型參照了不穩定的類型 ''{1}''
jvm.inspections.unstable.type.used.in.method.signature.description=方法必須使用 ''@{0}'' 註解標記，因為其簽名參照了不穩定的類型 ''{1}''
jvm.inspections.unstable.type.used.in.signature.display.name=簽名中使用了不穩定的類型
jvm.inspections.usages.of.obsolete.api.description=使用了過時的 API
jvm.inspections.usages.of.obsolete.api.display.name=ApiStatus.@Obsolete 的用法
propagated.from=傳播原因:
propagated.to=要傳播的目標:
title.uast=UAST