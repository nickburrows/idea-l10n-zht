0.errors.1.warnings={0} 個錯誤，{1} 個警告
0.manifest.properties=''{0}'' 清單屬性:
ArtifactPropertiesEditor.tab.post.processing=正在後處理
ArtifactPropertiesEditor.tab.pre.processing=正在預處理
ArtifactPropertiesEditor.tab.validation=驗證
abnormal.build.process.termination=建置程序終止異常
action.compile.description.module=模組 ''{0}''
action.compile.description.selected.files=所選檔案
action.compiler.properties.text=編譯器屬性
action.compiler.reference.direct.inheritor.search.text=編譯器參照直接繼承者搜尋
action.compiler.reference.find.usages.text=編譯器參照尋找用法
action.compiler.reference.functional.expression.search.text=編譯器參照函式表達式搜尋
action.description.package.file=更新對應工件中的檔案
action.disabled.in.fork.mode={0} 在複刻模式下被停用。<br/>將複刻模式更改為 \\&lt;none\\&gt; 以{1}。
action.disabled.when.per.module.working.directory.configured=組態按模組工作目錄時將停用 ''{0}''。<br/>只指定一個工作目錄，或將測試作用域更改為一個模組。
action.make.few.modules.text=建置模組 {0}(_M)
action.make.selected.modules.text=建置選定的模組 (_M)
action.make.single.module.text=建置模組 ''{0}''(_M)
action.name.exclude.from.validation=從驗證中排除
action.name.package.file=打包檔案
action.name.package.files=打包檔案
action.run.all.affected.tests.text=執行所有受影響的測試
action.show.snapshot.location.text=顯示快照位置
action.text.move.to=移至
actions.exclude.from.compile.text=從編譯中排除
add.notnull.assertions=為非 null 註解的方法和參數新增執行時斷言(&A)
affected.tests.counts=\ /{0} 個{1, choice, 0#測試|1#測試}
all.inheritors=所有({0})
all.modules=<所有模組>
artifact.configuration.problem.text={0, choice, 1#{1} 個工件|2#{0} 個工件}
artifact.type.plain=其他
artifacts.menu.item.all=所有工件
artifacts.menu.item.build=建置
artifacts.menu.item.clean=清理
artifacts.menu.item.edit=編輯…
artifacts.menu.item.rebuild=重新建置
bad.resource.patterns.dialog.title=格式不正確的資源模式
build.artifacts.before.run.description.empty=編譯 Artifacts
build.artifacts.before.run.description.multiple=編譯 {0} artifacts
build.artifacts.before.run.description.single=建置 ''{0}'' 工件
build.artifacts.before.run.selector.title=編譯 Artifacts
build.process.ecj.path.does.not.exist=eclipse ecj 編譯器的路徑不存在: {0}
build.process.no.free.debug.port=找不到可用的連接埠來偵錯建置程序
build.process.no.javac.found=JRE 未提供系統 java 編譯器。確保 IntelliJ IDEA 類別路徑中存在 tools.jar。
build.process.no.javac.path.found=無法確定 {0} ({1})到 ''tools.jar'' 庫的路徑
build.process.wsl.distribution.dont.match=正在嘗試使用 JDK {0} 開始建置，該版本的 JDK 未存儲在專案的 WSL 分發版中。\n\
執行建置的 JDK 以及專案使用的 JDK 必須存儲在存儲專案的同一 WSL 分發版中。\n\
執行建置需要 JDK {1} 或更高版本。如果您的專案使用的是較舊的 JDK，請將 JDK {1} 或更高版本新增到您的 SDK 組態表中。該 JDK 將被自動選取以執行建置。
button.add=新增(&A)…
button.rebuild=重新建置
button.text.checkin.handler.show.errors=展示錯誤 (&S)
cannot.clean.0.artifact=無法清理 ''{0}'' 工件
cannot.create.directory.0.1=無法建立目錄 ''{0}'': {1}
cannot.delete.0=無法刪除 ''{0}''
cannot.package.file=無法打包檔案
checkbox.text.compile.affected.unloaded.modules=編譯受影響的已移除模組 (&U)
choose.members=選擇成員
chooser.description.select.output.directory.for.0.artifact=選擇''{0}'' artifact的輸出目錄
class.can.have.more.common.super.class=類別可以擁有更常見的超類別
classes.up.to.date.check=類別最新狀態檢查
clean.artifacts=清理工件
cleaning.artifacts=正在清理工件
compilation.finished=編譯已完成
compiler.build.messages.classes.check.outdated=建置結果對請求的編譯作用域來說已過時。\n\
後續增量建置將為更改的源編譯檔案，並移除先前建置的過時結果。
compiler.build.messages.classes.check.uptodate=建置結果對請求的編譯作用域來說處於最新狀態。\n\
後續增量建置將不會執行任何動作。
compiler.cache.description=編譯器快取
compiler.cache.option.cleanup.asynchronously=異步清理
compiler.cache.option.disable.update=停用快取下載
compiler.cache.option.force.update=強制更新快取
compiler.cache.option.max.download.time=快取下載的最長持續時間:
compiler.cache.option.max.download.time.units= 分鐘
compiler.configurable.display.name=編譯器
compiler.content.name.make=建置
compiler.content.name.rebuild=重新建置
compiler.content.name.recompile=重新編譯
compiler.eclipse.name=Eclipse
compiler.error.failed.to.delete=無法刪除 {0}
compiler.javac.name=Javac
compiler.results.export.text.prefix=行 ({0})
compiler.running.dialog.title=編譯器執行中
compiler.ui.pattern.legend.text=使用 <b>;</b> 分隔模式，使用 <b>!</b> 求反模式。已接受萬用字元: <b>?</b> \\&mdash; 僅一個符號；<b>*</b> \\&mdash; 無或更多符號；<b>/</b> \\&mdash; 路徑分隔符；<b>/**/</b> \\&mdash; 任何數量的目錄；<i>\\&lt;dir_name\\&gt;</i>:<i>\\&lt;pattern\\&gt;</i> \\&mdash; 限制為具有指定名稱的來源根
configurable.AnnotationProcessorsConfigurable.display.name=註解處理器
configurable.CompilerUIConfigurable.display.name=一般
configuration.for.java.scratch.files=Java 臨時檔案的組態
confirm.project.rebuild=確認專案重新建置
create.jar.from.modules=從模組建立 JAR
dialog.message.action.apply.fix=自動修復
dialog.message.compilation.of.unloaded.modules.failed=There are unloaded modules in the project which depend on changed files.\n\
Compilation of these modules finished with errors.
dialog.message.enter.directory.name=輸入目錄名稱:
dialog.message.error.jdk.not.specified.with.fixSuggestion=沒有為 {0} {1,choice, 1#模組|2#模組}指定 SDK，或其 SDK 已損壞。自動解析以下 SDK?
dialog.message.error.jdk.not.specified.with.noFix=需要手動組態:
dialog.message.jar.file.doesn.t.exist=JAR 檔案 ''{0}'' 不存在
dialog.message.output.dir.artifact= ''{0}'' 工件(''{1}'')
dialog.message.output.dir.contains.source.roots=''{1}'' 工件的輸出目錄 ''{0}'' 包含專案的來源根。是否繼續並將其清除?
dialog.message.output.dirs.contain.source.roots=以下工件的輸出目錄包含來源根:\n\
{0}是否要繼續並清除這些目錄?
dialog.message.profile.name=組態檔名
dialog.title.choose.artifacts=選擇 Artifacts
dialog.title.choose.module=選擇模組
dialog.title.manifest.select.main.class=選擇主類別
dialog.title.output.directory.for.artifact=Artifact輸出目錄
dialog.title.packaging.choose.library=選擇庫
dialog.title.packaging.choose.module=選擇模組
directory.copy.element.type.name=目錄內容
disabled.in.power.save.mode=(在省電模式下停用)
eclipse.compiler.cross.platform.help.message=(建議在路徑中使用 '/' 進行跨平台組態)
eclipse.compiler.path.leave.empty.help.message=ECJ 批處理編譯器工具的路徑(若留空，則使用捆綁路徑):
eclipse.compiler.proceed.on.errors.option=遇到錯誤時繼續
eclipse.options.group.title=Eclipse 選項
edit.classpath=編輯類別路徑
element.type.name.archive=歸檔
element.type.name.artifact=工件
element.type.name.directory=目錄
element.type.name.library.files=庫檔案
element.type.name.module.output=模組輸出
element.type.name.module.source=模組源
element.type.name.module.test.output=模組測試輸出
element.with.manifest.button.create.manifest=建立清單(&C)…
element.with.manifest.button.use.existing.manifest=使用現有清單(&U)…
element.with.manifest.label.manifest.file=清單檔案(&F):
element.with.manifest.label.meta.inf.manifest.mf.file.not.found=找不到 META-INF/MANIFEST.MF 檔案
enter.archive.name=輸入歸檔名稱:
error.associated.scratch.file.not.found=未找到關聯的臨時檔案
error.bad.resource.patterns=以下資源模式格式錯誤:{0}
error.chunk.modules.must.have.same.jdk=以下模組必須具有相同的 JDK 分配，因為它們之間的迴圈相依關係:\n\
{0}\n\
請更新模組組態
error.chunk.modules.must.have.same.language.level=以下模組必須具有相同的語言級別，因為它們之間存在迴圈相依關係:\n\
{0}\n\
請更新模組組態
error.compiler.configurable.malformed.patterns=以下資源模式格式錯誤:\n\
{0}
error.javac.out.of.memory=記憶體不足。在“專案屬性|編譯器”設定中增加最大堆大小。
error.jdk.module.names.overflow.element.ellipsis=…
error.jdk.not.specified=沒有為{0,choice, 1#模組|2#模組} {1} 指定 SDK
error.no.scratch.file.associated.with.configuration=沒有與組態關聯的臨時檔案
error.output.not.specified=沒有為{0,choice, 1#模組|2#模組} {1} 指定輸出路徑
error.task.0.execution.failed=任務 {0} 失敗，請參閱 idea.log 了解詳細資訊
exclude.from.compile.table.path.column.name=路徑
exclude.from.compile.table.recursively.column.name=遞迴
extracted.directory.element.type.name=已提取目錄
file.title=檔案
intention.name.make.extends=生成擴展 ''{0}''
intention.name.make.implements=生成實作 ''{0}''
jar.artifacts.dialog.border.title.jar.files.from.libraries=來自庫的 JAR 檔案
jar.artifacts.dialog.checkbox.include.tests=包含測試(&I)
jar.artifacts.dialog.label.directory.for.metainf=META-INF/MANIFEST.MF 的目錄(&D):
jar.artifacts.dialog.label.main.class=主類別(&C):
jar.artifacts.dialog.label.module=模組(&M):
jar.artifacts.dialog.radio.button.copy.to.the.output.directory.and.link.via.manifest=複製到輸出目錄並通過清單鏈接(&T)
jar.artifacts.dialog.radio.button.extract.to.the.target.jar=提取到目標 JAR(&E)
jar.from.modules.presentable.name=來自具有相依項的模組…
jar.text=JAR
java.compiler.description=Java編譯器
java.compiler.option.additional.command.line.parameters=附加命令行參數:
java.compiler.option.generate.debugging.info=生成偵錯資訊
java.compiler.option.generate.no.warnings=不生成警告
java.compiler.option.prefer.target.jdk.compiler=盡可能使用模組目標 JDK 中的編譯器
java.compiler.option.report.deprecated=報告使用棄用的功能
java.scratch=Java 草稿
javac.options.group.title=Javac 選項
jshell.console=JShell 主控台
jshell.dropped.x.code.snippets=已丟棄 {0} 程式碼段
jshell.internal.error=內部錯誤
jshell.nothing.to.execute=沒有要執行的內容
label.address=地址(&A):
label.debugger.mode=偵錯器模式(&D):
label.extracted.dir.presentation=已提取 ''{0}''
label.host=主機(&H):
label.in.path.suffix=(在 {0} 中)
label.library.element.module=模組 ''{0}''
label.option.autoshow.first.error=在編輯器中自動顯示錯誤 (&E)
label.option.clear.output.directory.on.rebuild=在重新建置時清除輸出目錄 (&L)
label.option.display.notification.popup=在建置完成時顯示通知
label.option.resource.patterns.text=資源模式:
label.port=連接埠(&P):
label.text.class.path=類別路徑 (&P):
label.text.main.class=主類別 (&M):
label.transport=傳輸(&T):
label.unknown.value=<未知>
link.label.checkin.handler.show.errors=Show errors
macro.output.path=輸出路徑
mesage.text.deployment.descriptor.file.not.exist=部署檔案描述子檔案 ''{0}'' 不存在
message.category.error=錯誤
message.category.information=資訊
message.category.statistics=統計
message.category.warning=警告
message.resource.patterns.format.changed=資源模式的格式已更改。\n\
{0} 無法轉換現有的正則表達式模式:\n\
{1}\n\
請以新格式輸入模式字串。\n\
每個資源模式可以包含以下萬用字元:\n\
? - 一個字元\n\
* - 零個或多個字元\n\
! - 反轉符合（僅允許在模式開頭）\n\
使用 ; (分號)來分隔資源模式；\n\
使用反斜杠(“\\”)轉義“!”字元。\n\
您可能還需要修改模板專案設定。\n\
按 ''{2}'' 接受輸入的模式，按 ''{3}'' 以新格式載入預設模式。
message.tect.package.file.io.error=IO異常:\n\
{0}
message.text.deployment.description.invalid.file=無效檔案
message.text.error.copying.file.to.file=將檔案 ''{0}'' 複製到 ''{1}'' 時出錯。
message.text.xml.file.invalid=XML檔案 ''{0}'' 無效
meta.inf.manifest.mf.file.not.found.in.0=在 ''{0}'' 中未找到 META-INF/MANIFEST.MF 檔案
module.sources.set.display.name={0, choice, 0#|1#測試 }''{1}'' 模組
modules.classpath.title=相依
no.compilation.problems.found=未找到編譯問題
no.excludes=不排除
no.validators=沒有驗證器可用
node.excluded.flag.tooltip=排除
node.text.0.compile.output=''{0}'' 編譯輸出
node.text.0.directory.content=''{0}'' 目錄內容
node.text.0.module.sources=''{0}'' 源
node.text.0.test.compile.output=''{0}'' 測試編譯輸出
notification.action.jps.open.configuration.dialog=組態…
notification.compiler.auto.build.completed.with.errors=自動建置完成但有錯誤
notification.compiler.auto.build.failure=自動建置失敗: {0}
notification.content.git.crlf.config=要使編譯器快取正常工作，您需要執行 <code>{0}</code> 指令並強制簽出專案
notification.content.internal.authentication.plugin.required.for.correct.work=必須具備 <a href="https://plugins.jetbrains.com/plugin/14567-jetbrains-internal-authentication">JetBrains Internal Authentication</a>，JPS 快取才能正常工作
notification.group.compiler=建置已完成
notification.group.title.jps.cannot.start.compiler=建置啟動失敗
notification.title.cpu.snapshot.build.has.been.captured=已捕獲建置 CPU 快照
notification.title.git.crlf.config=Git 行尾組態錯誤
notification.title.jps.caches.downloader=Jps 快取下載程序
notification.title.jps.cannot.start.compiler=無法啟動編譯器
only.works.while.not.running.debugging=(僅在不執行/不偵錯時工作)
option.use.compiler.text=使用編譯器:
packaging.element.text.output.root=<輸出根>
packaging.files=正在打包檔案
path.to.ecj.compiler.tool=ecj 編譯器工具的路徑
pattern.conversion.dialog.title=模式轉換
plugins.advertiser.feature.artifact=工件
popup.advertisement.debug.with.shift.navigate.with.f4=使用 {0} 偵錯，使用 F4 導覽
popup.title.affected.tests.counts=已在{2}{3, choice, 0#類別|1#類別}中為 {4} 找到 {0} 個{1, choice, 0#測試|1#測試}
popup.title.choose.suite.to.add=選擇要新增的套件
popup.title.chosen.artifact.action={0,choice,0#{0} 個工件|1#|2# {0} 個工件}的動作
popup.title.debug.recent.tests=偵錯最近的測試
popup.title.run.recent.tests=執行最近的測試
progress.compiling.class=編譯 {0}…
progress.executing.postcompile.tasks=執行後編譯任務…
progress.executing.precompile.tasks=執行預編譯任務…
progress.loading.classes=載入類別…
progress.parsing.file=解析 {0}…
progress.preparing.wsl.build.environment=正在準備 WSL 建置環境…
progress.text.clearing.build.system.data=正在清除建置系統資料…
progress.title.cancelling.running.builds=正在取消執行中的建置
progress.updating.caches=更新快取…
rebuild.lvcs.label.no.errors=''{0}''沒有錯誤
rebuild.lvcs.label.with.errors=''{0}''沒有錯誤
reference.projectsettings.compiler.annotationProcessors=註解處理器
reference.projectsettings.compiler.excludes=排除
refresh.compiler.ref.index=正在檢查建置最新狀態
rmi.compiler.description=RMI編譯器
rmic.option.enable.rmi.stubs=啟用RMI存根生成
rmic.option.generate.iiop.stubs=生成IIOP存根
select.directory.for.meta.inf.manifest.mf.file=為 META-INF/MANIFEST.MF 檔案選擇目錄
separator.choose.members.to.delete=<html>選擇已在 <b>{0}</b> 中定義的成員將其刪除
settings.actions.on.save.page.build.project.on.save.checkbox=建置專案
settings.actions.on.save.page.build.project.on.save.checkbox.comment=執行/偵錯時未觸發
settings.actions.on.save.page.compiler.settings.link=編譯器設定…
settings.additional.compilation.options=其他編譯選項也同樣適用於所有模組
settings.all.modules.will.be.compiled.with.project.bytecode.version=所有模組都將使用專案位元組碼版本進行編譯
settings.annotation.processing.proc.only=在編譯 java(-proc:only 模式)之前，在單獨的步驟中執行處理器 
settings.annotation.processor.options=註解處理器選項:
settings.annotation.processors=註解處理器:
settings.auto.build.only.works.while.not.running=(僅在不執行/不偵錯時工作)
settings.build.process.heap.size=共享建置程序堆大小(MB):
settings.build.project.automatically=自動建置專案
settings.column.option.name=選項名稱
settings.column.value=值
settings.compile.independent.modules.in.parallel=並行編譯獨立模組
settings.compiler.will.run.all.automatically.discovered.processors=編譯器將執行所有自動發現的處理器
settings.configure.annotations=組態註解(&C)…
settings.enable.annotation.processing=啟用註解處理
settings.exclude.from.validation=從驗證中排除:
settings.module.column=模組
settings.module.content.root=模組內容根
settings.module.output.directory=模組輸出目錄
settings.module.path.warning=假設指定的路徑是 'module path': JAR 或包含打包 java 模組的路徑。\n\
要確保被發現並從模組路徑執行，註解處理器應打包為 java 模組並使用模組宣告中的 ServiceLoader 註冊。
settings.no.processor.specific.options.configured=未組態處理器特定選項
settings.obtain.processors.from.project.classpath=從專案類別路徑獲取處理器
settings.override.compilation.options.column=編譯選項
settings.override.compiler.parameters.per.module=按模組覆寫編譯器參數:
settings.override.module.column=模組
settings.parallel.module.compile.may.require.larger.heap.size=(可能需要更大的堆)
settings.per.module.bytecode.version=按模組位元組碼版本:
settings.processor.fq.name=處理器 FQ 名稱
settings.processor.path=處理器路徑:
settings.production.sources.directory=生產源目錄:
settings.project.bytecode.version=專案位元組碼版本:
settings.rebuild.module.on.dependency.change=相依關係更改時重新建置模組
settings.recommended.in.paths=(建議在路徑中使用 '/' 進行跨平台組態)
settings.same.as.language.level=與語言級別相同
settings.shared.build.process.vm.options=共享建置過程虛擬機選項:
settings.store.generated.sources.relative.to=存儲相對於下列位置生成的源:
settings.target.bytecode.version=目標位元組碼版本
settings.test.sources.directory=測試源目錄:
settings.use.processor.module.path.compiler.option.for.java.9.and.later=使用 --processor-module-path 編譯器選項 (適用於 Java 9 及更高版本)
settings.use.release.option.for.cross.compilation=使用 '--release' 選項進行交叉編譯 (Java 9 及更高版本)
settings.user.local.build.process.heap.size=使用者本地建置程序堆大小(MB)(覆寫共享大小):
settings.user.local.build.process.vm.options=使用者本地建置過程虛擬機選項 (覆寫共享選項):
settings.validate.on.build=建置時驗證
settings.validators=驗證器:
settings.warning=<html>警告!<br>如果已啟用選項“重新建置時清除輸出目錄”，存儲生成源的目錄的全部內容將在重新建置時清除。</html>
shift.key=Shift
show.content.of.included.artifacts=顯示已包含工件的內容
show.library.files=顯示庫檔案
specify.path.to.manifest.mf.file=指定 MANIFEST.MF 檔案的路徑
status.all.up.to.date=所有檔案都處於最新狀態
status.compilation.aborted=編譯中止
status.compilation.completed.successfully=建置在 {0}內成功完成
status.compilation.completed.successfully.with.warnings=在 {1}內成功完成編譯，包含 {0} 個{0,choice, 0#警告|1#警告|2#警告}
status.compilation.completed.successfully.with.warnings.and.errors=在 {2}內成功完成編譯，包含 {0} 個{0,choice, 0#錯誤|1#錯誤|2#錯誤}和 {1} 個{1,choice, 0#警告|1#警告|2#警告}
status.text.file.has.been.packaged={0, choice, 1#檔案|2#檔案} {1} {0, choice, 1#已|2#已}在 {2} 打包。
synchronizing.output.directories=正在同步輸出目錄…
tab.title.thread.dump=傾印 {0}
test.discovery.parametrized=已參數化
test.discovery.show.affected.tests=顯示受影響的測試
test.discovery.tests.tab.title={0} 的測試
test.discovery.unused.test.data.tab.title=未使用的測試資料
text.empty.profile=組態檔名不應為空
text.profile.exists=組態檔案 {0} 已存在
title.create.new.profile=建立新的組態檔案
title.new.archive=新增歸檔
title.new.directory=新增目錄
unknown.artifact.properties.0=未知工件屬性: {0}
unknown.artifact.remove.confirmation=是否要移除工件 ''{0}''?
unknown.artifact.type.0=未知工件類型: {0}
unknown.build.process.error=未知錯誤
unknown.element.0=未知元素: {0}
validation.display.name=驗證
warning.compiler.running.on.toolwindow.close=編譯器正在執行。將其終止?
warning.text.file.has.been.changed=檔案在編譯期間已更改，跳過檢查驗證
whole.project=<整個專案>
wsl.network.connection.failure=無法建立從 WSL 到 Windows 主機的網絡連線(可能被防火牆阻止)。\n\
要了解詳細資訊，請參閱: https://jb.gg/wsl-firewall
you.are.about.to.rebuild.the.whole.project=您將重新建置整個專案。\n\
執行“建置專案”?