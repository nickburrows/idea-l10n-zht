action.AnActionButton.extract.style.text.select.all=取消全選
action.AnActionButton.extract.style.text.unselect.all=取消全選
action.AnActionButton.text.select.all=全選
action.AnActionButton.text.unselect.all=取消全選
action.AnActionButton.update.sites.text.deselect.all=取消全選
action.AnActionButton.update.sites.text.select.all=全選
action.Android.DeviceExplorer.GotoDatabaseFolder.text=導覽到資料庫目錄
action.Android.DeviceExplorer.GotoSdcardFolder.text=導覽到 SD 卡目錄
action.Android.DeviceExplorer.GotoSharedPrefsFolder.text=導覽到共享的偏好設定目錄
action.Android.DeviceExplorer.Help.text=開啟裝置資源管理器幫助
action.Android.ExportProjectZip.text=將專案匯出為 Zip 檔案…
action.Android.FixAndroidRunConfigurations.description=如果 Android 執行組態中缺少“Gradle-aware Make”啟動任務，請新增此任務
action.Android.FixAndroidRunConfigurations.text=修復 Android 執行組態
action.Android.RunAndroidAvdManager.description=開啟 Android 虛擬裝置 (AVD) 管理器，來管理仿真器映像和快照
action.Android.RunAndroidAvdManager.popup.text=開啟 AVD Manager
action.Android.RunAndroidAvdManager.text=AVD Manager
action.Android.RunAndroidAvdManager.toolbar.text=新增裝置定義…
action.AndroidAddRTLSupport.description=在可能的情況下新增從右到左(RTL)支援
action.AndroidAddRTLSupport.text=在可能的情況下新增 RTL 支援…
action.AndroidConnectDebuggerAction.description=將偵錯器附加到 Android 程序
action.AndroidConnectDebuggerAction.text=將偵錯器附加到 Android 程序
action.AndroidEnableInstantAppsSupport.description=為模組啟用免安裝套用支援
action.AndroidEnableInstantAppsSupport.text=啟用免安裝套用支援…
action.AndroidExtractAsIncludeAction.description=將一個或多個檢視提取到單獨的布局中
action.AndroidExtractAsIncludeAction.text=布局(_L)…
action.AndroidExtractStyleAction.description=從布局中拉取與樣式相關的特性，並將其作為新樣式提取
action.AndroidExtractStyleAction.text=樣式(_Y)…
action.AndroidFindStyleApplicationsAction.description=在可能的情況下，將特性取代為 Android 樣式參照
action.AndroidFindStyleApplicationsAction.text=在可能的情況下使用樣式(_W)…
action.AndroidInlineIncludeAction.description=內聯包含的 Android 布局
action.AndroidInlineIncludeAction.text=內聯布局(_L)…
action.AndroidInlineStyleReferenceAction.description=內聯 Android 樣式
action.AndroidInlineStyleReferenceAction.text=內聯樣式(_S)…
action.AndroidMigrateToAndroidxAction.description=遷移到 AndroidX 軟體套件名稱
action.AndroidMigrateToAndroidxAction.text=遷移到 AndroidX…
action.AndroidMigrateToAppCompatAction.description=將套用遷移到 AppCompat
action.AndroidMigrateToAppCompatAction.text=遷移到 AppCompat…
action.AndroidMigrateToResourceNamespacesAction.description=遷移到資源命名空間
action.AndroidMigrateToResourceNamespacesAction.text=遷移到資源命名空間…
action.AndroidModularizeAction.description=將類別及其關聯資源移到另一個模組
action.AndroidModularizeAction.text=模塊化…
action.AndroidUnusedResourceAction.description=移除未使用的資源
action.AndroidUnusedResourceAction.text=移除未使用的資源…
action.ConvertFromWebp.text=轉換為 PNG…
action.ConvertToWebp.text=轉換為 WebP…
action.DeviceAndSnapshotComboBox.text=選擇裝置
action.DumbAware.AbstractDependenciesPanel.text.add.dependency=新增相依項
action.DumbAware.ToolWindowHeader.text.hide=隱藏
action.IdeaNewProject.text=IDEA 新增專案…
action.InferAnnotations.text=推斷支援註解…
action.LayoutEditor.AddSampleData.description=新增新的資料範例檔案
action.LayoutEditor.AddSampleData.text=新增範例資料檔案
action.Project.CallGraph.text=上下文呼叫路徑
action.Project.InterproceduralThreadAnnotations.text=過程間執行緒註解檢查器
action.StatisticsViewer.text=顯示統計資訊檢視器
action.label.code.style.notification.disable=Disable notification
action.label.code.style.notification.open.settings=Open code style settings
action.label.open.project.structure=Open project structure
activity.class.not.specified.error=未指定 Activity 類別
activity.not.declared.in.manifest=Activity ''{0}'' 未在 AndroidManifest.xml 中宣告
add.dependency.intention.text=新增庫相依項
add.string.resource.intention.text=提取字串資源
android.9patch.creator.error=建立 9-Patch 檔案時出現意外錯誤: {0}
android.9patch.creator.error.title=建立 9-Patch 檔案
android.9patch.creator.save.title=另存為 .9.png
android.9patch.creator.title=建立 9-Patch 檔案…
android.9patch.file.type.description=Android 9-Patch
android.aapt.use.custom.package.name=重新命名清單包(&K):
android.apk.settings.title=資源打包
android.apk.sign.gradle.invalid.destination=該目標目錄不存在或不可寫
android.apk.sign.gradle.missing.destination=請為簽署的 {0} 指定目標目錄
android.apk.sign.gradle.missing.variants=請選擇要建置並簽署的建置變體
android.apk.sign.gradle.no.model=缺少 Gradle 專案資訊。請檢查 IDE 是否已成功將其狀態與 Gradle 專案模型同步。
android.apk.sign.gradle.no.variants=未定義建置變體
android.application.title=Android 應用程式
android.apt.settings.title=R.java 和 Manifest.java 檔案
android.as.wizard.welcome.dialog.title=Android Studio 安裝嚮導
android.autogeneration.notification.group=Android 自動生成
android.browse.instrumentation.class.dialog.title=選擇插樁類別
android.browse.test.class.dialog.title=選擇測試類別
android.cannot.create.dir.error=無法建立目錄{0}
android.cannot.create.file.error=無法建立檔案 {0}
android.cannot.create.new.key.error=無法建立新密鑰或密鑰庫
android.cannot.debug.noDebugPermissions=無法從裝置 {1} 上的模組 {0} 偵錯應用程式。\n此應用程式在清單中未啟用 ''debuggable'' 特性。\n如果您已在清單中手動設定該特性，請將其移除並讓 IDE 自動分配。\n如果您使用的是 Gradle，請確保您的當前變體可偵錯。
android.cannot.find.file.error=未找到檔案{0}
android.cannot.run.library.project.error=該模組不能是 Android 庫
android.compilation.error.apt.gen.not.specified=沒有為模組 {0} 指定 AAPT 目標目錄
android.compilation.error.manifest.not.found=[{0}] AndroidManifest.xml 檔案未找到。請檢視 Android facet 設定。
android.compilation.error.specify.platform=[{0}] Android SDK 未指定或無法解析
android.compile.messages.generating.r.java.content.name=正在生成源
android.complication.configuration.type.name=Wear OS 複雜功能
android.component.entry.point=Android 組件
android.confirm.password.label=確認(&C):
android.create.new.key.error.prefix=密鑰已建立，存在錯誤:
android.ddms.actions.layoutinspector.description=檢查所選視窗的布局
android.ddms.actions.layoutinspector.description.disabled=偵錯時檢查布局已停用
android.ddms.actions.layoutinspector.dumpdisplay.notification.failure=由於異常，檢索顯示列表資訊失敗: {0}
android.ddms.actions.layoutinspector.dumpdisplay.notification.nonode=檢索顯示列表資訊失敗，找不到目標節點。
android.ddms.actions.layoutinspector.dumpdisplay.notification.success=顯示寫入 logcat 的列表資訊。
android.ddms.actions.layoutinspector.menu.dump.display=傾印顯示列表
android.ddms.actions.layoutinspector.menu.show.bound=顯示布局邊界
android.ddms.actions.layoutinspector.notification.group=Layout Inspector
android.ddms.actions.layoutinspector.notification.title=Layout Inspector
android.ddms.actions.layoutinspector.title=Layout Inspector
android.ddms.actions.layoutinspector.title.legacy=舊版 Layout Inspector
android.ddms.actions.layoutinspector.update.notification.failure=無法從裝置更新圖片。
android.ddms.actions.layoutinspector.windowpicker=選擇視窗
android.ddms.actions.screenrecord=螢幕錄製
android.ddms.actions.screenrecord.description=錄製裝置螢幕的視訊
android.ddms.actions.screenshot=螢幕捕獲
android.ddms.actions.screenshot.copied.to.clipboard=圖片已複製到剪貼簿
android.ddms.actions.screenshot.description=從裝置獲取螢幕截圖
android.ddms.actions.screenshot.title=螢幕捕獲
android.ddms.actions.terminate.vm=終止應用程式
android.ddms.actions.terminate.vm.description=終止所選 Android 應用程式
android.ddms.nodevices=[none]
android.ddms.notification.layoutinspector.reboot.live.inspector=無法檢測到實時檢查服務。要啟用實時檢查，請重啟裝置。
android.ddms.screenrecord.options.ok.button.text=開始錄製
android.ddms.screenrecorder.options.bit.rate=比特率(Mbps):
android.ddms.screenrecorder.options.bit.rate.invalid=比特率必須為整數。
android.ddms.screenrecorder.options.info=<html>Screen Recorder 最多可以錄製 3 分鐘的裝置顯示器。</html>
android.ddms.screenrecorder.options.resolution=解析度(原生 %):
android.ddms.screenrecorder.options.show.taps=顯示點按
android.ddms.screenrecorder.options.show.taps.tooltip=顯示點按的視覺反饋
android.ddms.screenrecorder.options.use.emulator.recording=使用模擬器錄製(webm)
android.ddms.screenrecorder.options.use.emulator.recording.tooltip=使用 Emulator Recording API 進行錄製。如果未選中，將改用 ADB 錄製。
android.ddms.screenshot.generic.error=獲取螢幕截圖時出現意外錯誤: {0}
android.ddms.screenshot.image.processor.task.title=正在更新圖片
android.ddms.screenshot.save.error=儲存螢幕截圖時出現意外錯誤: {0}
android.ddms.screenshot.save.ok.button.text=儲存
android.ddms.screenshot.save.title=另存為 PNG
android.ddms.screenshot.task.error.invalid.bpp=從裝置接收到不支持的圖片(每像素位數 = {0})
android.ddms.screenshot.task.error1=從裝置獲取螢幕截圖時出現意外錯誤: {0}
android.ddms.screenshot.task.step.load=正在將螢幕截圖載入到記憶體中…
android.ddms.screenshot.task.step.obtain=正在從裝置獲取螢幕截圖…
android.dest.directory.title=生成檔案的目錄(&Y):
android.dex.compiler.vm.options.title=Android DX 編譯器虛擬機選項
android.dictionary.name=Android 字典
android.editor.settings.appearance.enable.flags.for.languages=啟用語言標誌
android.editor.settings.appearance.title=Android 編輯器
android.editor.settings.general.code.folding.string.references=字串參照
android.emulator=模擬器
android.emulator.settings.clipboard.sharing=啟用剪貼簿共享
android.emulator.settings.incompatible.snapshot.policy=遇到與當前組態不相容的快照時:
android.emulator.settings.incompatible.snapshot.policy.ask=刪除前詢問
android.emulator.settings.incompatible.snapshot.policy.delete=自動刪除
android.emulator.settings.incompatible.snapshot.policy.ignore=不刪除
android.emulator.settings.launch.tool.window=在工具視窗中啟動
android.emulator.settings.launch.tool.window.tooltip=啟用此設定將導致 Android 模擬器在工具視窗中啟動。否則，Android 模擬器將作為獨立應用程式啟動。
android.export.package.bundle.description=<html>生成簽署的套用 Bundle 以上傳到套用商店來獲得以下好處:<ul><li>更小的下載大小</li><li>按需套用功能</li><li>僅資產模組</li></ul></html>
android.export.package.bundle.gradle.error=生成簽署的 Bundle 需要您將 Android Gradle 延伸模組更新到 3.2.0 或更高版本。
android.export.package.bundle.key.export=匯出加密密鑰，將發佈的套用註冊在
android.export.package.bundle.key.export.error.description=無法匯出加密密鑰，請修正問題，然後重試。\n\n詳細資訊: {0}。
android.export.package.bundle.key.export.error.title=匯出加密密鑰失敗
android.export.package.city.label=城市或地區(&L):
android.export.package.country.code.label=國家/地區程式碼(XX)(&X):
android.export.package.destination.akp.label=目標 APK 路徑(&D):
android.export.package.incorrect.password.length=密碼必須至少為 6 個字元
android.export.package.key.certificate.name.label=名字和姓氏(&F):
android.export.package.key.validity.label=有效期(年)(&V):
android.export.package.keystore.error.title=密鑰庫載入錯誤
android.export.package.new.key.alias.label=別名(&A):
android.export.package.organization.label=組織(&R):
android.export.package.organization.unit.label=組織單位(&O):
android.export.package.passwords.cannot.contain.quote.character=密碼不得包含引號字元
android.export.package.passwords.not.match.error=密碼不符合
android.export.package.run.proguard.label=執行 ProGuard(&P)
android.export.package.specify.certificate.field.error=至少一個憑證頒發者欄位需要為非空
android.export.package.specify.key.alias.error=請指定鍵別名
android.export.package.specify.key.password.error=請指定密鑰的密碼
android.export.package.specify.key.store.password.error=請指定密鑰庫的密碼
android.export.package.specify.keystore.location.error=請指定密鑰庫位置
android.export.package.specify.password.error=請指定密碼
android.export.package.state.label=州或省(&T):
android.export.package.success.message=已成功建立檔案 {0}
android.export.package.wizard.bundle.title=生成簽署的 Bundle 或 APK
android.export.package.wizard.title=正在已簽名的 APK
android.extended.device.chooser.avd.label=Android Virtual Device(&A):
android.extract.package.cannot.find.key.error=找不到密鑰 {0}
android.extract.package.choose.dest.apk=選擇目標 APK 檔案
android.extract.package.choose.keystore.title=選擇密鑰庫檔案
android.extract.package.error.0.message=錯誤: {0}
android.extract.package.specify.apk.path.error=請指定目標 APK 路徑
android.extract.package.specify.proguard.cfg.path.error=請指定 ProGuard 組態檔案路徑
android.extract.package.task.title=生成 APK 檔案
android.extract.style.title=提取 Android 樣式
android.facet.editor.is.library.checkbox=庫模組(&B)
android.facet.importing.notification.group=匯入錯誤
android.facet.importing.title=匯入模組 ''{0}'' 時出錯
android.facet.not.editable.text=無法編輯此 facet，因為它自動建立。僅可編輯手動建立的 Android facet。
android.facet.settings.apk.path.label=APK 路徑(&P):
android.facet.settings.compile.resources.by.ide=通過 IDE 生成(&G)
android.facet.settings.custom.debug.keystore.label=自訂偵錯密鑰庫(&U):
android.facet.settings.pack.test.sources=將測試程式碼和資源包含到 APK 中
android.facet.settings.run.proguard=建置偵錯 APK 時執行 ProGuard
android.file.not.exist.error=檔案{0}不存在
android.final.package.element.type.name=Android 最終軟體套件
android.find.style.applications.title=盡可能使用樣式
android.font.file.type.description=字體
android.generate.r.java.by.res.dir=使用在“結構”部分中指定的資源目錄(&O)
android.generate.signed.apk.action.bundle.text=生成已簽名的捆綁包/APK…
android.generate.signed.apk.action.text=生成已簽名的 APK…
android.gradle.link.appengine.outdated=更新 'appengine' 延伸模組版本。
android.ij.wizard.welcome.dialog.title=Android Support 延伸模組安裝嚮導
android.import.dependencies.add.module.dependency.task.title=新增相依關係 {0} --> {1}
android.import.dependencies.dialog.title=從屬性檔案匯入 Android 相依項
android.import.dependencies.error.message.header=匯入完成，但有錯誤:
android.import.dependencies.import.module.task.title=從 {1} 匯入庫模組 {0}
android.import.dependencies.new.module.task.title=在 {1} 中建立庫模組 {0}
android.import.dependencies.source.roots.dialog.label=選擇要新增到專案的來源根
android.import.dependencies.source.roots.dialog.title=匯入來源根
android.inline.file.inline.all.text=內聯所有參照並移除檔案(&A)
android.inline.file.inline.this.text=內聯此用法並保留檔案(&T)
android.inline.layout.command.name=內聯布局檔案 ''{0}''
android.inline.layout.title=內聯 Android 布局
android.inline.style.command.name=內聯樣式 ''{0}''
android.inline.style.inline.all.text=內聯所有參照並移除樣式(&A)
android.inline.style.inline.this.text=內聯此用法並保留樣式(&T)
android.inline.style.title=內聯 Android 樣式
android.inspections.dom.name=Android 資源驗證
android.inspections.element.not.allowed.name=不允許 Android XML 元素
android.inspections.group.name=Android
android.inspections.nav.file=導覽檔案
android.inspections.nav.name.not.valid=''{0}'' 不是標記 ''{1}'' 的有效目標
android.inspections.non.constant.res.ids.in.switch.message=資源 ID 不能在 Android 庫模組的 switch 語句中使用
android.inspections.non.constant.res.ids.in.switch.name=switch 語句中存在非常數資源 ID
android.inspections.on.click.missing.incorrect.signature=''{1}'' 中方法 ''{0}'' 的簽名不正確
android.inspections.on.click.missing.name=相關 Activity 中缺少 onClick 處理程序
android.inspections.on.click.missing.problem=方法 ''{0}'' 在 ''{1}'' 中缺失或簽名不正確
android.inspections.root.tag.name=Android XML 根標記驗證
android.inspections.unknown.attribute.message=未知特性 {0}
android.inspections.unknown.attribute.name=未知 Android XML 特性
android.inspections.unresolvable.tag=不可解析的標記
android.invalid.sdk.message=您的 Android SDK 路徑無效。請在 <a href="#">Settings</a> 中進行更新。
android.key.password.label=密碼(&S):
android.launch.task.clear.app.data.description=清除套用存儲
android.launch.task.clear.app.data.error=無法清除裝置 {1} 上 {0} 的套用存儲
android.launch.task.show.logcat=開啟 {0} 的 logcat 面板\n
android.launch.task.show.logcat.emulator=模擬器 {0}
android.launch.task.show.logcat.unknown.avd=未知 AVD 名稱
android.launch.task.show.logcat.unknown.manufacturer=未知制造商
android.launch.task.show.logcat.unknown.model=未知模型
android.launch.task.show.logcat.unknown.version=未知版本
android.launch.task.succeeded={0}已成功
android.launch.task.succeeded.with.warnings={0}已成功，有 {1} 個警告
android.layout.preview.default.error.message=無法執行渲染
android.layout.preview.edit.configuration.available.qualifiers.label=可用的限定符(&V):
android.layout.preview.edit.configuration.choosen.qualifiers.label=選擇的限定符(&H):
android.layout.screenview.action.description=Show {0} 圖面
android.manifest.merger.not.supported.error=不支持清單合併。請重新組態清單檔案
android.new.component.action.command.name=新增 Android 組件
android.new.component.action.description=從“其他”類別建立新的 Android 物件
android.new.component.action.title.non.gradle=Android 組件
android.new.component.dialog.activity.item=Activity
android.new.component.dialog.application.item=應用程式
android.new.component.dialog.broadcast.receiver.item=廣播接收器
android.new.component.dialog.broadcast.remote.interface=遠端接口
android.new.component.dialog.fragment.item=Fragment
android.new.component.dialog.service.item=服務
android.progress.title.setting.up.run.configurations=Setting up run configurations...
android.proguard.vm.options.title=Android ProGuard 虛擬機選項
android.proxy.settings.dialog.message=<html>{0} 組態為使用 HTTP 代理。Gradle 可能需要進行這些 HTTP 代理設定才能存取 Internet(例如下載相依項。)<br/><br/>是否要將以下 HTTP 設定存儲到全域 gradle.properties 檔案?<br/><br/><b>注意: </b>您可以在 gradle.properties 檔案中手動設定密碼，但要自擔風險。<br/><br/>有關更多詳細資訊，請參閱 <a href=''https://developer.android.com/studio/intro/studio-config.html#proxy''>Android Studio 文檔</a>。<br/><br/>
android.proxy.settings.dialog.title=代理設定
android.psd.file.type.description=Adobe Photoshop 圖片
android.refactoring.gradle.warning.rename.source.root=新的來源根名稱不會自動傳播<br/>到 Gradle 組態。<br/>您需要在 *.gradle 檔案中手動進行相應<br/>更改。
android.refactoring.migrateto.androidx=遷移到 AndroidX
android.refactoring.migrateto.namespaces.progress.analyze.code=正在分析程式碼檔案…
android.refactoring.migrateto.namespaces.progress.analyze.manifest=正在分析清單檔案…
android.refactoring.migrateto.namespaces.progress.analyze.xml=正在分析 XML 資源檔案…
android.refactoring.migrateto.namespaces.progress.inferring=正在推斷命名空間…
android.refactoring.migrateto.namespaces.title=遷移到資源命名空間…
android.refactoring.migrateto.nontransitiverclass.error.old.agp.message=不可傳遞的 R 類別不適用於使用低於 4.2.0 版本的 Android Gradle 延伸模組的專案
android.refactoring.migrateto.nontransitiverclass.error.old.agp.title=無法執行重構
android.refactoring.migrateto.nontransitiverclass.progress.findusages=正在尋找 R 類別用法…
android.refactoring.migrateto.nontransitiverclass.progress.inferring=正在推斷軟體套件名稱…
android.refactoring.migrateto.nontransitiverclass.progress.rewriting=正在覆寫資源參照…
android.refactoring.migrateto.nontransitiverclass.title=遷移到不可傳遞的 R 類別…
android.refactoring.migrateto.nontransitiverclass.warning.recommend.upgrade=此功能在 AGP 4.2 版本中為實驗性功能，升級到 7.0.0 或更新版本可獲得最佳結果。
android.refactoring.migrateto.nontransitiverclass.warning.uncommitted.changes=專案可能包含未提交的更改。在繼續之前，您應該提交或恢復這些更改。
android.refactoring.migrateto.resourceview.header=要遷移的資源參照
android.refactoring.migratetoappcompat=遷移到 AppCompat
android.refactoring.rtl.addsupport.dialog.apply.button.text=按搜尋結果面板底部的“執行 RTL 重構”按鈕，以進行從右到左(RTL)重構
android.refactoring.rtl.addsupport.dialog.label.text=此重構將向您的 Android 套用新增 RTL 支援。\n\n請檢查以下選項:\n
android.refactoring.rtl.addsupport.dialog.ok.button.text=執行
android.refactoring.rtl.addsupport.dialog.option.label.layouts.options.generate.v17.txt=生成 -v17 版本
android.refactoring.rtl.addsupport.dialog.option.label.layouts.options.replace.leftright.txt=用開始/結束屬性取代左/右屬性
android.refactoring.rtl.addsupport.dialog.option.label.layouts.options.txt=布局選項
android.refactoring.rtl.addsupport.dialog.option.label.update.layouts.text=更新布局檔案
android.refactoring.rtl.addsupport.dialog.option.label.update.manifest.text=更新 AndroidManifest.xml
android.refactoring.rtl.addsupport.dialog.title=新增從右到左(RTL)支援…
android.refactoring.rtl.addsupport.title=新增從右到左(RTL)支援
android.run.configuration.all.in.module.radio=模組中的所有(&A)
android.run.configuration.all.in.package.radio=軟體套件中的所有(&I)
android.run.configuration.class.label=類別(&L)
android.run.configuration.class.radio=類別(&S)
android.run.configuration.complication=複雜功能資料來源
android.run.configuration.debug.surface.warn=警告: 如果背景服務的響應時間過長，所選 Wear 裝置可能會終止背景服務，這可能會影響偵錯。為了避免這種情況，請將裝置端 Wear OS 配套套用更新到最新版本。
android.run.configuration.general.tab.title=一般
android.run.configuration.loading=正在載入…
android.run.configuration.logcat.skip.content.label=啟動前清除日誌(&C)
android.run.configuration.method.label=方法(&T)
android.run.configuration.method.radio=方法(&E)
android.run.configuration.misc.tab.title=雜項
android.run.configuration.module.label=模組:
android.run.configuration.not.supported=當前專案不支持執行組態 {0}。無法獲取 APK 檔案的位置。
android.run.configuration.not.supported.applicationid=當前專案不支持執行組態 {0}。無法獲取應用程式 ID。
android.run.configuration.not.supported.package=當前專案中不支持執行組態 {0}。無法獲取軟體套件。
android.run.configuration.package.label=包(&K)
android.run.configuration.run=執行 {0}
android.run.configuration.tile=磁貼
android.run.configuration.type.description=Android 啟動/偵錯組態
android.run.configuration.type.name=Android 套用
android.run.configuration.watchface=表盤
android.run.configuration.wear.version.affects.debugging=警告: 執行 API 級別 26 及以下級別的 Wear 裝置如果響應時間過長，可能會終止背景服務，這可能會影響偵錯。要避免這種情況，請使用執行 API 級別 28 或更高級別的裝置。
android.run.sdk.manager.action.text=SDK 管理器
android.safeargs.fix.import=匯入
android.sdk.configure.jdk.error=請組態內部 JDK
android.sdk.manager.installer.install.error=請求的動作未成功完成。有關詳細資訊，請參閱 IDE 日誌。
android.sdk.manager.installer.install.finished=請等待請求的動作完成。
android.sdk.manager.installer.panel.description=正在完成請求的動作
android.sdk.manager.installer.panel.title=SDK 組件安裝程序
android.sdk.missing.msg=您的 Android SDK 缺失、過期或損壞。
android.sdk.missing.title=SDK 問題
android.sdk.not.configured.notification=Android SDK is not configured for module ''{0}'' or corrupted
android.sdk.open.manager=開啟 SDK 管理器
android.sdk.presentable.name=Android SDK
android.streaming.notification.title=正在執行裝置訊息
android.suggested.dependency.action.family.name=新增庫相依項
android.suggested.dependency.action.name.prefix=新增對 {0} 的相依關係
android.suggested.import.action.family.name=新增庫相依關係並匯入
android.suggested.import.action.name.prefix=新增對 {0} 的相依關係並匯入
android.suggested.imports.title=建議的匯入
android.test.run.configuration.instrumentation.label=插樁類別:
android.test.run.configuration.type.description=Android Instrumented Tests 組態
android.test.run.configuration.type.name=Android Instrumented Tests
android.tile.configuration.type.name=Wear OS 磁貼
android.update.project.properties.dialog.text=以下 Android 模組的結構已被更改:<br>{0}<br>是否要更新相關的 project.properties 檔案?<br><a href="once">僅一次</a><br><a href="always">始終更新這些模組的檔案</a><br><a href="never">永不更新這些模組的檔案</a>
android.update.project.properties.dialog.title=更新屬性檔案
android.usageGroup.properties.new.flag=要新增的屬性標誌: {0}
android.usageGroup.resource.references.from.package=對 {0} 中定義的資源的參照
android.usageType.gradle.build.script=在 Gradle 建置腳本中
android.usageType.gradle.properties.file=Gradle 屬性檔案
android.usageType.manifest=在 Android 清單中
android.usageType.permission.reference.code=程式碼中的權限參照
android.usageType.resource.declaration.xml=Android 資源 XML 中的資源宣告
android.usageType.resource.file=Android 資源檔案
android.usageType.resource.reference.code=程式碼中的資源參照
android.usageType.resource.reference.xml=Android 資源 XML 中的資源參照
android.use.custom.r.java.source.dir=使用自訂資源目錄(&M):
android.watchface.configuration.type.name=Wear OS 表盤
android.wizard.action.new.component=建立新的 {0}
android.wizard.action.requires.aidlEnabled={0} (需要在建置檔案中將 buildFeatures.aidl 設定為 true)
android.wizard.action.requires.androidx={0} (需要 AndroidX 支援)
android.wizard.action.requires.minsdk={0} (需要 minSdk >= {1})
android.wizard.action.requires.new.agp={0} (需要 Android Gradle 延伸模組 {1} 或更新版本)
android.wizard.activity.add=將 Activity 新增到 {0}
android.wizard.activity.add.cpp.docslinktext=請參閱文檔
android.wizard.activity.invalid.androidx=所選 Activity 模板要求專案具有 androidx.* 相依項。
android.wizard.activity.invalid.min.sdk=所選 Activity 模板的最低 SDK 級別為 {0}。
android.wizard.activity.invalid.needs.kotlin=所選活動模板需要 Kotlin。
android.wizard.activity.not.found=未選擇 Activity 模板
android.wizard.buildConfigurationLanguage.combo.tooltip=用於建置腳本的建置組態語言
android.wizard.config.activity.title=組態 Activity
android.wizard.config.component.title=組態組件
android.wizard.config.fragment.title=組態 Fragment
android.wizard.cppStandard.combo.tooltip=用於原生模組的 C++ 標準
android.wizard.fragment.add=將 Fragment 新增到 {0}
android.wizard.fragment.invalid.androidx=所選片段模板要求專案具有 androidx.* 相依項。
android.wizard.fragment.invalid.min.sdk=所選 Fragment 模板的最低 SDK 級別為 {0}。
android.wizard.fragment.invalid.needs.kotlin=所選片段模組需要 Kotlin。
android.wizard.fragment.not.found=未選擇 Fragment 模板
android.wizard.language.combo.empty=(選擇語言)
android.wizard.language.combo.header=源語言
android.wizard.language.combo.tooltip=用於程式碼生成的編程語言
android.wizard.module.config.new.base.missing=<No Base Module found>
android.wizard.module.config.title=組態您的模組
android.wizard.module.description=Android 模組用於開發要在 <b>Android</b> 作業系統上執行的套用。<br><b>Android</b> 模組包括一個或多個<b>動作組件</b>且可能支援一些機型，<br>包括<b>手機與平板電腦</b>、<b>Wear</b> 和 <b>Android Auto</b>。
android.wizard.module.enable.instant=啟用免安裝套用支援
android.wizard.module.help.baselineprofiles.target.module.description=選擇您想要生成基線組態檔案的應用程式
android.wizard.module.help.baselineprofiles.usegmd.description=Gradle 托管裝置可以自動建立、啟動和停止模擬器。如果未選中，您將需要在使用此產生器之前手動啟動模擬器或裝置。
android.wizard.module.help.benchmark.module.type=要執行的基準測試類型。如需了解詳情，請參閱 https://d.android.com/benchmark。\n\nMicrobenchmark - 衡量要最佳化的小段程式碼的 CPU 性能和分配。\n\nMacrobenchmark - 衡量和檢查套用的啟動和滾動性能。
android.wizard.module.help.benchmark.target.module=選擇您想要進行基準測試的應用程式
android.wizard.module.help.buildconfigurationlanguage.description=組態建置腳本以建置模組
android.wizard.module.help.choose=幫助我選擇
android.wizard.module.help.loading=載入
android.wizard.module.help.name=要將模組放置在子目錄中，請使用語法: :subfolder:module_name，例如 :libraries:lib1
android.wizard.module.help.refreshing=正在載入統計資訊…
android.wizard.module.import.eclipse.title=匯入 Eclipse ADT 專案
android.wizard.module.import.gradle.description=將現有 Gradle 專案作為模組匯入
android.wizard.module.import.gradle.title=匯入 Gradle 專案
android.wizard.module.import.source.browse.bad.modules.1=找不到子專案 %1$s 的源。\n這可能導致缺少相依項。
android.wizard.module.import.source.browse.bad.modules.2=找不到子專案 %1$s 和 %2$s 的源。\n這可能導致缺少相依項。
android.wizard.module.import.source.browse.bad.modules.more=找不到 %1$s 和其他 %2$d 個子專案的源。\n這可能導致缺少相依項。
android.wizard.module.import.source.browse.cant.import=指定 Gradle 或 Android Eclipse 專案的位置
android.wizard.module.import.source.browse.description=選擇要作為新的子專案匯入的現有 ADT 或 Gradle 專案
android.wizard.module.import.source.browse.error=內部錯誤，請檢查 IDE 日誌
android.wizard.module.import.source.browse.invalid.location=路徑不存在
android.wizard.module.import.source.browse.taken.location=此位置已匯入
android.wizard.module.import.source.browse.title=選擇源位置
android.wizard.module.import.source.title=從源中匯入模組
android.wizard.module.new.automotive=Automotive
android.wizard.module.new.automotive.description=建立新的 Android Automotive 模組。
android.wizard.module.new.baselineprofiles.module.app=基線組態檔案
android.wizard.module.new.baselineprofiles.module.description=建立用於生成基線組態檔案的模組。
android.wizard.module.new.benchmark.module.app=基準
android.wizard.module.new.benchmark.module.description=建立新的基準模組。
android.wizard.module.new.dynamic.download.options=模組下載選項
android.wizard.module.new.dynamic.module=動態功能
android.wizard.module.new.dynamic.module.description=建立可以動態傳遞的新 Android App Bundle 模組。
android.wizard.module.new.dynamic.module.instant=免安裝的動態功能
android.wizard.module.new.dynamic.module.instant.description=建立一個將作為免安裝套用傳遞的新 Android 模組。
android.wizard.module.new.dynamic.select.base=請選擇一個專案基礎模組
android.wizard.module.new.google.cloud=Google Cloud
android.wizard.module.new.java.or.kotlin.library=Java 或 Kotlin 庫
android.wizard.module.new.java.or.kotlin.library.description=建立新的 Java 或 Kotlin 庫。
android.wizard.module.new.library=Android 庫
android.wizard.module.new.library.description=建立新 Android 庫。
android.wizard.module.new.mobile=手機與平板電腦
android.wizard.module.new.mobile.description=建立新的 Android 手機和平板電腦模組。
android.wizard.module.new.module.header=選擇模組類型
android.wizard.module.new.module.menu=新增模組…
android.wizard.module.new.module.menu.description=向專案新增一個新模組
android.wizard.module.new.module.title=建立新的模組
android.wizard.module.new.native.library=Android 原生庫
android.wizard.module.new.native.library.description=建立新的 Android 原生庫。
android.wizard.module.new.tv=電視
android.wizard.module.new.tv.description=建立新的 Android TV 模組。
android.wizard.module.new.wear=Wear OS
android.wizard.module.new.wear.description=建立新的 Wear OS 模組。
android.wizard.module.package.too.long=軟體套件名稱過長
android.wizard.module.presentable.name=Android
android.wizard.module.will.not.use.version.catalog=新模組將不使用版本目錄資訊
android.wizard.new.activity.title=新增 Android Activity
android.wizard.new.component.title=新增 Android 組件
android.wizard.new.fragment.title=新增 Android Fragment
android.wizard.project.create.error=新增專案嚮導中出錯
android.wizard.project.help.buildconfigurationlanguage.description=組態建置腳本以建置模組，以及是否使用 Gradle 版本目錄進行了組態
android.wizard.project.loading.sdks=正在尋找可供下載的 SDK…
android.wizard.project.loading.stats.fail=無法載入統計資訊。值可能已過期。
android.wizard.project.new.choose=選擇專案模板
android.wizard.project.new.configure=組態您的專案
android.wizard.validate.empty.application.name=請輸入應用程式名稱 (在啟動器中顯示) 或庫的描述性名稱
android.wizard.validate.empty.module.name=請輸入有效的模組名稱
android.wizard.validate.invalid.class.name=請輸入有效的類別名
android.wizard.validate.lowercase.application.name=大多數套用的應用程式名稱以大寫字母開頭
android.wizard.validate.module.already.exists=模組“{0}”已存在
android.wizard.validate.module.illegal.character=模組名稱 ''{1}'' 中存在非法字元 ''{0}''
android.wizard.validate.module.needs.androidx=專案需要轉換為 androidx.* 相依項
android.wizard.validate.module.needs.new.agp=組合需要 Android Gradle 延伸模組 {0} 或更新版本
android.wizard.validate.module.needs.new.agp.baseline.profiles=基線組態檔案需要 Android Gradle 延伸模組 {0} 或更新版本
android.wizard.validate.module.needs.new.agp.kts=Kts 需要 Android Gradle 延伸模組 {0} 或更新版本
android.wizard.validate.module.needs.new.agp.macro.benchmark=宏基准測試需要 Android Gradle 延伸模組 {0} 或更新版本
android.wizard.validate.project.illegal.character=專案名稱 ''{1}'' 中存在非法字元 ''{0}''
android.wizard.validate.select.compose.sdk=Compose 需要安裝 Android SDK 31 或更新版本
android.wizard.validate.select.language=請選擇語言
android.xml.code.style.notification=You can format your XML resources in the 'standard' Android way. Choose 'Set from... | Android' in the XML code style settings.
assert.level.title=斷言
avd.manager.arm.images=ARM 鏡像
avd.manager.x86.images=x86 鏡像
cannot.find.testcase.error=找不到 junit.framework.TestCase 類別
cannot.parse.sdk.error=無法解析 Android SDK
cannot.resolve.color.literal.error=無法解析顏色 ''{0}''
cannot.resolve.flag.error=無法解析標誌
cannot.resolve.float.literal.error=無法解析浮點數 ''{0}''
cannot.resolve.format.error=無法解析格式
cant.find.activity.class.error=找不到 android.app.Activity 類別
cant.find.class.error=找不到 {0} 類別
check.resource.dir.error=找不到模組 {0} 的資源目錄
checkbox.disable.sdk.diff.patching=停用 SDK 差異修補
checkbox.force.https.sources=使用 http://... 強制要提取的 https://... 源
checkbox.group.tags.with.the.same.name=具有相同名稱的組標籤
checkbox.hide.obsolete.packages=隱藏過時軟體套件
checkbox.insert.line.breaks.around.style.declaration=在樣式宣告周圍插入換行符
checkbox.show.package.details=顯示軟體套件詳細資訊
checkbox.use.custom.formatting.settings.for.android.xml.files=對 Android XML 檔案使用自訂格式設定
checkbox.use.same.device.for.future.launches=將同一裝置用於未來啟動
choose.device.dialog.title=選擇部署目標
compose.feature.in.non-canary.message=<html>Jetpack Compose 是一項預覽功能，僅 Canary 版本的 Android Studio 中包含對 Compose 的支援。要在您的套用專案中使用 Compose，請下載並安裝 IDE 的最新 <a href="https://developer.android.com/studio/preview"> Canary 版本</a>。</html>
compose.feature.in.non-canary.title=Jetpack Compose 功能不受支援
configurable.AndroidConfigurations.displayName=Android 組態
configurable.AndroidFacetEditorTab.display.name=Android SDK 設定
configurable.AndroidProjectStructureConfigurableForIdea.display.name=Android 專案結構
configurable.AndroidProjectStructureConfigurableForIdea.redirect.text=請使用 <a>Android 專案結構</a>組態頁面。
configurable.AndroidTestingConfigurable.displayName=測試
configurable.DeploymentConfigurable.display.name=部署
configurable.ExperimentalSettingsConfigurable.display.name=實驗性
configurable.GradleFacetEditorTab.display.name=Android Gradle 模組設定
configurable.IdeSdksConfigurable.display.name=SDK 位置
configurable.MemorySettingsConfigurable.display.name=記憶體設定
configurable.ProfilingConfigurable.display.name=CPU 記錄組態
configurable.SdkUpdaterConfigurable.display.name=Android SDK
configurable.group.android.settings.display.name=Android
configurable.group.build.android.settings.description=<html><body>使用 Android 建置工具組態專案整合。
configurable.group.tools.android.settings.description=<html><body>Configure the Android tools settings.
connection.assistant.adb.devices=檢測到至少一台 Android 裝置。
connection.assistant.adb.failure=找不到 ADB。
connection.assistant.adb.no_devices.body=
connection.assistant.adb.no_devices.title=未檢測到 Android 裝置。
connection.assistant.adb.unexpected=出現意外錯誤，請提交錯誤。
connection.assistant.loading=正在載入…
connection.assistant.usb.no_devices.body=
connection.assistant.usb.no_devices.title=未檢測到 USB 裝置
copy.resources.from.artifacts.setting=在 Make 之前執行“process-resources”Maven 任務(&U)
create.file.resource.intention.name=建立 {0} 資源檔案 ''{1}''
create.file.resource.quickfix.name=在 {1} 中建立資源檔案 ''{0}''
create.on.click.handler.intention.text=建立 onClick 事件處理程序
create.value.resource.intention.name=建立 {0} 值資源 ''{1}''
create.value.resource.quickfix.name=在 ''{1}'' 中建立值資源 ''{0}''
ddms.corrupted.error=警告: 偵錯資訊可能不可用。請使用 ADB 關閉其他應用程式: Monitor、DDMS、Eclipse
debug.level.title=偵錯
default.activity.not.found.error=找不到預設 Activity
deployment.failed.no.certificates.explanation=由於 APK 未簽署或簽署不正確，安裝失敗。\n如果這是基於 Gradle 的專案，請確保在 Gradle 建置腳本中指定了簽署組態。
deployment.failed.reason.devicedisconnected=安裝失敗，因為裝置“{0}”已斷開連線。
deployment.failed.reason.dexopt=該裝置可能具有與當前版本不符合的過時的 dex jar (dexopt 錯誤)
deployment.failed.reason.different.signature=該裝置已經具有一個軟體套件相同但簽名不同的應用程式
deployment.failed.reason.oldersdk=由於套用的 minSdkVersion 比裝置的 API 級別({0})更新，安裝失敗。\n請更新您套用的 minSdkVersion。
deployment.failed.reason.version.downgrade=該裝置已具有此套用程序的較新版本
deployment.failed.splitapk.nomatch=當前選擇的變體“{0}”使用拆分 APK，但 {1} 個拆分 APK 均不與 ABI 為“{2}”的當前裝置相容。
deployment.failed.title=應用程式安裝失敗
deployment.failed.uninstall.prompt.androidthings.errortext=無法解除安裝以下軟體套件：\n{0}
deployment.failed.uninstall.prompt.androidthings.text=您的 APK 和其他已安裝的軟體套件的意圖是 IOT_LAUNCHER。一次只能安裝一個具有該意圖的 APK。安裝 APK 之前，請嘗試解除安裝這些軟體套件。\n\n警告：解除安裝將移除應用數據！\n\n您要解除安裝以下應用嗎？\n{0}
deployment.failed.uninstall.prompt.generic.text=安裝失敗，消息 {0}。\n可以通過解除安裝 APK 的現有版本(如果有)來解決此問題，然後重新安裝。\n\n警告：解除安裝將移除應用數據！\n\n要解除安裝現有的應用嗎？
deployment.failed.uninstall.prompt.text=自 {0} 起安裝失敗。\n要繼續，您必須解除安裝現有的應用。\n\n警告：解除安裝將移除應用數據!\n\n要解除安裝現有的應用嗎？
deployment.target.not.found=找不到目標裝置。
directory.not.specified.error=未指定目錄
do.not.ask.for.this.session=不再要求此會話
downloading.android.plugin.components=正在下載 Android 延伸模組組件
element.cannot.resolve=無法解析類別 {0}
error.file.download.failed=無法下載 ''{0}'':\n{1}
error.level.title=錯誤
error.report.at.b.android=<html>提交反饋時出錯: {0}<br>考慮在 <a href="https://code.google.com/p/android/issues/list">Android 問題追蹤器</a>中建立問題</html>
error.report.to.google.action=報告給 Google(&R)
exportable.AndroidFoldingSettings.presentable.name=Android 程式碼折疊
extract.dimension.intention.text=提取尺寸資源
feedback.notifications.title=感謝您的反饋!
file.must.be.under.module.error=無法計算 {0} 的相對路徑
file.name.not.specified.error=未指定檔名
group.Android.CreateResourcesActionGroup.text=Android 資源檔案
group.Android.InstantRunActions.text=Instant Run
group.Android.MainToolbarRight.text=Android 主工具列靠右
group.AndroidToolsGroup.text=Android
group.Internal.Android.text=Android
heap.dump.analysis.exception=堆傾印分析時出錯。有關詳細資訊，請參閱 idea.log。
heap.dump.analysis.notification.action.title=審閱報告
heap.dump.analysis.notification.ready.content=分析完成。
heap.dump.analysis.notification.submit.error.content=提交報告時出錯。請參見 idea.log 了解詳細資訊。
heap.dump.analysis.notification.submitted.content=感謝您提交報告。
heap.dump.analysis.notification.title=記憶體使用報告
heap.dump.analysis.report.dialog.action.dont.send=不發送
heap.dump.analysis.report.dialog.action.send=發送
heap.dump.analysis.report.dialog.footer=提交此報告，即表明您允許 Google 根據 <a href="http://www.google.com/policies/privacy/">Google 的隱私政策</a>收集和處理此資料。
heap.dump.analysis.report.dialog.header=<html>{0} 檢測到異常高的記憶體使用。<br>您可以將以下記憶體使用報告發送到 Google，幫助團隊調查問題的根源。
heap.dump.analysis.report.dialog.title=記憶體使用報告
heap.dump.analysis.task.title=正在準備記憶體報告
heap.dump.snapshot.already.pending=記憶體報告已掛起。重啟 {0} 以開始分析。
heap.dump.snapshot.created=已在 {0} 建立堆傾印。下次您啟動時 {1} 會對它進行分析。
heap.dump.snapshot.created.no.analysis=已在 {0} 建立堆傾印。
heap.dump.snapshot.error.check.log=建立堆傾印時出錯。請檢查 idea.log 了解詳細資訊。
heap.dump.snapshot.exception=建立堆傾印時出錯。有關詳細資訊，請參閱 idea.log。
heap.dump.snapshot.indicator.low.memory.text=檢測到記憶體不足。正在捕獲 {0} 堆傾印
heap.dump.snapshot.indicator.text=正在捕獲 {0} 堆傾印
heap.dump.snapshot.no.space=空間不足，無法在 {0} 建立堆傾印。堆傾印所需的估計大小: {1}MB，但只有 {2}MB 可用。
heap.dump.snapshot.restart.dialog.message=堆傾印分析需要重啟 {0}。要立即重啟嗎?
heap.dump.snapshot.restart.dialog.restart.later=稍後重啟
heap.dump.snapshot.restart.dialog.restart.now=立即重啟
heap.dump.snapshot.restart.dialog.title=確認重啟
heap.dump.snapshot.task.title=正在捕獲堆傾印
heap.dump.snapshot.title=捕獲堆傾印
implement.parcelable.intention.text=新增 Parcelable 實作
info.level.title=資訊
label.android.sdk.location=Android SDK 位置:
label.below.are.the.available.sdk=<html>以下為可用的 SDK 開發者工具。安裝後，IDE 將自動檢查更新。選中“顯示包詳細資訊”以顯示 SDK 工具的可用版本。</html>
label.download.location=下載位置
label.each.android.sdk.platform.package=<html>每個 Android SDK 平台軟體套件預設都包含 Android 平台以及與 API 級別有關的源。安裝後，IDE 將自動檢查更新。選中“顯示軟體套件詳細資訊”可顯示各個 SDK 組件。</html>
label.loading.sources=正在載入源…
label.looking.for.updates=正在尋找更新…
label.manager.for.the.android.sdk=IDE 使用的 Android SDK 和工具的管理器
label.sdk.location.must.be.set=必須設定 SDK 位置
label.these.are.the.sites=<html>這些是檢查 Android SDK 更新和工具的站點。如果未選中，SDK 管理器將不會檢查站點有無更新。通過新增其他附加組件更新站點可以新增新的附加組件或其他 SDK 軟體套件。</html>
live.edit=Live Edit
live.edit.action.disable.title=停用 Live Edit
live.edit.action.enable.title=啟用 Live Edit
live.edit.advanced.settings.configurable.display.name=Live Edit 進階組態
live.edit.configurable.display.name=Live Edit
live.edit.configurable.display.name.comment=即時反映在模擬器和物理裝置上執行的 Android 套用的 Composable 函式中所做的程式碼變更的功能。對裝置/模擬器的設定更改將需要重新執行應用程式。<a href="https://developer.android.com/studio/run#live-edit">了解詳情</a>。
live.edit.configurable.enable.debug.mode=啟用偵錯模式
live.edit.configurable.enable.debug.mode.comment=啟用 Live Edit 解釋器追蹤並停用 Houdini 異常清除
live.edit.configurable.enable.embedded.compiler=使用嵌入式編譯器
live.edit.configurable.enable.embedded.compiler.comment=使用嵌入式 Jetpack Compose 編譯器。如果停用，@Composable 將無法通過 Live Edit 進行編譯。
live.edit.configurable.enable.inline.analysis=啟用源內聯分析
live.edit.configurable.enable.inline.analysis.comment=啟用參照另一個原始檔中的內聯函式的原始檔的 Live Edit。
live.edit.configurable.enable.partial.recompose=啟用部分重組
live.edit.configurable.enable.partial.recompose.comment=啟用 @Composable 函式的 Live Edit 部分重組
live.edit.configurable.refresh.rate=刷新率(毫秒)
live.edit.configurable.refresh.rate.comment=調整 GUI 程式碼更改檢測間隔
live.edit.disable.all=無
live.edit.disable.all.description=關閉這兩個功能。
live.edit.mode.automatic=自動推送編輯內容
live.edit.mode.manual=手動推送編輯內容 ({0})
live.edit.tooltip.description=<html>將對程式碼中的 Composable 的更改立即套用到連線的模擬器或實體裝置。
live.edit.tooltip.url.label=Live Edit 文檔
live.literals=Compose 文字的 Live Edit
live.literals.action.disable.title=停用文字的 Live Edit
live.literals.action.enable.title=啟用文字的 Live Edit
live.literals.action.show.problems.title=顯示問題…
live.literals.breadcrumbs.highlights=文字裝飾
live.literals.configurable.display.name=Compose 文字的 Live Edit
live.literals.configurable.select.live.literals=(已棄用)文字的Live Edit
live.literals.configurable.select.live.literals.comment=實時更新模擬器和實體裝置中的 Composable 中使用的文字。在啟用文字的 Live Edit 後需要建置，以便該功能正常執行。<a href="https://developer.android.com/jetpack/compose/tooling#live-edit-literals">了解詳情</a>。
live.literals.customize.appearance.title=自訂文字裝飾…
live.literals.highlight.toggle.description=在編輯器中切換文字裝飾
live.literals.highlight.toggle.hide.title=停用文字裝飾
live.literals.highlight.toggle.show.title=啟用文字裝飾
live.literals.highlight.toggle.title=切換文字裝飾
live.literals.is.disabled=文字的 Live Edit: 關
live.literals.is.enabled=文字的 Live Edit: 開
live.literals.problems.dialog.title=問題
live.literals.tooltip.description=<html>程式碼中某些文字的更改將立即反映在模擬器中。<br/>使用此圖標可以啟用/停用該功能，開啟編輯器標記，並檢視文字的 Live Edit 狀態。
live.literals.tooltip.url.label=文字的 Live Edit 文檔
low.memory.notification.content=IDE 記憶體不足，這可能會影響性能。請考慮增加堆大小。
low.memory.notification.title=記憶體不足
memory.settings.has.user.properties=<i>{0}</i> 中指定的使用者 Gradle 屬性由專案共享，並且優先於專案級別屬性。要為守護程序指定專案級別的最大堆大小，請在使用者級別屬性中移除 <i>org.gradle.jvmargs</i> 設定，然後重新開啟此面板。
memory.settings.ide.bottom.message=這是全域設定，適用於您使用 {0} 開啟的所有專案。在對 IDE 堆大小的任何更改生效之前，您需要重啟 IDE。
memory.settings.panel.daemon.info=這些設定僅應用於當前專案，並且更改僅會在重新建置專案(通過從菜單欄選擇“建置”>“重新建置專案”)後生效。更改堆大小並重新建置專案後，您可能會發現具有舊設定的守護程序並需要將其手動停止。
memory.settings.panel.ide.info=根據可用記憶體和當前專案，建議 IDE 堆大小為 {0}。
memory.settings.panel.show.daemons.info=尋找現有的 Gradle 守護程序
memory.settings.panel.top.message=對作業系統應為 {0} 個進程(如核心 IDE 或 Gradle 守護程序)分配的最大 RAM 大小進行組態。與分配過少記憶體類似，分配過多記憶體也可能會降低性能。
memory.settings.panel.use.recommended.values=使用建議值
memory.settings.postsync.configure=組態…
memory.settings.postsync.do.not.ask.for.project=此專案不再詢問
memory.settings.postsync.do.not.show.again=不再顯示
memory.settings.postsync.message=根據可用記憶體和專案大小，將最大堆大小從 {0}MB 增加到 {1}MB 可以最佳化 IDE 性能。
memory.settings.postsync.save=使用建議設定並重啟
memory.settings.postsync.title={0} 的性能可以提高
memory.settings.restart.needed=記憶體設定已儲存。為了使新設定生效，您需要重啟 IDE。要立即重啟嗎?
new.file.dialog.text=輸入一個新的檔名
new.resource.action.description=建立新的資源檔案
new.resource.action.name=建立資源檔案“{0}”
new.resource.action.title=Android 資源檔案
new.resource.command.name=新增資源檔案
new.resource.dialog.title=新增資源檔案
new.resource.dir.action.name=建立資源目錄“{0}”
new.resource.dir.action.title=Android 資源目錄
new.resource.dir.command.name=新增資源目錄
new.resource.dir.dialog.title=新增資源目錄
new.sampledata.dir.action.description=建立新的範例資料目錄
new.sampledata.dir.action.title=範例資料目錄
new.typed.resource.action.description=建立新的 {0} 資源檔案
new.typed.resource.action.title={0}資源檔案
new.typed.resource.command.name=新增 {0} 資源檔案
new.typed.resource.dialog.title=新增 {0} 資源檔案
no.android.targets.error=在此 SDK 中找不到任何 Android 目標
no.facet.error=找不到 {0} 的 Android facet
no.jdk.for.android.found.error=找不到合適版本的 Java SDK。除 Android SDK 外，您還需要定義一個 JDK 1.5、1.6 或 1.7
no.provider.type.error=複雜功能資料來源在清單中沒有受支援的類型宣告。
not.activity.subclass.error={0} 不是 Activity 子類別或別名
not.resource.file.error=檔案 {0} 不是資源檔案
not.valid.activity.name.error=不是有效的 Activity 名稱“{0}”
not.valid.package.name.error=不是有效的軟體套件名稱“{0}”
package.name.must.contain.2.ids.error=軟體套件名稱必須包含 2 個分段(例如 com.example)
package.not.found.error=清單檔案中未指定軟體套件
progress.connecting.to.download.file.text=正在連線到 ''{0}''…
progress.download.file.text=正在從 ''{1}'' 下載 ''{0}''…
progress.downloading.0.files.text=正在下載 {0} {0, choice, 1#檔案|2#檔案}…
project.sync.warning.multiple.gradle.daemons.message=<html>可能會產生多個 Gradle 守護程序，因為 Gradle JDK 和 JAVA_HOME 的位置不同。<br>專案 ''{0}'' 在執行 Gradle 時使用以下 JDK 位置:<br>''{1}''<br>系統環境變數 JAVA_HOME 為:<br>''{2}''<br>如果您不需要使用不同的路徑(或者如果 JAVA_HOME 未定義)，則可以通過將 JAVA_HOME 和 JDK 位置設定為相同的路徑來避免產生多個守護程序。
project.sync.warning.multiple.gradle.daemons.url=https://docs.gradle.org/current/userguide/gradle_daemon.html#sec:why_is_there_more_than_one_daemon_process_on_my_machine
project.upgrade.addBuildTypeFirebaseCrashlyticsUsageInfo.tooltipText=為發佈 buildType 啟用原生符號上傳
project.upgrade.addFirebaseCrashlyticsClasspathDependencyUsageInfo.tooltipText=新增對 Firebase Crashlytics Gradle 延伸模組的相依
project.upgrade.addFirebaseCrashlyticsNdkUsageInfo.tooltipText=新增 Firebase Crashlytics NDK 相依關係
project.upgrade.addFirebaseCrashlyticsSdkUsageInfo.tooltipText=新增對 Firebase Crashlytics SDK 的相依
project.upgrade.addGoogleAnalyticsSdkUsageInfo.tooltipText=新增對 Google Analytics SDK 的相依
project.upgrade.addGoogleMavenRepositoryUsageInfo.tooltipText=新增 Google Maven 儲存庫
project.upgrade.addGoogleServicesClasspathDependencyUsageInfo.tooltipText=新增對 Google Services Gradle 延伸模組的相依
project.upgrade.agpUpgradeRefactoringProcessor.commandName=將 AGP 版本從 {0} 升級到 {1}
project.upgrade.agpUpgradeRefactoringProcessor.usageView.header=AGP 升級助手
project.upgrade.agpVersionRefactoringProcessor.commandName=將 AGP 相依項從 {0} 升級到 {1}
project.upgrade.agpVersionRefactoringProcessor.target.presentableText=正在升級 AGP 組態
project.upgrade.agpVersionRefactoringProcessor.usageType=更新版本字串
project.upgrade.agpVersionRefactoringProcessor.usageView.header=將 AGP 版本從 {0} 升級到 {1}
project.upgrade.agpVersionUsageInfo.tooltipText=將 AGP 版本從 {0} 更新到 {1}
project.upgrade.aidlBuildFeature.enable.tooltipText=在此模組中啟用 aidl
project.upgrade.aidlDefaultRefactoringProcessor.commandName=在需要的地方顯式啟用 aidl
project.upgrade.aidlDefaultRefactoringProcessor.enable.usageType=插入 aidl 指令
project.upgrade.aidlDefaultRefactoringProcessor.usageView.header=顯式啟用 aidl 建置功能
project.upgrade.androidManifestExtractNativeLibsToUseLegacyPackagingRefactoringProcessor.addUseLegacyPackaging.tooltipText=新增 useLegacyPackaging 宣告
project.upgrade.androidManifestExtractNativeLibsToUseLegacyPackagingRefactoringProcessor.addUseLegacyPackaging.usageType=新增 useLegacyPackaging 宣告
project.upgrade.androidManifestExtractNativeLibsToUseLegacyPackagingRefactoringProcessor.commandName=將 extractNativeLibs從Android 清單移動到建置檔案
project.upgrade.androidManifestExtractNativeLibsToUseLegacyPackagingRefactoringProcessor.removeExtractNativeLibs.tooltipText=移除 extractNativeLibs 宣告
project.upgrade.androidManifestExtractNativeLibsToUseLegacyPackagingRefactoringProcessor.removeExtractNativeLibs.usageType=移除 extractNativeLibs 宣告
project.upgrade.androidManifestExtractNativeLibsToUseLegacyPackagingRefactoringProcessor.usageView.header=將 extractNativeLibs從Android 清單移動到建置檔案
project.upgrade.androidManifestPackageToNamespaceRefactoringProcessor.addNamespace.tooltipText=新增命名空間宣告
project.upgrade.androidManifestPackageToNamespaceRefactoringProcessor.addNamespace.usageType=新增命名空間宣告
project.upgrade.androidManifestPackageToNamespaceRefactoringProcessor.addTestNamespace.tooltipText=新增 testNamespace 宣告
project.upgrade.androidManifestPackageToNamespaceRefactoringProcessor.addTestNamespace.usageType=新增 testNamespace 宣告
project.upgrade.androidManifestPackageToNamespaceRefactoringProcessor.commandName=將軟體套件從 Android 清單移至建置檔案
project.upgrade.androidManifestPackageToNamespaceRefactoringProcessor.removePackage.tooltipText=移除軟體套件宣告
project.upgrade.androidManifestPackageToNamespaceRefactoringProcessor.removePackage.usageType=移除軟體套件宣告
project.upgrade.androidManifestPackageToNamespaceRefactoringProcessor.usageView.header=將軟體套件從 Android 清單移至建置檔案
project.upgrade.androidManifestUseEmbeddedDexToUseLegacyPackagingRefactoringProcessor.addUseLegacyPackaging.tooltipText=新增 useLegacyPackaging 宣告
project.upgrade.androidManifestUseEmbeddedDexToUseLegacyPackagingRefactoringProcessor.addUseLegacyPackaging.usageType=新增 useLegacyPackaging 宣告
project.upgrade.androidManifestUseEmbeddedDexToUseLegacyPackagingRefactoringProcessor.commandName=將 Android 清單中的 useEmbeddedDex 包含到建置檔案中
project.upgrade.androidManifestUseEmbeddedDexToUseLegacyPackagingRefactoringProcessor.usageView.header=將 Android 清單中的 useEmbeddedDex 包含到建置檔案中
project.upgrade.androidResourcesUsageInfo.move.tooltipText=將用法從 aaptOptions 移至 androidResources
project.upgrade.androidResourcesUsageInfo.remove.tooltipText=移除 aaptOptions
project.upgrade.applyGoogleServicesPluginUsageInfo.tooltipText=套用 Google Services 延伸模組
project.upgrade.buildConfigBuildFeature.enable.tooltipText=保留現有的 buildConfig 行為
project.upgrade.buildConfigDefaultRefactoringProcessor.commandName=啟用 buildConfig 生成功能
project.upgrade.buildConfigDefaultRefactoringProcessor.enable.usageType=保留現有的 buildConfig 行為
project.upgrade.buildConfigDefaultRefactoringProcessor.usageView.header=啟用 buildConfig 生成功能
project.upgrade.compileRuntimeConfigurationRefactoringProcessor.changeDependencyConfigurationUsageType=更改相依關係組態
project.upgrade.compileRuntimeConfigurationRefactoringProcessor.commandName=取代棄用的組態
project.upgrade.compileRuntimeConfigurationRefactoringProcessor.renameConfigurationUsageType=重新命名組態
project.upgrade.compileRuntimeConfigurationRefactoringProcessor.usageView.header=取代棄用的組態
project.upgrade.dataBindingEnabledUsageInfo.tooltipText=將啟用的 dataBinding 遷移到 buildFeatures
project.upgrade.deprecated.notification.body=Android Studio 的未來版本將不支持 Android Gradle 延伸模組版本 {0}。啟動 AGP 升級助手，將此專案的 AGP 版本更新到至少 {1}。
project.upgrade.deprecated.notification.title=強烈建議進行專案更新
project.upgrade.deprecatedOperatorUsageInfo.rewrite.tooltipText=覆寫用法
project.upgrade.emulatorSnapshotsUsageInfo.move.tooltipText=將用法從 failureRetention 移至 emulatorSnapshots
project.upgrade.emulatorSnapshotsUsageInfo.remove.tooltipText=移除 failureRetention
project.upgrade.fabricCrashlyticsRefactoringProcessor.addFirebaseCrashlyticsClasspathUsageType=新增對 Firebase Crashlytics Gradle 延伸模組的相依
project.upgrade.fabricCrashlyticsRefactoringProcessor.addFirebaseCrashlyticsNativeSymbolUploadUsageType=為發佈 buildType 啟用原生符號上傳
project.upgrade.fabricCrashlyticsRefactoringProcessor.addFirebaseCrashlyticsNdkUsageType=新增 Firebase Crashlytics NDK 相依關係
project.upgrade.fabricCrashlyticsRefactoringProcessor.addFirebaseCrashlyticsSdkUsageType=新增對 Firebase Crashlytics SDK 的相依
project.upgrade.fabricCrashlyticsRefactoringProcessor.addGmavenRepositoryUsageType=新增 Google Maven 儲存庫
project.upgrade.fabricCrashlyticsRefactoringProcessor.addGoogleAnalyticsSdkUsageType=新增對 Google Analytics SDK 的相依
project.upgrade.fabricCrashlyticsRefactoringProcessor.addGoogleServicesClasspathUsageType=新增對 Google Services Gradle 延伸模組的相依
project.upgrade.fabricCrashlyticsRefactoringProcessor.applyGoogleServicesPluginUsageType=套用 Google Services 延伸模組
project.upgrade.fabricCrashlyticsRefactoringProcessor.commandName=將 crashlytics 從 fabric 遷移到 firebase
project.upgrade.fabricCrashlyticsRefactoringProcessor.removeCrashlyticsEnableNdkUsageType=移除 enableNdk crashlytics 標誌
project.upgrade.fabricCrashlyticsRefactoringProcessor.removeFabricClasspathUsageType=移除對 Fabric Gradle 延伸模組的相依
project.upgrade.fabricCrashlyticsRefactoringProcessor.removeFabricCrashlyticsSdkUsageType=移除對 Fabric SDK 的相依
project.upgrade.fabricCrashlyticsRefactoringProcessor.removeFabricNdkUsageType=移除 Fabric NDK 相依關係
project.upgrade.fabricCrashlyticsRefactoringProcessor.removeFabricRepositoryUsageType=移除 Fabric Maven 儲存庫
project.upgrade.fabricCrashlyticsRefactoringProcessor.replaceFabricPluginUsageType=將 Fabric 延伸模組取代為 Firebase Crashlytics 延伸模組
project.upgrade.fabricCrashlyticsRefactoringProcessor.usageView.header=將 crashlytics 從 fabric 遷移到 firebase
project.upgrade.gMavenRepositoryRefactoringProcessor.commandName=將 google() GMaven 新增到 buildscript 儲存庫
project.upgrade.gMavenRepositoryRefactoringProcessor.usageType=新增 GMaven 宣告
project.upgrade.gMavenRepositoryRefactoringProcessor.usageView.header=將 google() GMaven 新增到 buildscript 儲存庫
project.upgrade.gradlePluginsRefactoringProcessor.commandName=升級 Gradle 延伸模組
project.upgrade.gradlePluginsRefactoringProcessor.usageView.header=升級 Gradle 延伸模組
project.upgrade.gradlePluginsRefactoringProcessor.wellKnownGradlePluginUsageType=更新 Gradle 延伸模組版本
project.upgrade.gradleVersionRefactoringProcessor.commandName=將 Gradle 版本升級到 {0}
project.upgrade.gradleVersionRefactoringProcessor.gradleUrlUsageType=更新 Gradle 分發 URL
project.upgrade.gradleVersionRefactoringProcessor.usageView.header=將 Gradle 版本升級到 {0}
project.upgrade.gradleVersionUsageInfo.tooltipText=將 Gradle 版本升級到 {0}
project.upgrade.installationUsageInfo.move.tooltipText=將用法從 adbOptions 移至安裝
project.upgrade.installationUsageInfo.remove.tooltipText=移除 adbOptions
project.upgrade.java8DefaultRefactoringProcessor.acceptNewUsageType=接受新預設值(保持不變)
project.upgrade.java8DefaultRefactoringProcessor.commandName=更新預設 Java 語言級別
project.upgrade.java8DefaultRefactoringProcessor.existingDirectiveUsageType=現有語言級別指令(保持不變)
project.upgrade.java8DefaultRefactoringProcessor.groupingName=新增指令以繼續使用 Java 7
project.upgrade.java8DefaultRefactoringProcessor.insertOldUsageType=繼續使用 Java 7 (插入語言級別指令)
project.upgrade.java8DefaultRefactoringProcessor.usageView.header=更新預設 Java 語言級別
project.upgrade.javaLanguageLevelUsageInfo.tooltipText.acceptNewDefault=接受新預設值
project.upgrade.javaLanguageLevelUsageInfo.tooltipText.existing=保留現有顯式 {0}
project.upgrade.javaLanguageLevelUsageInfo.tooltipText.insertOldDefault=插入顯式 {0} 以保留以前的行為
project.upgrade.kotlinLanguageLevelUsageInfo.tooltipText.acceptNewDefault=接受新預設值
project.upgrade.kotlinLanguageLevelUsageInfo.tooltipText.existing=保留現有顯式 {0}
project.upgrade.kotlinLanguageLevelUsageInfo.tooltipText.insertOldDefault=插入顯式 {0} 以保留以前的行為
project.upgrade.lintOptionsUsageInfo.move.tooltipText=將用法從 lintOptions 遷移到 lint
project.upgrade.lintOptionsUsageInfo.remove.tooltipText=移除 lintOptions
project.upgrade.migratePackagingOptionsRefactoringProcessor.commandName=將 packagingOptions DSL 屬性遷移到子塊
project.upgrade.migratePackagingOptionsRefactoringProcessor.move.tooltipText=移動屬性
project.upgrade.migratePackagingOptionsRefactoringProcessor.move.usageType=移動屬性
project.upgrade.migratePackagingOptionsRefactoringProcessor.remove.tooltipText=移除屬性(拆分後)
project.upgrade.migratePackagingOptionsRefactoringProcessor.remove.usageType=移除屬性(拆分後)
project.upgrade.migratePackagingOptionsRefactoringProcessor.split.tooltipText=拆分 jniLibs 和資源之間的屬性
project.upgrade.migratePackagingOptionsRefactoringProcessor.split.usageType=拆分 jniLibs 和資源之間的屬性
project.upgrade.migratePackagingOptionsRefactoringProcessor.usageView.header=將 packagingOptions 遷移到子塊
project.upgrade.migrateToAndroidResourcesRefactoringProcessor.commandName=將 DSL 屬性從 aaptOptions 遷移到 androidResources
project.upgrade.migrateToAndroidResourcesRefactoringProcessor.move.usageType=將屬性遷移到 androidResources
project.upgrade.migrateToAndroidResourcesRefactoringProcessor.remove.usageType=移除 aaptOptions
project.upgrade.migrateToAndroidResourcesRefactoringProcessor.usageView.header=從 aaptOptions 遷移到 androidResources
project.upgrade.migrateToBuildFeaturesRefactoringProcessor.commandName=將啟用的 booleans 遷移到 buildFeatures
project.upgrade.migrateToBuildFeaturesRefactoringProcessor.dataBindingEnabledUsageType=將啟用的 dataBinding 遷移到 buildFeatures
project.upgrade.migrateToBuildFeaturesRefactoringProcessor.usageView.header=將啟用的 booleans 遷移到 buildFeatures
project.upgrade.migrateToBuildFeaturesRefactoringProcessor.viewBindingEnabledUsageType=將啟用的 viewBinding 遷移到 buildFeatures
project.upgrade.migrateToEmulatorSnapshotsRefactoringProcessor.commandName=將 DSL 屬性從 failureRetention 遷移到 emulatorSnapshots
project.upgrade.migrateToEmulatorSnapshotsRefactoringProcessor.move.usageType=將屬性遷移到 emulatorSnapshots
project.upgrade.migrateToEmulatorSnapshotsRefactoringProcessor.remove.usageType=移除 failureRetention
project.upgrade.migrateToEmulatorSnapshotsRefactoringProcessor.usageView.header=從 failureRetention 遷移到 emulatorSnapshots
project.upgrade.migrateToInstallationRefactoringProcessor.commandName=將 DSL 屬性從 adbOptions 遷移到安裝
project.upgrade.migrateToInstallationRefactoringProcessor.move.usageType=將屬性遷移到安裝
project.upgrade.migrateToInstallationRefactoringProcessor.remove.usageType=移除 adbOptions
project.upgrade.migrateToInstallationRefactoringProcessor.usageView.header=從 adbOptions 遷移到安裝
project.upgrade.migrateToLintRefactoringProcessor.commandName=將 DSL 屬性從 lintOptions 遷移到 lint
project.upgrade.migrateToLintRefactoringProcessor.move.usageType=將屬性遷移到 lint
project.upgrade.migrateToLintRefactoringProcessor.remove.usageType=移除 lintOptions
project.upgrade.migrateToLintRefactoringProcessor.usageView.header=從 lintOptions 遷移到 lint
project.upgrade.migrateToTestCoverageRefactoringProcessor.commandName=將 DSL 屬性從 jacoco 遷移到 testCoverage
project.upgrade.migrateToTestCoverageRefactoringProcessor.move.usageType=將屬性遷移到 testCoverage
project.upgrade.migrateToTestCoverageRefactoringProcessor.remove.usageType=移除 jacoco
project.upgrade.migrateToTestCoverageRefactoringProcessor.usageView.header=從 jacoco 遷移到 testCoverage
project.upgrade.noLanguageLevelAction.acceptNewDefault=接受 Java 8 的新預設值
project.upgrade.noLanguageLevelAction.insertOldDefault=插入指令以繼續使用 Java 7
project.upgrade.noPropertyPresentAction.acceptNewDefault=接受完整模式下的新 R8 預設設定
project.upgrade.noPropertyPresentAction.insertOldDefault=插入屬性以在相容性模式下繼續使用 R8
project.upgrade.nonConstantRClassDefaultRefactoringProcessor.commandName=保留常數 R 類別值
project.upgrade.nonConstantRClassDefaultRefactoringProcessor.usageType=插入 android.nonFinalRClass 屬性以保留現有行為
project.upgrade.nonConstantRClassDefaultRefactoringProcessor.usageView.header=保留常數 R 類別值
project.upgrade.nonConstantRClassUsageInfo.tooltipText=插入 android.nonFinalRClass 屬性以保留現有行為
project.upgrade.nonTransitiveRClassDefaultRefactoringProcessor.commandName=保留可傳遞 R 類別
project.upgrade.nonTransitiveRClassDefaultRefactoringProcessor.usageType=插入 android.nonTransitiveRClass 屬性以保留現有行為
project.upgrade.nonTransitiveRClassDefaultRefactoringProcessor.usageView.header=保留可傳遞 R 類別
project.upgrade.nonTransitiveRClassUsageInfo.tooltipText=插入 android.nonTransitiveRClass 屬性以保留現有行為
project.upgrade.notification.body=Android Gradle 延伸模組版本 {0} 有可用的升級。啟動 AGP 升級助手以更新該項目的 AGP 版本。
project.upgrade.notification.title=建議進行專案更新
project.upgrade.notifyCancelledUpgrade.body=啟動 AGP 升級助手以繼續升級。
project.upgrade.notifyCancelledUpgrade.title=已取消 Android Gradle 延伸模組升級
project.upgrade.obsoleteConfigurationConfigurationUsageInfo.tooltipText=將組態從 {0} 重命名為 {1}
project.upgrade.obsoleteConfigurationDependencyUsageInfo.tooltipText=將組態從 {0} 更新到 {1}
project.upgrade.projectJdkRefactoringProcessor.commandName=升級專案 JDK 以執行 Gradle
project.upgrade.projectJdkRefactoringProcessor.enable.usageType=升級專案 JDK
project.upgrade.projectJdkRefactoringProcessor.usageView.header=升級專案 JDK 以執行 Gradle
project.upgrade.projectJdkUsageInfo.tooltipText=設定專案 JDK
project.upgrade.r8FullModeDefaultRefactoringProcessor.acceptNewUsageType=接受新的預設 R8 模式(保持不變)
project.upgrade.r8FullModeDefaultRefactoringProcessor.commandName=更新預設 R8 處理模式
project.upgrade.r8FullModeDefaultRefactoringProcessor.existingDirectiveUsageType=現有的 fullMode 屬性(保持不變)
project.upgrade.r8FullModeDefaultRefactoringProcessor.groupingName=新增屬性以在相容性模式下繼續使用 R8
project.upgrade.r8FullModeDefaultRefactoringProcessor.insertOldUsageType=繼續在兼容性模式下使用 R8 (插入屬性)
project.upgrade.r8FullModeDefaultRefactoringProcessor.usageView.header=更新預設 R8 處理模式
project.upgrade.r8FullModeDefaultUsageInfo.tooltipText.acceptNewDefault=接受新預設值
project.upgrade.r8FullModeDefaultUsageInfo.tooltipText.existing=保留現有顯式屬性
project.upgrade.r8FullModeDefaultUsageInfo.tooltipText.insertOldDefault=插入屬性以保留以前的行為
project.upgrade.redundantProperties.tooltipText=移除屬性
project.upgrade.redundantProperties.usageType=移除屬性
project.upgrade.redundantPropertiesRefactoringProcessor.commandName=移除冗餘屬性
project.upgrade.redundantPropertiesRefactoringProcessor.usageView.header=移除冗餘屬性
project.upgrade.references.text=考慮的參考
project.upgrade.removeBuildTypeUseProguard.tooltipText=移除 useProguard 設定
project.upgrade.removeBuildTypeUseProguard.usageType=移除 useProguard 設定
project.upgrade.removeBuildTypeUseProguardRefactoringProcessor.commandName=移除 buildType useProguard 設定
project.upgrade.removeBuildTypeUseProguardRefactoringProcessor.usageView.header=移除 buildType useProguard 設定
project.upgrade.removeCrashlyticsEnableNdkUsageInfo.tooltipText=移除 enableNdk crashlytics 標誌
project.upgrade.removeFabricClasspathDependencyUsageInfo.tooltipText=移除對 Fabric Gradle 延伸模組的相依
project.upgrade.removeFabricCrashlyticsSdkUsageInfo.tooltipText=移除對 Fabric SDK 的相依
project.upgrade.removeFabricMavenRepositoryUsageInfo.tooltipText=移除 Fabric Maven 儲存庫
project.upgrade.removeFabricNdkUsageInfo.tooltipText=移除 Fabric NDK 相依關係
project.upgrade.removeImplementationPropertiesRefactoringProcessor.commandName=移除忽略的組態屬性
project.upgrade.removeImplementationPropertiesRefactoringProcessor.usageView.header=移除忽略的組態屬性
project.upgrade.removeImplementationProperty.tooltipText=移除屬性
project.upgrade.removeImplementationProperty.usageType=移除屬性
project.upgrade.removeSourceSetJniRefactoringProcessor.commandName=從 sourceSets 中移除 jni 資源目錄
project.upgrade.removeSourceSetJniRefactoringProcessor.usageView.header=從 sourceSets 中移除 jni 資源目錄
project.upgrade.renderScriptBuildFeature.enable.tooltipText=在此模組中啟用 renderScript
project.upgrade.renderScriptDefaultRefactoringProcessor.commandName=在需要的地方顯式啟用 renderScript
project.upgrade.renderScriptDefaultRefactoringProcessor.enable.usageType=插入 renderScript 指令
project.upgrade.renderScriptDefaultRefactoringProcessor.usageView.header=顯式啟用 renderScript 建置功能
project.upgrade.replaceFabricPluginUsageInfo.tooltipText=將 Fabric 延伸模組取代為 Firebase Crashlytics 延伸模組
project.upgrade.repositoriesNoGMavenUsageInfo.tooltipText=將 google() 新增到 buildscript 儲存庫
project.upgrade.rewriteDeprecatedOperatorsRefactoringProcessor.commandName=覆寫已棄用的運算符
project.upgrade.rewriteDeprecatedOperatorsRefactoringProcessor.rewrite.usageType=覆寫用法
project.upgrade.rewriteDeprecatedOperatorsRefactoringProcessor.usageView.header=覆寫已棄用的運算符
project.upgrade.sourceSetJniUsageInfo.tooltipText=從 sourceSet 移除 jni
project.upgrade.sourceSetJniUsageInfo.usageType=從 sourceSet 移除 jni
project.upgrade.testCoverageUsageInfo.move.tooltipText=將用法從 jacoco 移至 testCoverage
project.upgrade.testCoverageUsageInfo.remove.tooltipText=移除 jacoco
project.upgrade.usageView.doAction=完成升級(&U)
project.upgrade.usageView.need.reRun=無法執行升級。\n找到用法後代碼有更改。\n請再次執行用法搜尋。
project.upgrade.usageView.tabText=更新用法
project.upgrade.viewBindingEnabledUsageInfo.tooltipText=將啟用的 viewBinding 遷移到 buildFeatures
provider.module.not.chosen=未選擇模組。
provider.slots.empty.error=沒有新增複雜功能插槽。
provider.type.empty=沒有為插槽“{0}”指定類型。
provider.type.invalid.error=複雜功能資料來源類型“{0}”不存在。
provider.type.manifest.not.available=清單資訊目前不可用。
provider.type.mismatch.error=複雜功能資料來源無法提供類型 {0}。
quick.fixes.family=Android 快速修復
redo.parcelable.intention.text=取代 Parcelable 實作
remove.parcelable.intention.text=移除 Parcelable 實作
resource.explorer.copy.value.description=將資源值複製到剪貼簿
resource.explorer.copy.value.title=複製值
resource.manager.collapse.section=摺疊
resource.manager.expand.section=展開
root.element.not.specified.error=未指定根元素
run.error.apk.not.signed=當前所選變體的 APK 無法簽名。請為此變體({0})指定簽名組態。
run.error.apk.not.valid=當前專案無法執行
select.platform.error=請選擇 Android SDK
select.target.dialog.text=請選擇 Android 目標
specific.activity.not.launchable.error=Activity 必須匯出或包含 intent-filter
specify.package.name.error=必須指定軟體套件名稱
sys.health.send.feedback=發送反饋
sys.health.too.many.exceptions=已檢測到大量內部異常。這表明 IDE 存在嚴重問題。請考慮重新安裝 Android Studio。如果問題仍然存在，請通過以下鏈接報告錯誤。
tab.name.sdk.platforms=SDK 平台
tab.name.sdk.tools=SDK 工具
tab.name.sdk.update.sites=SDK 更新站點
text.loading=正在載入…
title.cannot.open.file=無法開啟檔案 {0}
tooltip.disabling.sdk.diff.patching=停用 SDK 差異修補可能會增大 SDK 軟體套件下載體積，但是將提升下載後包的安裝速度。如果在您的計算機上安裝本地補丁將花費大量時間，但您具有無流量限制的快速網絡連線，這樣選擇較為實用。SDK 差異修補預設啟用，並且是進階硬體的首選安裝方法。
unsupported.jvm.dragndrop.message=在受拖放問題(1.8.0_60 至 1.8.0_76)影響的 JDK8 版本上執行。請參見 <a href="https://youtrack.jetbrains.com/issue/IDEA-146691">IDEA-146691</a> 了解詳細資訊，並考慮使用問題範圍之外的 JDK。
unsupported.jvm.openjdk.message=OpenJDK 表現出間歇性的性能和 UI 問題。我們建議使用 Oracle JRE/JDK。
unsupported.mac.intelonarm.message=Android Studio 執行在 Rosetta 2 下，這可能會影響性能。我們推薦使用官方 Apple 晶片(arm64)版本。
updates.settings.channel.locked=
verbose.level.title=詳細
virus.scanning.dont.show.again=不再顯示
virus.scanning.dont.show.again.this.project=不再為此專案顯示
virus.scanning.warn.message=防病毒程序可能會影響建置性能。{0} 檢查了以下目錄: {1}
warning.level.title=警告
whatsnew.action.custom.description=了解最新版本 {0} 的新功能和改進
windows.ucrt.warn.message=未安裝 Windows 版 Universal C Runtime。ADB 等平台工具可能無法正常工作。