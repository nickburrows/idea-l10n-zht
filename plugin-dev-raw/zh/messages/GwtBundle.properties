action.GWT.GenerateCompileReport.description=執行 GWT 編譯器以生成編譯報告，並在瀏覽器中開啟結果
action.GWT.GenerateCompileReport.text=生成 GWT 編譯報告…
action.GWT.GenerateUiHandlerMethod.text=@UiHandler 方法…
action.GWT.NewEntryPoint.description=建立擴展 EntryPoint 的新 GWT 類別
action.GWT.NewEntryPoint.text=GWT 入口點
action.GWT.NewEventWithHandler.description=建立一個擴展 GwtEvent 的類別和相應的擴展 EventHandler 的類別
action.GWT.NewEventWithHandler.text=GWT 事件和處理程序類別
action.GWT.NewModule.description=建立新的 GWT 模組框架
action.GWT.NewModule.text=GWT 模組
action.GWT.NewRemoteService.description=建立擴展 RemoteService、對應的異步版本和實作類別的新 GWT 接口
action.GWT.NewRemoteService.text=GWT 遠端服務
action.GWT.NewSerialClass.description=建立實作 IsSerializable 的新 GWT 類別
action.GWT.NewSerialClass.text=GWT 可序列化類別
action.GWT.NewTestCase.description=建立一個擴展 GWTTestCase 的新類別
action.GWT.NewTestCase.text=GWT 測試用例
action.GWT.NewUiBinder.description=建立一個擴展 UiBinder 的類別和相應的 ui.xml 檔案
action.GWT.NewUiBinder.text=GWT UiBinder 和 ui.xml 檔案
action.GWT.NewUiRenderer.description=建立一個擴展 UiRenderer 的類別和相應的 ui.xml 檔案
action.GWT.NewUiRenderer.text=GWT UiRenderer 和 ui.xml 檔案
action.ViewReportAction.text=檢視報告
action.group.gwt.description=Google Web Toolkit
action.group.gwt.title=Google Web Toolkit
action.name.create.gwt.event.with.handler=建立 GWT 事件 ''{0}'' 及其處理程序類別
action.name.create.gwt.uibinder.0.and.1.ui.xml.file=建立 GWT UiBinder ''{0}'' 和 ''{1}.ui.xml'' 檔案
action.name.create.gwt.uirenderer.0.and.1.ui.xml.file=建立 GWT UiRenderer ''{0}'' 和 ''{1}.ui.xml'' 檔案
action.progress.creating.gwt.test.case.0=建立 GWT 測試用例 ''{0}''
artifact.node.gwt.compiler.output=GWT 編譯器輸出
artifact.node.gwt.deploy.output=GWT 部署輸出
border.title.gwt.compilation=GWT 編譯
button.text.generate=生成
checkbox.create.html.and.css.files.in.directory=在目錄中建立 HTML 和 CSS 檔案(&C)
checkbox.create.sample.application=建立範例應用程式(&C)
checkbox.open.in.browser=在瀏覽器中開啟(&B):
checkbox.show.compiler.output=顯示編譯器輸出(&S)
checkbox.text.report.interfaces=報告接口
checkbox.text.separate.methods=為每個欄位生成單獨的方法(&S)
checkbox.text.use.custom.web.xml=使用自訂 'web.xml' 檔案描述子的內容(&W)
checkbox.update.resources.on.frame.deactivation=切換出 IDE 時更新資源(&U)
checkbox.use.super.dev.mode=使用超級開發模式
checkbox.with.javascript.debugger=使用 JavaScript 偵錯器
choose.text.select.gwt.module=選擇 GWT 模組:
command.create.sample.gwt.project.files=建立範例 GWT 專案檔案
console.message.dev.mode.initialized.startup.urls=開發模式已初始化{0, choice, 0#|1#。啟動 URL:|2#。啟動 URL:}
content.display.name.dev.mode=開發模式
content.display.name.modules=模組
content.display.name.server=伺服器
css.usages.variable=變數
default.gwt.run.configuration.name=未命名
dialog.caption.gwt.dev.mode.parameters=GWT 開發模式參數
dialog.caption.vm.parameters=虛擬機選項
dialog.message.0.class.not.found=找不到 {0} 類別。
dialog.message.cannot.create.sample.gwt.application.0=無法建立範例 GWT 應用程式: {0}
dialog.message.incorrect.number.of.type.parameters.in.0.class={0} 類別中的類型參數數量不正確。
dialog.message.root.element.type.is.not.specified=未指定根元素類型
dialog.promt.enter.name.for.gwt.test.case=輸入 GWT 測試用例的名稱:
dialog.title.choose.fields.to.generate.handler.for=選擇要為其生成處理程序的欄位
dialog.title.choose.gwt.module=GWT 模組
dialog.title.choose.gwt.modules.to.load=選擇要載入的 GWT 模組
dialog.title.create.gwt.event.with.handler=建立新的 GWT 事件和處理程序類別
dialog.title.create.new.gwt.uibinder.class.and.ui.xml.file=建立新的 GWT UiBinder 類別和 ui.xml 檔案
dialog.title.create.new.gwt.uirenderer.class.and.ui.xml.file=建立新的 GWT UiRenderer 類別和 ui.xml 檔案
dialog.title.generate.gwt.compile.report=生成 GWT 編譯報告
dialog.title.google.web.toolkit=Google Web Toolkit
dialog.title.new.gwt.test.case=新增 GWT 測試用例
dialog.title.no.gwt.modules.found.in.the.project=在專案中找不到 GWT 模組
dialog.title.select.event.type=選擇事件類型
dialog.title.select.type.of.root.element=選擇根元素的類型
error.class.not.found.in.jar=在 ''{1}'' 中找不到類別 ''{0}''
error.file.not.found.message=找不到檔案 ''{0}''
error.invalid.gwt.installation.message=''{0}'' 不是有效的 GWT 安裝: {1}
error.message.0.is.not.under.public.roots.of.gwt.modules.nor.under.web.roots=''{0}'' 不在 GWT 模組的 ''public'' 根目錄下，也不在 Web 根目錄下，因此無法在托管模式瀏覽器中開啟。
error.message.0.parameter.used.without.corresponding.war=使用的 {0} 參數時未使用對應的 -war
error.message.cannot.create.socket.0=無法建立套接字: {0}
error.message.gwt.event.not.supported=GWT 1.6 或更高版本支援 GwtEvent
error.message.gwt.user.jar.in.library.0.does.not.correspond.to.selected.gwt.installation=庫 ''{0}'' 中的 gwt-user.jar 與所選 GWT 安裝不相符
error.message.gwt.user.jar.library.not.found.in.dependencies.of.module=在模組的相依項中找不到 gwt-user.jar 庫
error.message.path.to.gwt.sdk.must.not.contain.character=GWT SDK 路徑不得包含 '!' 字元
error.message.set.service.entry.point.method.call.can.be.replaced.by.remote.service.relative.path.annotation='setServiceEntryPoint()' 方法呼叫可被取代為 '@RemoteServiceRelativePath' 註解
error.message.set.service.entry.point.method.call.is.redundant='setServiceEntryPoint()' 方法呼叫冗餘，因為入口點由 '@RemoteServiceRelativePath' 註解指定
error.message.this.action.is.allowed.only.for.client.side.packages.of.a.gwt.module=此動作僅適用於 GWT 模組的客戶端軟體套件
error.message.uibinder.is.supported.in.gwt.2.0.or.later=GWT 2.0 或更高版本支援 UiBinder
error.message.uirenderer.is.supported.in.gwt.2.5.or.later=GWT 2.5 或更高版本支援 UiRenderer
error.message.unknown.gwt.dev.mode.server.0=未知的 GWT 開發模式伺服器: {0}
error.text.gwt.facet.not.configured.in.module.0=未為模組 ''{0}'' 組態 GWT Facet
error.text.gwt.sdk.is.not.specified.correctly=在模組 ''{0}'' 的 GWT Facet 設定中未正確指定 GWT SDK 路徑
error.text.no.gwt.modules.in.module.0=在 ''{0}'' 中找不到 GWT 模組
exportable.GwtSdkManager.presentable.name=GWT SDK
file.template.group.title.gwt=Google Web Toolkit
fix.download.gwt=下載 GWT…
framework.title.google.web.toolkit=Google Web 工具包(&G)
google.web.toolkit.title=Google Web Toolkit
group.GWT.text=Google Web Toolkit
group.gwt.inspections.name=Google Web Toolkit
gwt.compiler.deploy.output.element.type.name=GWT 編譯器部署輸出
gwt.compiler.output.element.type.dialog.description=選擇包含 GWT Facet 的模組
gwt.compiler.output.element.type.dialog.title=選擇模組
gwt.compiler.output.element.type.name=GWT 編譯器輸出
gwt.installation.chooser.description=請指定 GWT 安裝目錄的路徑
gwt.installation.chooser.title=GWT 安裝目錄路徑
gwt.insufficient.language.level={0} (由 GWT Facet 組態)
gwt.intention.category=Google Web Toolkit
gwt.notification.display.id=GWT
gwt.searching.for.implementations=正在搜尋實作…
i18n.class.gutter.tooltip.text=類別有 {0} 個關聯的屬性 {0, choice, 1#檔案|2#檔案}
i18n.goto.property.popup.title=<html><body>選擇 <b>{0}</b> 的本地化(找到 {1} 個檔案)</body></html>
i18n.interface.method.gutter.tooltip=<html><body>方法在 {0} {0, choice, 1#個檔案|2#個檔案}中有關聯的屬性
implementation.provided=由 GWT 提供實作
inspection.GwtCssResourceErrors.name=擴展 'CssResource' 的不一致接口
inspection.GwtDefaultPackageNotRegistered.name='client' 軟體套件或 'public' 目錄未在 gwt.xml 檔案中註冊
inspection.GwtDeprecatedEventListeners.name=使用棄用的事件偵聽器
inspection.GwtUiBinderErrors.name='UiBinder' 接口的不一致實作
inspection.GwtUiFieldAssignment.name=賦值給包含 '@UiField' 註解的欄位
inspection.GwtUiFieldErrors.name=包含 '@UIField' 註解的不一致欄位
inspection.GwtUiHandlerErrors.name=包含 '@UiHandler' 註解的不一致方法
inspection.message.0.css.classes.do.not.have.corresponding.methods={0} CSS 類別沒有對應的方法
inspection.message.0.is.deprecated.in.gwt.1.6=''{0}'' 在 GWT 1.6 中被棄用
inspection.message.0.subpackage.is.not.registered.as.1.path.in.2=''{0}'' 子軟體套件未在 ''{2}'' 中作為 {1} 路徑進行註冊
inspection.message.assignment.to.uifield.annotated.field.will.be.ignored=對 @UiField 註解欄位的賦值將被忽略，因為它由 UiBinder 初始化
inspection.message.css.class.0.does.not.have.corresponding.method=CSS 類別 ''{0}'' 沒有對應的方法
inspection.name.classes.not.from.jre.emulation.library.in.client.code=使用 JRE Emulation Library 中不存在的類別和方法
inspection.name.client.class.from.non.inherited.module.usage=使用未繼承的 GWT 模組中的客戶端類別
inspection.name.deprecated.gwt.key.tag.in.javadoc.comments=JavaDoc 註釋中的已棄用 '@gwt.key' 標記
inspection.name.gwt.remote.service.is.not.registered.in.web.xml=GWT 遠端服務未在 web.xml 中註冊
inspection.name.inconsistent.gwt.localizable.interface=不一致的可本地化接口
inspection.name.inconsistent.gwt.remote.service=不一致的遠端服務
inspection.name.incorrect.argument.of.gwt.create.method=不正確的 GWT.create() 方法實參
inspection.name.incorrect.java.methods.calls.in.js=從 JavaScript 程式碼中不正確呼叫 Java 方法
inspection.name.incorrect.serializable.class=不正確的可序列化類別
inspection.name.method.with.parameters.in.interface.extending.constants=接口擴展 Constants 中帶有參數的方法
inspection.name.non.serializable.service.method.parameters=不可序列化的服務方法參數類型或返回值類型
inspection.name.obsolete.gwt.type.args.tag.in.javadoc.comments=JavaDoc 註釋中的已棄用 '@gwt.typeArgs' 標記
inspection.name.overlay.type.restrictions.violated=違反覆蓋類型限制
inspection.name.raw.use.of.async.callback.in.asynchronous.service.interfaces=在異步服務接口中原始使用 AsyncCallback
inspection.name.redundant.set.service.entry.point.methods.calls=冗餘的 'setServiceEntryPoint()' 方法呼叫
inspection.name.unresolved.references.in.jsni.methods=JSNI 方法中未解析的參照
inspection.name.unresolved.references.in.ui.xml.files=ui.xml 檔案中未解析的參照
inspection.name.unresolved.references.to.html.tags=對 html 標記的未解析參照
inspection.unresolved.references.to.css.classes.display.name=對 CSS 類別的未解析參照
intention.text.create.uifield.for.tag=為標記建立 '@UiField'
intention.text.create.uihandler.for.tag=為標記建立 '@UiHandler'
item.text.0.and.more.modules={0} 和{2, choice, 0#其他 1 個模組|1#其他 {1} 個模組}
label.choose.module.text=模組(&M):
label.gwt.0.sdk.from.maven.repository=來自 Maven 儲存庫的 GWT {0} SDK
label.gwt.module=GWT 模組(&G):
label.gwt.modules.are.not.available.while.index.update.is.in.progress=GWT 模組在索引更新期間不可用
label.gwt.sdk=GWT SDK:
label.html.to.open.text=起始頁面(&P):
label.label=標籤
label.module=模組:
label.none.facet.selected=<none>
label.select.script.output.style.text=JavaScript 輸出樣式(&O):
label.select.web.facet.text=目標 Web Facet(&W):
label.server=伺服器(&R):
label.text.0.is.used=使用了 {0}
label.text.additional.compiler.parameters=附加編譯器虛擬機選項(&A):
label.text.compile.report.was.generated.0.ago=編譯報告於 {0}前生成
label.text.download.gwt=下載 GWT
label.text.enter.name.for.new.gwt.uibinder.class.and.ui.xml.file=輸入新的 GWT UiBinder 類別和 ui.xml 檔案的名稱(&E):
label.text.enter.name.for.new.gwt.uirenderer.class.and.ui.xml.file=輸入新的 GWT UiRenderer 類別和 ui.xml 檔案的名稱(&E):
label.text.event.class.name=事件類別名(&E):
label.text.event.handler.method.name=處理方法名稱(&M):
label.text.gwt.0.sdk.from.gradle.repository=來自 Gradle 的 GWT {0} SDK
label.text.gwt.compiler.heap.size=編譯器最大堆大小 (Mb)(&H):
label.text.gwt.compiler.parameters=編譯器參數(&C):
label.text.gwt.dev.mode.parameters=開發模式參數(&D):
label.text.gwt.module.to.load=要載入的 GWT 模組(&G):
label.text.gwt.sdk.path.not.specified=未指定 GWT SDK 路徑。
label.text.handler.class.name=處理程序類別名(&H):
label.text.path.to.gwt.installation=GWT 安裝目錄路徑(&P):
label.text.select.root.element.type=指定根元素的類型(&S):
label.text.vm.parameters=虛擬機選項(&V):
library.presentation.description=GWT SDK 庫
message.text.gwt.module.chooser.isn.t.available.while.updating.indices=在 {0} 更新索引期間，GWT 模組選擇器不可用
new.entry.point.dlg.prompt=輸入新 GWT 入口點的名稱
new.entry.point.dlg.title=新增 GWT 入口點
new.entry.point.progress.text=正在建立 GWT EntryPoint ''{0}''
new.module.dlg.prompt=輸入新 GWT 模組的名稱(&E)
new.module.dlg.title=新增 GWT 模組
new.module.progress.text=正在建立 GWT 模組 ''{0}''
new.serial.dlg.prompt=輸入新的 GWT 可序列化類別的名稱
new.serial.dlg.title=新增 GWT 可序列化類別
new.serial.progress.text=正在建立 GWT 可序列化類別 ''{0}''
new.service.dlg.prompt=輸入新 GWT 遠端服務的名稱
new.service.dlg.title=新增 GWT 遠端服務
new.service.progress.text=建立 GWT 遠端服務 ''{0}''
notification.content.gwt.file.mapping.is.not.possible.during.index.update=在索引更新期間無法進行 GWT 檔案映射
notification.content.unable.to.configure.gwt.unit.tests.during.index.update=在索引更新期間無法組態 GWT 單元測試
parsing.error.rule.expected=應為規則
popup.step.title.select.artifact=選擇工件
popup.title.choose.css.file=選擇 CSS 檔案
popup.title.css.class.method.goto=<html><body>為 <b>{0}</b> 方法選擇檔案(找到 {1} 個檔案)</body></html>
popup.title.css.file.goto=<html><body>為 <b>{0}</b> 選擇檔案(找到 {1} 個檔案)</body></html>
popup.title.resource.method.goto=<html><body>為 <b>{0}</b> 選擇檔案(找到 {1} 個檔案)</body></html>
popup.title.ui.tag.file.goto=<html><body>為 <b>{0}</b> 欄位選擇 ui.xml 檔案(找到 {1} 個檔案)</body></html>
popup.title.ui.xml.file.goto=<html><body>為 <b>{0}</b> 選擇 ui.xml 檔案(找到 {1} 個檔案)</body></html>
problem.description.0.is.not.a.checked.exception=''{0}'' 不是檢查過的例外
problem.description.ambiguous.wildcard.match=不明確的萬用字元符合: ''{2}'' 中的 ''{0}'' 和 ''{1}'' 都與 ''{3}'' 符合
problem.description.async.method.does.not.have.sync.variant=方法 ''{0}'' 沒有相應的同步變體
problem.description.async.remote.service.0.does.not.define.corresponding.method=異步遠端服務 ''{0}'' 未定義相應的方法
problem.description.cannot.call.instance.method.without.object.instance=沒有物件實例，無法呼叫實例方法 ''{0}''
problem.description.cannot.resolve.0=無法解析 ''{0}''
problem.description.cannot.resolve.symbol.0.in.1=無法解析 ''{1}'' 中的符號 ''{0}''
problem.description.class.0.is.defined.in.module.1.which.is.not.inherited.in.module.2=類別 ''{0}'' 在模組 ''{1}'' 中定義，而該模組在模組 ''{2}'' 中未被繼承
problem.description.class.0.is.not.presented.in.jre.emulation.library=JRE 仿真庫中不存在類別 ''{0}''，因此不能在 ''{1}'' GWT 模組的客戶端程式碼中使用
problem.description.class.is.not.widget=類別 ''{0}'' 未實作 ''IsWidget'' 接口
problem.description.constructor.in.overlay.type.cannot.have.parameters=覆蓋類型中的建構函式不能有參數
problem.description.constructor.in.overlay.type.must.be.protected=覆蓋類型中的建構函式必須為 protected
problem.description.constructor.in.overlay.type.must.have.empty.body=覆蓋類型中的建構函式的主體必須為空
problem.description.correct.servlet.mapping.is.not.specified.for.remote.service.0=沒有為遠端服務 ''{0}'' 指定正確的 servlet 映射
problem.description.field.0.is.not.serializable=類型 ''{0}'' 不可序列化
problem.description.generics.isnt.supported.in.gwt.before.1.5.version=1.5 版之前的 GWT 不支持泛型
problem.description.gwt.key.tag.is.deprecated.in.gwt.1.5='@gwt.key' 標記在 GWT 1.5 中被棄用
problem.description.gwt.serializable.type.0.should.implements.marker.interface.1=類型 ''{0}'' 未實作標記接口 {1}
problem.description.gwt.type.args.tag.is.obsolete.in.gwt.1.5='@gwt.typeArgs' 標記在 GWT 1.5 中被棄用
problem.description.html.tag.with.id.0.is.not.found=找不到 ID 為 ''{0}'' 的 HTML 標記
problem.description.inconsistent.element.type=UiBinder 接口形參與 ''{0}'' 標記不一致。應為 ''{1}'' 或其超類別
problem.description.incorrect.number.of.arguments.for.method=''{0}'' 方法的實參數量不正確: 應為 {1} 個，但實際為 {2} 個
problem.description.incorrect.servlet.mapping.for.remote.service.0=遠端服務 ''{0}'' 的 URL 格式不正確
problem.description.inner.classes.in.overlay.type.must.be.static=覆蓋類型中的內部類別必須為 static
problem.description.instance.methods.in.overlay.type.must.be.final=覆蓋類型中的實例方法必須為 final
problem.description.method.0.does.not.have.corresponding.property=方法 ''{0}'' 沒有對應的屬性
problem.description.method.0.is.not.presented.in.jre.emulation.library=JRE 仿真庫中不存在方法 ''{0}''，因此不能在 ''{1}'' GWT 模組的客戶端程式碼中使用
problem.description.methods.of.async.remote.service.0.isn.t.synchronized.with.1=異步遠端服務 ''{0}'' 的方法與 ''{1}'' 不一致
problem.description.methods.with.parameters.are.not.allowed.in.an.interface.extending.constants=接口擴展 Constants 中不允許使用帶有參數的方法
problem.description.only.class.literals.may.be.used.as.arguments.to.gwt.create=只能將類別文字用作 GWT.create() 的實參
problem.description.overlay.type.cannot.have.instance.fields=覆蓋類型不能包含實例欄位
problem.description.overlay.type.must.have.protected.empty.no.arg.constructor=覆蓋類型必須具有不帶參數的 protected 空建構函式
problem.description.properties.with.parameters.are.not.allowed.if.the.associated.interface.extends.constants=如果關聯接口擴展 Constants，則不允許使用帶有參數的屬性
problem.description.property.0.does.not.have.corresponding.method.in.1=屬性 ''{0}'' 在 ''{1}'' 中沒有對應的方法
problem.description.raw.use.of.async.callback.interface=在方法 ''{0}'' 中原始使用 AsyncCallback 接口
problem.description.remote.service.0.does.not.have.corresponding.async.variant=遠端服務 ''{0}'' 沒有相應的異步變體
problem.description.remote.service.is.not.registered.as.a.servlet.in.web.xml=遠端服務 ''{0}'' 未在 web.xml 中註冊為 servlet。
problem.description.serializable.class.should.provide.public.no.args.constructor=可序列化的類別應提供 public 無實參建構函式
problem.description.the.asynchronous.version.of.method.0.must.have.a.return.type.void=方法 ''{0}'' 的異步版本必須具有返回值類型 ''void''、\n''com.google.gwt.http.client.Request'' 或 ''com.google.gwt.http.client.RequestBuilder''
problem.description.type.is.not.serializable=類型 ''{0}'' 不可序列化
problem.description.type.of.collection.elements.is.not.specified=未指定 ''{0}'' 元素的類型
problem.description.ui.xml.not.found=UiBinder 接口沒有對應的 ui.xml 檔案
problem.description.ui.xml.root.ambiguity=在對應的 ui.xml 檔案中檢測到過多根標記
problem.description.ui.xml.root.not.found=無法在對應的 ui.xml 檔案中檢測到根標記
problem.description.unknown.css.class=未知 CSS 類別 ''{0}''
problem.descriptor.description.template.0.field.is.not.bound.to.tag.in.1.file=''{0}'' 欄位未綁定到 ''{1}'' 檔案中的標記
problem.descriptor.description.template.0.is.not.annotated.with.uifield=''{0}'' 未使用 @UiField 進行註解
problem.descriptor.description.template.cannot.get.eventhandler.type.for.0=無法獲取 ''{0}'' 的 EventHandler 類型
problem.descriptor.description.template.cannot.get.eventhandler.type.for.02=無法獲取 ''{0}'' 的 EventHandler 類型
problem.descriptor.description.template.cannot.resolve.0.field=無法解析 ''{0}'' 欄位
problem.descriptor.description.template.duplicate.declaration.bound.to.0.field=綁定到 ''{0}'' 欄位的宣告重複
problem.descriptor.description.template.expected.0.but.1.found=應為 ''{0}''，但實際為 ''{1}''
problem.descriptor.description.template.field.0.does.not.have.addhandler.method.for.1=欄位 ''{0}'' 沒有用於 ''{1}'' 的 ''addHandler'' 方法
problem.descriptor.description.template.handler.0.cannot.be.registered.methods.1.and.2.are.ambiguous=無法註冊處理程序 ''{0}'': 方法 ''{1}'' 和 ''{2}'' 不明確
problem.descriptor.description.template.handler.class.0.1=處理程序類別 ''{0}'' {1, choice, 0#沒有方法|2#定義了一個以上的方法}
problem.descriptor.description.template.handler.method.0.signature.does.not.match.1.signature=處理程序方法 ''{0}'' 簽名與 ''{1}'' 簽名不符合
problem.descriptor.description.template.parameter.0.is.not.an.event.subclass.of.gwtevent=參數 ''{0}'' 不是事件(GwtEvent 的子類別)
problem.descriptor.description.template.uibinder.class.not.found.for.0=找不到 ''{0}'' 的 UiBinder 類別
problem.descriptor.description.template.uifield.0.should.not.be.private=@UiField ''{0}'' 不應為 ''private''
problem.descriptor.description.template.uihandler.0.must.have.a.single.event.parameter.defined=@UiHandler ''{0}'' 必須只定義一個事件參數
problem.descriptor.description.template.uihandler.0.must.have.at.least.one.parameter.defined=@UiHandler ''{0}'' 必須至少定義一個參數
problem.descriptor.description.template.uihandler.0.should.not.be.private=''@UiHandler ''{0}'' 不應為 ''private''
progress.indicator.copying.files=正在複製檔案…
progress.indicator.deleting.obsolete.files=正在刪除過時的檔案…
progress.indicator.processing.files=正在處理檔案…
psi.viewer.name.gwt.ui.xml.file=GWT ui.xml 檔案
question.text.gwt.facet.is.not.configured.for.module.0.do.you.want.to.create.it=沒有為模組 ''{0}'' 組態 GWT Facet。是否要建立?
quick.fix.name.rename.reference=重新命名參照
quick.fix.name.synchronize.all.methods.of.0.with.1=將 ''{0}'' 的所有方法與 ''{1}'' 同步
quickfix.family.name.add.servlet.mapping.for.remote.service=為遠端服務新增 servlet 映射
quickfix.family.name.change.field.type=更改欄位類型
quickfix.family.name.connect.gwt.facet.and.register.remote.service.in.web.xml=連線 GWT Facet 並在 'web.xml' 中註冊遠端服務
quickfix.family.name.create.async.variant=建立異步變體
quickfix.family.name.create.css.class=建立 CSS 類別
quickfix.family.name.create.def.declaration=建立 '@def' 宣告
quickfix.family.name.create.interface=建立接口
quickfix.family.name.create.local.css.class=建立區域 CSS 類別
quickfix.family.name.create.missing.methods=建立缺少的方法
quickfix.family.name.create.property=建立屬性
quickfix.family.name.create.sync.variant=建立同步變體
quickfix.family.name.create.web.facet.and.register.remote.service.in.web.xml=建立 Web Facet 並在 'web.xml' 中註冊遠端服務
quickfix.family.name.generify.types.in.method=使用參數化類型
quickfix.family.name.inherit.from.messages.instead.of.constants=將 Constants 取代為 Messages
quickfix.family.name.inherit.module=繼承模組
quickfix.family.name.make.method.return.void=使方法返回 'void'
quickfix.family.name.register.remote.service.in.web.xml=在 'web.xml' 中註冊遠端服務
quickfix.family.name.register.subpackage=註冊子軟體套件
quickfix.family.name.replace.async.callback.by.generic.async.callback=泛化 'AsyncCallback'
quickfix.family.name.replace.gwt.key.tag.with.key.annotation=將 '@gwt.key' 標記取代為 @Key 註解
quickfix.family.name.replace.listener.with.handler=將偵聽器取代為處理程序
quickfix.family.name.set.servlet.mapping.for.remote.service=為遠端服務設定正確的 URL 格式
quickfix.name.0.css.class.or.def.element.not.found=找不到 ''{0}'' css 類別或 ''@def'' 元素
quickfix.name.add.servlet.mapping.for.remote.service.0=為遠端服務 ''{0}'' 新增 servlet 映射
quickfix.name.change.0.type.to.1=將 ''{0}'' 類型更改為 ''{1}''
quickfix.name.connect.gwt.facet.to.0.facet.and.register.remote.service.1.in.web.xml=將 GWT Facet 連線到 ''{0}'' Facet，並在 ''web.xml'' 中註冊遠端服務 ''{1}''
quickfix.name.create.0.method=建立 ''{0}'' 方法
quickfix.name.create.async.method.for.sync.0=為方法 ''{0}'' 建立異步變體
quickfix.name.create.css.class.0=建立 CSS 類別 ''{0}''
quickfix.name.create.def.declaration.for.0=為 ''{0}'' 建立 ''@def'' 宣告
quickfix.name.create.interface.0=建立接口 ''{0}''
quickfix.name.create.local.css.class.0=建立區域 CSS 類別 ''{0}''
quickfix.name.create.method.for.0=為 ''{0}'' 建立方法
quickfix.name.create.method.for.property.0.in.1=為 ''{1}'' 中的屬性 ''{0}'' 建立方法
quickfix.name.create.missing.methods=建立缺少的方法
quickfix.name.create.property.0=建立屬性 ''{0}''
quickfix.name.create.sync.method.for.async.0=為方法 ''{0}'' 建立同步變體
quickfix.name.create.web.facet.and.register.remote.service.0.in.web.xml=建立 Web Facet 並在 ''web.xml'' 中註冊遠端服務 ''{0}''
quickfix.name.generify.types.in.method.0.instead.of.using.gwt.type.args.tags=在方法 ''{0}'' 中使用參數化類型，不使用 ''@gwt.typeArgs'' 標記
quickfix.name.inherit.0.from.messages.instead.of.constants=從訊息而不是 Constants 繼承 ''{0}''
quickfix.name.inherit.module.0.from.1=從 ''{1}'' 整合模組 ''{0}''
quickfix.name.make.0.return.void=使 ''{0}'' 返回 ''void''
quickfix.name.register.0.subpackage.as.1.path=將 ''{0}'' 子軟體套件註冊為 {1} 路徑
quickfix.name.register.remote.service.0.in.web.xml=在 ''web.xml'' 中註冊遠端服務 ''{0}''
quickfix.name.remove.redundant.set.service.entry.point.call=移除冗餘的 'setServiceEntryPoint()' 呼叫
quickfix.name.replace.0.with.1=將 ''{0}'' 取代為 ''{1}''
quickfix.name.replace.async.callback.by.async.callback.0=將 ''AsyncCallback'' 取代為 ''AsyncCallback<{0}>''
quickfix.name.replace.gwt.key.tag.with.key.annotation.in.method.0=將 ''@gwt.key'' 標記取代為方法 ''{0}'' 中的 @Key 註解
quickfix.name.replace.set.service.entry.point.call.by.annotation=通過註解取代 'setServiceEntryPoint()' 呼叫
quickfix.name.set.correct.servlet.mapping.for.remote.service.0=為遠端服務 ''{0}'' 設定正確的 URL 格式
quickfix.name.set.provided.to.true=將 'provided' 特性設定為 'true'
quickfix.name.synchronize.all.methods.in.0=將所有缺少的方法新增到 ''{0}''
quickfix.popup.title.choose.properties.file=選擇屬性檔案
quickfix.text.create.artifact=建立工件
quickfix.text.include.in.artifact=包含在工件中
quickfix.text.include.into.0=包含到 ''{0}'' 中
run.gwt.configuration.description=GWT 組態
run.gwt.configuration.display.name=GWT 組態
running.app.updater.description.update.0=更新 ''{0}''
status.bar.text.gwt.dev.mode.resources.for.0.updated=''{0}'' 的 GWT 開發模式資源{2, choice, 0#已於 {1} 更新|1#已處於最新狀態}
tab.title.0.gwt.output=''{0}'' GWT 輸出
table.column.name.gwt.module=GWT 模組
table.column.name.output.relative.path=輸出相對路徑
task.title.looking.for.changed.classes=正在尋找更改的類別
task.title.preparing.war.directory.for.gwt.dev.mode=為 GWT 開發模式準備 WAR 目錄
task.title.updating.gwt.dev.mode.resources=正在更新 GWT 開發模式資源
text.0.or.1=''{0}'' 或 ''{1}''
text.gwt.modules.to.load.all=所有
text.gwt.modules.to.load.none=無
tooltip.gwt.modules.without.entry.points.cannot.be.compiled=無法編譯沒有入口點的 GWT 模組
tooltip.text.css.class.method.gutter=方法{0, choice, 1#有|2#有}  個關聯的 css {0, choice, 1#類別|2#類別}
tooltip.text.css.declaration.method.gutter=方法{0, choice, 1#有|2#有}  個關聯的 css {0, choice, 1#元素|2#元素}
tooltip.text.css.file.gutter=類別{0, choice, 1#有|2#有} {0} 個關聯的 css {0, choice, 1#檔案|2#檔案}
tooltip.text.resource.method.gutter=方法{0, choice, 1#有|2#有} {0} 個關聯的資源{0, choice, 1#檔案|2#檔案}
tooltip.text.ui.tag.file.gutter=欄位在 {0} 個 ui.xml {0, choice, 1#檔案|2#檔案}中{0, choice, 1#有|2#有} 個關聯的{0, choice, 1#標籤|2#標籤}
tooltip.text.ui.xml.file.gutter=類別{0, choice, 1#有|2#有} {0} 個關聯的 ui.xml {0, choice, 1#檔案|2#檔案}
validation.result.gwt.compiler.output.is.not.included.in.an.artifact=GWT 編譯器輸出未包含在工件中
validation.result.gwt.servlet.jar.is.not.included.in.0.artifact=gwt-servlet.jar 不包含在工件 ''{0}'' 中